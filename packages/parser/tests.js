const rewire = require(`rewire`)
const index = rewire(`./index`)

const get = name => index.__get__(name)
const set = (name, value) => {
  let replaced
  beforeEach(() => {
    replaced = index.__get__(name)
    index.__set__(name, value)
  })
  afterEach(() => {
    index.__set__(name, replaced)
  })
  return value
}

const setSpy = name => set(name, jasmine.createSpy(name))

describe(`linerCreate`, () => {
  it(`returns an object`, () => expect(get(`linerCreate`)(`Test Context`, `Test On Line`)).toEqual(jasmine.any(Object)))
  it(`returns line, 1`, () => expect(get(`linerCreate`)(`Test Context`, `Test On Line`).line).toEqual(1))
  it(`returns text, empty`, () => expect(get(`linerCreate`)(`Test Context`, `Test On Line`).text).toEqual(``))
  it(`returns lineComment, null`, () => expect(get(`linerCreate`)(`Test Context`, `Test On Line`).lineComment).toBeNull())
  it(`returns context, given`, () => expect(get(`linerCreate`)(`Test Context`, `Test On Line`).context).toEqual(`Test Context`))
  it(`returns onLine, given`, () => expect(get(`linerCreate`)(`Test Context`, `Test On Line`).onLine).toEqual(`Test On Line`))
  it(`returns a new object every call`, () => expect(get(`linerCreate`)(`Test Context`, `Test On Line`)).not.toBe(get(`linerCreate`)(`Test Context`, `Test On Line`)))
  it(`returns the same value every call`, () => expect(get(`linerCreate`)(`Test Context`, `Test On Line`)).toEqual(get(`linerCreate`)(`Test Context`, `Test On Line`)))
})

describe(`linerClassifyCharacter`, () => {
  const run = (input, output) => describe(`given "${input}"`, () => it(`returns "${output}"`, () => get(`linerClassifyCharacter`)(input)))
  run(`a`, `partOfLine`)
  run(`d`, `partOfLine`)
  run(`q`, `partOfLine`)
  run(`z`, `partOfLine`)
  run(`0`, `partOfLine`)
  run(`4`, `partOfLine`)
  run(`9`, `partOfLine`)
  run(`0`, `partOfLine`)
  run(`!`, `partOfLine`)
  run(`$`, `partOfLine`)
  run(`?`, `partOfLine`)
  run(`か`, `partOfLine`)
  run(` `, `partOfLine`)
  run(`\t`, `partOfLine`)
  run(`\r`, `newLine`)
  run(`\n`, `newLine`)
  run(`#`, `lineComment`)
})

describe(`linerTextNotEmpty`, () => {
  const run = (input, output) => describe(`given "${input}"`, () => it(`returns ${output}`, () => get(`linerTextNotEmpty`)(input)))
  run(``, false)
  run(` `, false)
  run(`\t`, false)
  run(`   \t     \t  `, false)
  run(`a`, true)
  run(` a`, true)
  run(`\ta`, true)
  run(`   \t     \t  a`, true)
  run(`awdhk\tauwdh iyi`, true)
  run(` awdhk\tauwdh iyi`, true)
  run(`\tawdhk\tauwdh iyi`, true)
  run(`   \t     \t  awdhk auwdh iyi`, true)
  run(`awdhk\tauwdh iyi `, true)
  run(`awdhk\tauwdh iyi\t`, true)
  run(`awdhk\tauwdh iyi   \t     \t  `, true)
  run(` awdhk\tauwdh iyi `, true)
  run(` awdhk\tauwdh iyi\t`, true)
  run(` awdhk\tauwdh iyi   \t     \t  `, true)
  run(`\tawdhk\tauwdh iyi `, true)
  run(`\tawdhk\tauwdh iyi\t`, true)
  run(`\tawdhk\tauwdh iyi   \t     \t  `, true)
  run(`  \t \t  \t  awdhk\tauwdh iyi `, true)
  run(`  \t \t  \t  awdhk\tauwdh iyi\t`, true)
  run(`  \t \t  \t  awdhk\tauwdh iyi   \t     \t  `, true)
})

describe(`linerCharacter`, () => {
  const linerClassifyCharacter = setSpy(`linerClassifyCharacter`)
  const linerTextNotEmpty = setSpy(`linerTextNotEmpty`)
  const onLine = jasmine.createSpy(`onLine`)
  afterEach(() => {
    linerClassifyCharacter.calls.reset()
    linerTextNotEmpty.calls.reset()
    onLine.calls.reset()
  })
  let liner
  beforeEach(() => liner = {
    line: 2368,
    text: `Test Text`,
    context: `Test Context`,
    onLine
  })

  describe(`when not inside a line comment`, () => {
    beforeEach(() => liner.lineComment = null)
    describe(`when given a line comment`, () => {
      beforeEach(() => {
        linerClassifyCharacter.and.returnValue(`lineComment`)
        get(`linerCharacter`)(liner, `Test Character`)
      })
      it(`does not change line`, () => expect(liner.line).toEqual(2368))
      it(`does not change text`, () => expect(liner.text).toEqual(`Test Text`))
      it(`starts a line comment`, () => expect(liner.lineComment).toEqual(`Test Character`))
      it(`does not change the context`, () => expect(liner.context).toEqual(`Test Context`))
      it(`does not change onLine`, () => expect(liner.onLine).toBe(onLine))
      it(`calls linerClassifyCharacter once`, () => expect(linerClassifyCharacter).toHaveBeenCalledTimes(1))
      it(`calls linerClassifyCharacter with the given character`, () => expect(linerClassifyCharacter).toHaveBeenCalledWith(`Test Character`))
      it(`does not call linerTextNotEmpty`, () => expect(linerTextNotEmpty).not.toHaveBeenCalled())
      it(`does not call onLine`, () => expect(onLine).not.toHaveBeenCalled())
    })

    describe(`when given a new line`, () => {
      beforeEach(() => linerClassifyCharacter.and.returnValue(`newLine`))
      describe(`when the accumulated text is empty`, () => {
        beforeEach(() => {
          linerTextNotEmpty.and.returnValue(false)
          get(`linerCharacter`)(liner, `Test Character`)
        })
        it(`increments line`, () => expect(liner.line).toEqual(2369))
        it(`empties text`, () => expect(liner.text).toEqual(``))
        it(`does not start a line comment`, () => expect(liner.lineComment).toBeNull())
        it(`does not change the context`, () => expect(liner.context).toEqual(`Test Context`))
        it(`does not change onLine`, () => expect(liner.onLine).toBe(onLine))
        it(`calls linerClassifyCharacter once`, () => expect(linerClassifyCharacter).toHaveBeenCalledTimes(1))
        it(`calls linerClassifyCharacter with the given character`, () => expect(linerClassifyCharacter).toHaveBeenCalledWith(`Test Character`))
        it(`calls linerTextNotEmpty once`, () => expect(linerTextNotEmpty).toHaveBeenCalledTimes(1))
        it(`calls linerTextNotEmpty with the text`, () => expect(linerTextNotEmpty).toHaveBeenCalledWith(`Test Text`))
        it(`does not call onLine`, () => expect(onLine).not.toHaveBeenCalled())
      })

      describe(`when the accumulated text is not empty`, () => {
        beforeEach(() => {
          linerTextNotEmpty.and.returnValue(true)
          get(`linerCharacter`)(liner, `Test Character`)
        })
        it(`increments line`, () => expect(liner.line).toEqual(2369))
        it(`empties text`, () => expect(liner.text).toEqual(``))
        it(`does not start a line comment`, () => expect(liner.lineComment).toBeNull())
        it(`does not change the context`, () => expect(liner.context).toEqual(`Test Context`))
        it(`does not change onLine`, () => expect(liner.onLine).toBe(onLine))
        it(`calls linerClassifyCharacter once`, () => expect(linerClassifyCharacter).toHaveBeenCalledTimes(1))
        it(`calls linerClassifyCharacter with the given character`, () => expect(linerClassifyCharacter).toHaveBeenCalledWith(`Test Character`))
        it(`calls linerTextNotEmpty once`, () => expect(linerTextNotEmpty).toHaveBeenCalledTimes(1))
        it(`calls linerTextNotEmpty with the text`, () => expect(linerTextNotEmpty).toHaveBeenCalledWith(`Test Text`))
        it(`calls onLine once`, () => expect(onLine).toHaveBeenCalledTimes(1))
        it(`calls onLine with the context`, () => expect(onLine).toHaveBeenCalledWith(`Test Context`, jasmine.anything(), jasmine.anything()))
        it(`calls onLine with the line number`, () => expect(onLine).toHaveBeenCalledWith(jasmine.anything(), 2368, jasmine.anything()))
        it(`calls onLine with the text`, () => expect(onLine).toHaveBeenCalledWith(jasmine.anything(), jasmine.anything(), `Test Text`))
      })
    })

    describe(`when given a part of line`, () => {
      beforeEach(() => {
        linerClassifyCharacter.and.returnValue(`partOfLine`)
        get(`linerCharacter`)(liner, `Test Character`)
      })
      it(`does not change line`, () => expect(liner.line).toEqual(2368))
      it(`appends it to the end of text`, () => expect(liner.text).toEqual(`Test TextTest Character`))
      it(`does not start a line comment`, () => expect(liner.lineComment).toBeNull())
      it(`does not change the context`, () => expect(liner.context).toEqual(`Test Context`))
      it(`does not change onLine`, () => expect(liner.onLine).toBe(onLine))
      it(`calls linerClassifyCharacter once`, () => expect(linerClassifyCharacter).toHaveBeenCalledTimes(1))
      it(`calls linerClassifyCharacter with the given character`, () => expect(linerClassifyCharacter).toHaveBeenCalledWith(`Test Character`))
      it(`does not call linerTextNotEmpty`, () => expect(linerTextNotEmpty).not.toHaveBeenCalled())
      it(`does not call onLine`, () => expect(onLine).not.toHaveBeenCalled())
    })
  })

  describe(`when in a line comment`, () => {
    beforeEach(() => liner.lineComment = `Test Line Comment`)
    describe(`when given a line comment`, () => {
      beforeEach(() => {
        linerClassifyCharacter.and.returnValue(`lineComment`)
        get(`linerCharacter`)(liner, `Test Character`)
      })
      it(`does not change line`, () => expect(liner.line).toEqual(2368))
      it(`does not change text`, () => expect(liner.text).toEqual(`Test Text`))
      it(`appends it to the end of the line comment`, () => expect(liner.lineComment).toEqual(`Test Line CommentTest Character`))
      it(`does not change the context`, () => expect(liner.context).toEqual(`Test Context`))
      it(`does not change onLine`, () => expect(liner.onLine).toBe(onLine))
      it(`calls linerClassifyCharacter once`, () => expect(linerClassifyCharacter).toHaveBeenCalledTimes(1))
      it(`calls linerClassifyCharacter with the given character`, () => expect(linerClassifyCharacter).toHaveBeenCalledWith(`Test Character`))
      it(`does not call linerTextNotEmpty`, () => expect(linerTextNotEmpty).not.toHaveBeenCalled())
      it(`does not call onLine`, () => expect(onLine).not.toHaveBeenCalled())
    })

    describe(`when given a new line`, () => {
      beforeEach(() => linerClassifyCharacter.and.returnValue(`newLine`))
      describe(`when the accumulated text is empty`, () => {
        beforeEach(() => {
          linerTextNotEmpty.and.returnValue(false)
          get(`linerCharacter`)(liner, `Test Character`)
        })
        it(`increments line`, () => expect(liner.line).toEqual(2369))
        it(`empties text`, () => expect(liner.text).toEqual(``))
        it(`ends the line comment`, () => expect(liner.lineComment).toBeNull())
        it(`does not change the context`, () => expect(liner.context).toEqual(`Test Context`))
        it(`does not change onLine`, () => expect(liner.onLine).toBe(onLine))
        it(`calls linerClassifyCharacter once`, () => expect(linerClassifyCharacter).toHaveBeenCalledTimes(1))
        it(`calls linerClassifyCharacter with the given character`, () => expect(linerClassifyCharacter).toHaveBeenCalledWith(`Test Character`))
        it(`calls linerTextNotEmpty once`, () => expect(linerTextNotEmpty).toHaveBeenCalledTimes(1))
        it(`calls linerTextNotEmpty with the text`, () => expect(linerTextNotEmpty).toHaveBeenCalledWith(`Test Text`))
        it(`does not call onLine`, () => expect(onLine).not.toHaveBeenCalled())
      })

      describe(`when the accumulated text is not empty`, () => {
        beforeEach(() => {
          linerTextNotEmpty.and.returnValue(true)
          get(`linerCharacter`)(liner, `Test Character`)
        })
        it(`increments line`, () => expect(liner.line).toEqual(2369))
        it(`empties text`, () => expect(liner.text).toEqual(``))
        it(`ends the line comment`, () => expect(liner.lineComment).toBeNull())
        it(`does not change the context`, () => expect(liner.context).toEqual(`Test Context`))
        it(`does not change onLine`, () => expect(liner.onLine).toBe(onLine))
        it(`calls linerClassifyCharacter once`, () => expect(linerClassifyCharacter).toHaveBeenCalledTimes(1))
        it(`calls linerClassifyCharacter with the given character`, () => expect(linerClassifyCharacter).toHaveBeenCalledWith(`Test Character`))
        it(`calls linerTextNotEmpty once`, () => expect(linerTextNotEmpty).toHaveBeenCalledTimes(1))
        it(`calls linerTextNotEmpty with the text`, () => expect(linerTextNotEmpty).toHaveBeenCalledWith(`Test Text`))
        it(`calls onLine once`, () => expect(onLine).toHaveBeenCalledTimes(1))
        it(`calls onLine with the context`, () => expect(onLine).toHaveBeenCalledWith(`Test Context`, jasmine.anything(), jasmine.anything()))
        it(`calls onLine with the line number`, () => expect(onLine).toHaveBeenCalledWith(jasmine.anything(), 2368, jasmine.anything()))
        it(`calls onLine with the text`, () => expect(onLine).toHaveBeenCalledWith(jasmine.anything(), jasmine.anything(), `Test Text`))
      })
    })

    describe(`when given a part of line`, () => {
      beforeEach(() => {
        linerClassifyCharacter.and.returnValue(`partOfLine`)
        get(`linerCharacter`)(liner, `Test Character`)
      })
      it(`does not change line`, () => expect(liner.line).toEqual(2368))
      it(`does not change text`, () => expect(liner.text).toEqual(`Test Text`))
      it(`appends it to the end of the line comment`, () => expect(liner.lineComment).toEqual(`Test Line CommentTest Character`))
      it(`does not change the context`, () => expect(liner.context).toEqual(`Test Context`))
      it(`does not change onLine`, () => expect(liner.onLine).toBe(onLine))
      it(`calls linerClassifyCharacter once`, () => expect(linerClassifyCharacter).toHaveBeenCalledTimes(1))
      it(`calls linerClassifyCharacter with the given character`, () => expect(linerClassifyCharacter).toHaveBeenCalledWith(`Test Character`))
      it(`does not call linerTextNotEmpty`, () => expect(linerTextNotEmpty).not.toHaveBeenCalled())
      it(`does not call onLine`, () => expect(onLine).not.toHaveBeenCalled())
    })
  })
})

describe(`linerEndOfFile`, () => {
  const linerClassifyCharacter = setSpy(`linerClassifyCharacter`)
  const linerTextNotEmpty = setSpy(`linerTextNotEmpty`)
  const onLine = jasmine.createSpy(`onLine`)
  afterEach(() => {
    linerClassifyCharacter.calls.reset()
    linerTextNotEmpty.calls.reset()
    onLine.calls.reset()
  })
  let liner
  beforeEach(() => liner = {
    line: 2368,
    text: `Test Text`,
    context: `Test Context`,
    onLine
  })

  describe(`when not in a line comment`, () => {
    beforeEach(() => liner.lineComment = null)

    describe(`when the accumulated text is empty`, () => {
      beforeEach(() => {
        linerTextNotEmpty.and.returnValue(false)
        get(`linerEndOfFile`)(liner)
      })
      it(`does not call linerClassifyCharacter`, () => expect(linerClassifyCharacter).not.toHaveBeenCalled())
      it(`calls linerTextNotEmpty once`, () => expect(linerTextNotEmpty).toHaveBeenCalledTimes(1))
      it(`calls linerTextNotEmpty with the text`, () => expect(linerTextNotEmpty).toHaveBeenCalledWith(`Test Text`))
      it(`does not call onLine`, () => expect(onLine).not.toHaveBeenCalled())
    })

    describe(`when the accumulated text is not empty`, () => {
      beforeEach(() => {
        linerTextNotEmpty.and.returnValue(true)
        get(`linerEndOfFile`)(liner)
      })
      it(`does not call linerClassifyCharacter`, () => expect(linerClassifyCharacter).not.toHaveBeenCalled())
      it(`calls linerTextNotEmpty once`, () => expect(linerTextNotEmpty).toHaveBeenCalledTimes(1))
      it(`calls linerTextNotEmpty with the text`, () => expect(linerTextNotEmpty).toHaveBeenCalledWith(`Test Text`))
      it(`calls onLine once`, () => expect(onLine).toHaveBeenCalledTimes(1))
      it(`calls onLine with the context`, () => expect(onLine).toHaveBeenCalledWith(`Test Context`, jasmine.anything(), jasmine.anything()))
      it(`calls onLine with the line number`, () => expect(onLine).toHaveBeenCalledWith(jasmine.anything(), 2368, jasmine.anything()))
      it(`calls onLine with the text`, () => expect(onLine).toHaveBeenCalledWith(jasmine.anything(), jasmine.anything(), `Test Text`))
    })
  })

  describe(`when in a line comment`, () => {
    beforeEach(() => liner.lineComment = `Test Line Comment`)

    describe(`when the accumulated text is empty`, () => {
      beforeEach(() => {
        linerTextNotEmpty.and.returnValue(false)
        get(`linerEndOfFile`)(liner)
      })
      it(`does not call linerClassifyCharacter`, () => expect(linerClassifyCharacter).not.toHaveBeenCalled())
      it(`calls linerTextNotEmpty once`, () => expect(linerTextNotEmpty).toHaveBeenCalledTimes(1))
      it(`calls linerTextNotEmpty with the text`, () => expect(linerTextNotEmpty).toHaveBeenCalledWith(`Test Text`))
      it(`does not call onLine`, () => expect(onLine).not.toHaveBeenCalled())
    })

    describe(`when the accumulated text is not empty`, () => {
      beforeEach(() => {
        linerTextNotEmpty.and.returnValue(true)
        get(`linerEndOfFile`)(liner)
      })
      it(`does not call linerClassifyCharacter`, () => expect(linerClassifyCharacter).not.toHaveBeenCalled())
      it(`calls linerTextNotEmpty once`, () => expect(linerTextNotEmpty).toHaveBeenCalledTimes(1))
      it(`calls linerTextNotEmpty with the text`, () => expect(linerTextNotEmpty).toHaveBeenCalledWith(`Test Text`))
      it(`calls onLine once`, () => expect(onLine).toHaveBeenCalledTimes(1))
      it(`calls onLine with the context`, () => expect(onLine).toHaveBeenCalledWith(`Test Context`, jasmine.anything(), jasmine.anything()))
      it(`calls onLine with the line number`, () => expect(onLine).toHaveBeenCalledWith(jasmine.anything(), 2368, jasmine.anything()))
      it(`calls onLine with the text`, () => expect(onLine).toHaveBeenCalledWith(jasmine.anything(), jasmine.anything(), `Test Text`))
    })
  })
})

describe(`indenterCreate`, () => {
  it(`returns an object`, () => expect(get(`indenterCreate`)(`Test Context`, `Test On Line`, `Test On Indent`, `Test On Outdent`, `Test On Error`)).toEqual(jasmine.any(Object)))
  it(`returns stack, an array containing zero`, () => expect(get(`indenterCreate`)(`Test Context`, `Test On Line`, `Test On Indent`, `Test On Outdent`, `Test On Error`).stack).toEqual([0]))
  it(`returns indentationCharacter, null`, () => expect(get(`indenterCreate`)(`Test Context`, `Test On Line`, `Test On Indent`, `Test On Outdent`, `Test On Error`).indentationCharacter).toBeNull())
  it(`returns context, given`, () => expect(get(`indenterCreate`)(`Test Context`, `Test On Line`, `Test On Indent`, `Test On Outdent`, `Test On Error`).context).toEqual(`Test Context`))
  it(`returns onLine, given`, () => expect(get(`indenterCreate`)(`Test Context`, `Test On Line`, `Test On Indent`, `Test On Outdent`, `Test On Error`).onLine).toEqual(`Test On Line`))
  it(`returns onIndent, given`, () => expect(get(`indenterCreate`)(`Test Context`, `Test On Line`, `Test On Indent`, `Test On Outdent`, `Test On Error`).onIndent).toEqual(`Test On Indent`))
  it(`returns onOutdent, given`, () => expect(get(`indenterCreate`)(`Test Context`, `Test On Line`, `Test On Indent`, `Test On Outdent`, `Test On Error`).onOutdent).toEqual(`Test On Outdent`))
  it(`returns onError, given`, () => expect(get(`indenterCreate`)(`Test Context`, `Test On Line`, `Test On Indent`, `Test On Outdent`, `Test On Error`).onError).toEqual(`Test On Error`))
  it(`returns a new object every call`, () => expect(get(`indenterCreate`)(`Test Context`, `Test On Line`, `Test On Indent`, `Test On Outdent`, `Test On Error`)).not.toBe(get(`indenterCreate`)(`Test Context`, `Test On Line`, `Test On Indent`, `Test On Outdent`, `Test On Error`)))
  it(`returns a new stack every call`, () => expect(get(`indenterCreate`)(`Test Context`, `Test On Line`, `Test On Indent`, `Test On Outdent`, `Test On Error`).stack).not.toBe(get(`indenterCreate`)(`Test Context`, `Test On Line`, `Test On Indent`, `Test On Outdent`, `Test On Error`).stack))
  it(`returns the same value every call`, () => expect(get(`indenterCreate`)(`Test Context`, `Test On Line`, `Test On Indent`, `Test On Outdent`, `Test On Error`)).toEqual(get(`indenterCreate`)(`Test Context`, `Test On Line`, `Test On Indent`, `Test On Outdent`, `Test On Error`)))
})

describe(`indenterExtractIndentation`, () => {
  const run = (input, output) => describe(`given "${input}"`, () => it(`returns ${output}`, () => get(`indenterExtractIndentation`)(input)))
  run(``, ``)
  run(` `, ` `)
  run(`\t`, `\t`)
  run(`   \t     \t  `, `   \t     \t  `)
  run(`a`, ``)
  run(` a`, ` `)
  run(`\ta`, `\t`)
  run(`   \t     \t  a`, `   \t     \t  `)
  run(`awdhk\tauwdh iyi`, ``)
  run(` awdhk\tauwdh iyi`, ` `)
  run(`\tawdhk\tauwdh iyi`, `\t`)
  run(`   \t     \t  awdhk auwdh iyi`, `   \t     \t  `)
  run(`awdhk\tauwdh iyi `, ``)
  run(`awdhk\tauwdh iyi\t`, ``)
  run(`awdhk\tauwdh iyi   \t     \t  `, ``)
  run(` awdhk\tauwdh iyi `, ` `)
  run(` awdhk\tauwdh iyi\t`, ` `)
  run(` awdhk\tauwdh iyi   \t     \t  `, ` `)
  run(`\tawdhk\tauwdh iyi `, `\t`)
  run(`\tawdhk\tauwdh iyi\t`, `\t`)
  run(`\tawdhk\tauwdh iyi   \t     \t  `, `\t`)
  run(`  \t \t  \t  awdhk\tauwdh iyi `, `  \t \t  \t  `)
  run(`  \t \t  \t  awdhk\tauwdh iyi\t`, `  \t \t  \t  `)
  run(`  \t \t  \t  awdhk\tauwdh iyi   \t     \t  `, `  \t \t  \t  `)
})

describe(`indenterExtractText`, () => {
  const run = (input, output) => describe(`given "${input}"`, () => it(`returns ${output}`, () => get(`indenterExtractText`)(input)))
  run(``, ``)
  run(` `, ` `)
  run(`\t`, `\t`)
  run(`   \t     \t  `, `   \t     \t  `)
  run(`a`, `a`)
  run(` a`, `a`)
  run(`\ta`, `a`)
  run(`   \t     \t  a`, `a`)
  run(`awdhk\tauwdh iyi`, `awdhk\tauwdh iyi`)
  run(` awdhk\tauwdh iyi`, `awdhk\tauwdh iyi`)
  run(`\tawdhk\tauwdh iyi`, `awdhk\tauwdh iyi`)
  run(`   \t     \t  awdhk auwdh iyi`, `awdhk\tauwdh iyi`)
  run(`awdhk\tauwdh iyi `, `awdhk\tauwdh iyi`)
  run(`awdhk\tauwdh iyi\t`, `awdhk\tauwdh iyi`)
  run(`awdhk\tauwdh iyi   \t     \t  `, `awdhk\tauwdh iyi`)
  run(` awdhk\tauwdh iyi `, `awdhk\tauwdh iyi`)
  run(` awdhk\tauwdh iyi\t`, `awdhk\tauwdh iyi`)
  run(` awdhk\tauwdh iyi   \t     \t  `, `awdhk\tauwdh iyi`)
  run(`\tawdhk\tauwdh iyi `, `awdhk\tauwdh iyi`)
  run(`\tawdhk\tauwdh iyi\t`, `awdhk\tauwdh iyi`)
  run(`\tawdhk\tauwdh iyi   \t     \t  `, `awdhk\tauwdh iyi`)
  run(`  \t \t  \t  awdhk\tauwdh iyi `, `awdhk\tauwdh iyi`)
  run(`  \t \t  \t  awdhk\tauwdh iyi\t`, `awdhk\tauwdh iyi`)
  run(`  \t \t  \t  awdhk\tauwdh iyi   \t     \t  `, `awdhk\tauwdh iyi`)
})

describe(`indenterCheckWhiteSpace`, () => {
  const run = (input, output) => describe(`given "${input}"`, () => it(`returns ${output}`, () => get(`indenterCheckWhiteSpace`)(input)))
  run(``, `none`)
  run(`a`, `a`)
  run(`aa`, `aa`)
  run(`aaa`, `aaa`)
  run(`aaaa`, `aaaa`)
  run(`ab`, `inconsistent`)
  run(`baa`, `inconsistent`)
  run(`aba`, `inconsistent`)
  run(`aab`, `inconsistent`)
  run(`abc`, `inconsistent`)
})

describe(`indenterLine`, () => {
  const indenterExtractIndentation = setSpy(`indenterExtractIndentation`)
  indenterExtractIndentation.and.returnValue(`Test Extracted Indentation`)
  const indenterExtractText = setSpy(`indenterExtractText`)
  indenterExtractText.and.returnValue(`Test Extracted Text`)
  const indenterCheckWhiteSpace = setSpy(`indenterCheckWhiteSpace`)
  let numberOfOnIndentCallsAtTimeOfCallingOnLine
  let numberOfOnOutdentCallsAtTimeOfCallingOnLine
  const onLine = jasmine.createSpy(`onLine`)
  onLine.and.callFake(() => {
    numberOfOnIndentCallsAtTimeOfCallingOnLine = onIndent.calls.count()
    numberOfOnOutdentCallsAtTimeOfCallingOnLine = onOutdent.calls.count()
  })
  const onIndent = jasmine.createSpy(`onIndent`)
  const onOutdent = jasmine.createSpy(`onOutdent`)
  const onError = jasmine.createSpy(`onError`)
  afterEach(() => {
    indenterExtractIndentation.calls.reset()
    indenterExtractText.calls.reset()
    indenterCheckWhiteSpace.calls.reset()
    onLine.calls.reset()
    onIndent.calls.reset()
    onOutdent.calls.reset()
    onError.calls.reset()
  })
  let indenter
  beforeEach(() => indenter = {
    stack: [0],
    context: `Test Context`,
    onLine,
    onIndent,
    onOutdent,
    onError
  })
  
  describe(`when no indentation character has been found`, () => {
    beforeEach(() => indenter.indentationCharacter = null)
    
    describe(`when the given line does not have indentation`, () => {
      beforeEach(() => {
        indenterCheckWhiteSpace.and.returnValue(`none`)
        get(`indenterLine`)(indenter, 3897, `Test Line Text`)
      })
      it(`does not change stack`, () => expect(indenter.stack).toEqual([0]))
      it(`does not change indentationCharacter`, () => expect(indenter.indentationCharacter).toBeNull())
      it(`does not change context`, () => expect(indenter.context).toEqual(`Test Context`))
      it(`does not change onLine`, () => expect(indenter.onLine).toBe(onLine))
      it(`does not change onIndent`, () => expect(indenter.onIndent).toBe(onIndent))
      it(`does not change onOutdent`, () => expect(indenter.onOutdent).toBe(onOutdent))
      it(`does not change onError`, () => expect(indenter.onError).toBe(onError))
      it(`extracts indentation once`, () => expect(indenterExtractIndentation).toHaveBeenCalledTimes(1))
      it(`extracts indentation from the line text`, () => expect(indenterExtractIndentation).toHaveBeenCalledWith(`Test Line Text`))
      it(`extracts text once`, () => expect(indenterExtractText).toHaveBeenCalledTimes(1))
      it(`extracts text from the line text`, () => expect(indenterExtractText).toHaveBeenCalledWith(`Test Line Text`))
      it(`checks white space once`, () => expect(indenterCheckWhiteSpace).toHaveBeenCalledTimes(1))
      it(`checks white space in the extracted indentation`, () => expect(indenterCheckWhiteSpace).toHaveBeenCalledWith(`Test Extracted Indentation`))
      it(`calls onLine once`, () => expect(onLine).toHaveBeenCalledTimes(1))
      it(`calls onLine with the context`, () => expect(onLine).toHaveBeenCalledWith(`Test Context`, jasmine.anything(), jasmine.anything()))
      it(`calls onLine with the line number`, () => expect(onLine).toHaveBeenCalledWith(jasmine.anything(), 3897, jasmine.anything()))
      it(`calls onLine with the extracted text`, () => expect(onLine).toHaveBeenCalledWith(jasmine.anything(), jasmine.anything(), `Test Extracted Text`))
      it(`does not call onIndent`, () => expect(onIndent).not.toHaveBeenCalled())
      it(`does not call onOutdent`, () => expect(onOutdent).not.toHaveBeenCalled())
      it(`does not call onError`, () => expect(onError).not.toHaveBeenCalled())
    })
    
    describe(`when the given line has inconsistent indentation`, () => {
      beforeEach(() => {
        indenterCheckWhiteSpace.and.returnValue(`inconsistent`)
        get(`indenterLine`)(indenter, 3897, `Test Line Text`)
      })
      it(`does not change stack`, () => expect(indenter.stack).toEqual([0]))
      it(`does not change indentationCharacter`, () => expect(indenter.indentationCharacter).toBeNull())
      it(`does not change context`, () => expect(indenter.context).toEqual(`Test Context`))
      it(`does not change onLine`, () => expect(indenter.onLine).toBe(onLine))
      it(`does not change onIndent`, () => expect(indenter.onIndent).toBe(onIndent))
      it(`does not change onOutdent`, () => expect(indenter.onOutdent).toBe(onOutdent))
      it(`does not change onError`, () => expect(indenter.onError).toBe(onError))
      it(`extracts indentation once`, () => expect(indenterExtractIndentation).toHaveBeenCalledTimes(1))
      it(`extracts indentation from the line text`, () => expect(indenterExtractIndentation).toHaveBeenCalledWith(`Test Line Text`))
      it(`does not extract text`, () => expect(indenterExtractText).not.toHaveBeenCalled())
      it(`checks white space once`, () => expect(indenterCheckWhiteSpace).toHaveBeenCalledTimes(1))
      it(`checks white space in the extracted indentation`, () => expect(indenterCheckWhiteSpace).toHaveBeenCalledWith(`Test Extracted Indentation`))
      it(`does not call onLine`, () => expect(onLine).not.toHaveBeenCalled())
      it(`does not call onIndent`, () => expect(onIndent).not.toHaveBeenCalled())
      it(`does not call onOutdent`, () => expect(onOutdent).not.toHaveBeenCalled())
      it(`calls onError once`, () => expect(onError).toHaveBeenCalledTimes(1))
      it(`calls onError with the context`, () => expect(onError).toHaveBeenCalledWith(`Test Context`, jasmine.anything(), jasmine.anything()))
      it(`calls onError with the line number`, () => expect(onError).toHaveBeenCalledWith(jasmine.anything(), 3897, jasmine.anything()))
      it(`calls onError with a message informing the user that they cannot mix indentation white space`, () => expect(onError).toHaveBeenCalledWith(jasmine.anything(), jasmine.anything(), `Inconsistent indenting white space characters; it is likely that both spaces and tabs are being used to indent within the same file`))
    })
    
    describe(`when the given line has indentation`, () => {
      beforeEach(() => {
        indenterCheckWhiteSpace.and.returnValue(`Test Indentation Character`)
        get(`indenterLine`)(indenter, 3897, `Test Line Text`)
      })
      it(`appends the length of the indentation to the stack`, () => expect(indenter.stack).toEqual([0, 26]))
      it(`sets indentationCharacter to the indentation character`, () => expect(indenter.indentationCharacter).toEqual(`Test Indentation Character`))
      it(`does not change context`, () => expect(indenter.context).toEqual(`Test Context`))
      it(`does not change onLine`, () => expect(indenter.onLine).toBe(onLine))
      it(`does not change onIndent`, () => expect(indenter.onIndent).toBe(onIndent))
      it(`does not change onOutdent`, () => expect(indenter.onOutdent).toBe(onOutdent))
      it(`does not change onError`, () => expect(indenter.onError).toBe(onError))
      it(`extracts indentation once`, () => expect(indenterExtractIndentation).toHaveBeenCalledTimes(1))
      it(`extracts indentation from the line text`, () => expect(indenterExtractIndentation).toHaveBeenCalledWith(`Test Line Text`))
      it(`extracts text once`, () => expect(indenterExtractText).toHaveBeenCalledTimes(1))
      it(`extracts text from the line text`, () => expect(indenterExtractText).toHaveBeenCalledWith(`Test Line Text`))
      it(`checks white space once`, () => expect(indenterCheckWhiteSpace).toHaveBeenCalledTimes(1))
      it(`checks white space in the extracted indentation`, () => expect(indenterCheckWhiteSpace).toHaveBeenCalledWith(`Test Extracted Indentation`))
      it(`calls onLine once`, () => expect(onLine).toHaveBeenCalledTimes(1))
      it(`calls onLine with the context`, () => expect(onLine).toHaveBeenCalledWith(`Test Context`, jasmine.anything(), jasmine.anything()))
      it(`calls onLine with the line number`, () => expect(onLine).toHaveBeenCalledWith(jasmine.anything(), 3897, jasmine.anything()))
      it(`calls onLine with the extracted text`, () => expect(onLine).toHaveBeenCalledWith(jasmine.anything(), jasmine.anything(), `Test Extracted Text`))
      it(`calls onIndent once`, () => expect(onIndent).toHaveBeenCalledTimes(1))
      it(`calls onIndent with the context`, () => expect(onIndent).toHaveBeenCalledWith(`Test Context`, jasmine.anything()))
      it(`calls onIndent with the line number`, () => expect(onIndent).toHaveBeenCalledWith(jasmine.anything(), 3897))
      it(`calls onIndent before onLine`, () => expect(numberOfOnIndentCallsAtTimeOfCallingOnLine).toEqual(1))
      it(`does not call onOutdent`, () => expect(onOutdent).not.toHaveBeenCalled())
      it(`does not call onError`, () => expect(onError).not.toHaveBeenCalled())
    })
  })
  
  describe(`when an indentation character has been found`, () => {
    beforeEach(() => indenter.indentationCharacter = `Test Indentation Character`)
    
    describe(`when the given line does not have indentation`, () => {
      beforeEach(() => {
        indenter.stack = [0, 14, 27, 36, 42]
        indenterCheckWhiteSpace.and.returnValue(`none`)
        get(`indenterLine`)(indenter, 3897, `Test Line Text`)
      })
      it(`clears the stack`, () => expect(indenter.stack).toEqual([0]))
      it(`does not change the indentation character`, () => expect(indenter.indentationCharacter).toEqual(`Test Indentation Character`))
      it(`does not change context`, () => expect(indenter.context).toEqual(`Test Context`))
      it(`does not change onLine`, () => expect(indenter.onLine).toBe(onLine))
      it(`does not change onIndent`, () => expect(indenter.onIndent).toBe(onIndent))
      it(`does not change onOutdent`, () => expect(indenter.onOutdent).toBe(onOutdent))
      it(`does not change onError`, () => expect(indenter.onError).toBe(onError))
      it(`extracts indentation once`, () => expect(indenterExtractIndentation).toHaveBeenCalledTimes(1))
      it(`extracts indentation from the line text`, () => expect(indenterExtractIndentation).toHaveBeenCalledWith(`Test Line Text`))
      it(`extracts text once`, () => expect(indenterExtractText).toHaveBeenCalledTimes(1))
      it(`extracts text from the line text`, () => expect(indenterExtractText).toHaveBeenCalledWith(`Test Line Text`))
      it(`checks white space once`, () => expect(indenterCheckWhiteSpace).toHaveBeenCalledTimes(1))
      it(`checks white space in the extracted indentation`, () => expect(indenterCheckWhiteSpace).toHaveBeenCalledWith(`Test Extracted Indentation`))
      it(`calls onLine once`, () => expect(onLine).toHaveBeenCalledTimes(1))
      it(`calls onLine with the context`, () => expect(onLine).toHaveBeenCalledWith(`Test Context`, jasmine.anything(), jasmine.anything()))
      it(`calls onLine with the line number`, () => expect(onLine).toHaveBeenCalledWith(jasmine.anything(), 3897, jasmine.anything()))
      it(`calls onLine with the extracted text`, () => expect(onLine).toHaveBeenCalledWith(jasmine.anything(), jasmine.anything(), `Test Extracted Text`))
      it(`does not call onIndent`, () => expect(onIndent).not.toHaveBeenCalled())
      it(`calls onOutdent once per eliminated stack level`, () => expect(onOutdent).toHaveBeenCalledTimes(4))
      it(`calls onOutdent with the context`, () => {
        expect(onOutdent.calls.argsFor(0)).toEqual([`Test Context`, jasmine.anything()])
        expect(onOutdent.calls.argsFor(1)).toEqual([`Test Context`, jasmine.anything()])
        expect(onOutdent.calls.argsFor(2)).toEqual([`Test Context`, jasmine.anything()])
        expect(onOutdent.calls.argsFor(3)).toEqual([`Test Context`, jasmine.anything()])
      })
      it(`calls onOutdent with the line number`, () => {
        expect(onOutdent.calls.argsFor(0)).toEqual([jasmine.anything(), 3897])
        expect(onOutdent.calls.argsFor(1)).toEqual([jasmine.anything(), 3897])
        expect(onOutdent.calls.argsFor(2)).toEqual([jasmine.anything(), 3897])
        expect(onOutdent.calls.argsFor(3)).toEqual([jasmine.anything(), 3897])
      })
      it(`calls onOutdent before onLine`, () => expect(numberOfOnOutdentCallsAtTimeOfCallingOnLine).toEqual(4))
      it(`does not call onError`, () => expect(onError).not.toHaveBeenCalled())
    })
    
    describe(`when the given line has inconsistent indentation`, () => {
      beforeEach(() => {
        indenter.stack = [0, 14, 27, 36, 42]
        indenterCheckWhiteSpace.and.returnValue(`inconsistent`)
        get(`indenterLine`)(indenter, 3897, `Test Line Text`)
      })
      it(`does not change stack`, () => expect(indenter.stack).toEqual([0, 14, 27, 36, 42]))
      it(`does not change indentationCharacter`, () => expect(indenter.indentationCharacter).toEqual(`Test Indentation Character`))
      it(`does not change context`, () => expect(indenter.context).toEqual(`Test Context`))
      it(`does not change onLine`, () => expect(indenter.onLine).toBe(onLine))
      it(`does not change onIndent`, () => expect(indenter.onIndent).toBe(onIndent))
      it(`does not change onOutdent`, () => expect(indenter.onOutdent).toBe(onOutdent))
      it(`does not change onError`, () => expect(indenter.onError).toBe(onError))
      it(`extracts indentation once`, () => expect(indenterExtractIndentation).toHaveBeenCalledTimes(1))
      it(`extracts indentation from the line text`, () => expect(indenterExtractIndentation).toHaveBeenCalledWith(`Test Line Text`))
      it(`does not extract text`, () => expect(indenterExtractText).not.toHaveBeenCalled())
      it(`checks white space once`, () => expect(indenterCheckWhiteSpace).toHaveBeenCalledTimes(1))
      it(`checks white space in the extracted indentation`, () => expect(indenterCheckWhiteSpace).toHaveBeenCalledWith(`Test Extracted Indentation`))
      it(`does not call onLine`, () => expect(onLine).not.toHaveBeenCalled())
      it(`does not call onIndent`, () => expect(onIndent).not.toHaveBeenCalled())
      it(`does not call onOutdent`, () => expect(onOutdent).not.toHaveBeenCalled())
      it(`calls onError once`, () => expect(onError).toHaveBeenCalledTimes(1))
      it(`calls onError with the context`, () => expect(onError).toHaveBeenCalledWith(`Test Context`, jasmine.anything(), jasmine.anything()))
      it(`calls onError with the line number`, () => expect(onError).toHaveBeenCalledWith(jasmine.anything(), 3897, jasmine.anything()))
      it(`calls onError with a message informing the user that they cannot mix indentation white space`, () => expect(onError).toHaveBeenCalledWith(jasmine.anything(), jasmine.anything(), `Inconsistent indenting white space characters; it is likely that both spaces and tabs are being used to indent within the same file`))
    })
    
    describe(`when the given line has indentation inconsistent with the rest of the file`, () => {
      beforeEach(() => indenterCheckWhiteSpace.and.returnValue(`Test Other Indentation Character`))
      describe(`when the indentation is greater than the top of the stack`, () => {
        beforeEach(() => {
          indenter.stack = [0, 4, 6, 10, 24]
          get(`indenterLine`)(indenter, 3897, `Test Line Text`)
        })
        it(`does not change stack`, () => expect(indenter.stack).toEqual([0, 4, 6, 10, 24]))
        it(`does not change indentationCharacter`, () => expect(indenter.indentationCharacter).toEqual(`Test Indentation Character`))
        it(`does not change context`, () => expect(indenter.context).toEqual(`Test Context`))
        it(`does not change onLine`, () => expect(indenter.onLine).toBe(onLine))
        it(`does not change onIndent`, () => expect(indenter.onIndent).toBe(onIndent))
        it(`does not change onOutdent`, () => expect(indenter.onOutdent).toBe(onOutdent))
        it(`does not change onError`, () => expect(indenter.onError).toBe(onError))
        it(`extracts indentation once`, () => expect(indenterExtractIndentation).toHaveBeenCalledTimes(1))
        it(`extracts indentation from the line text`, () => expect(indenterExtractIndentation).toHaveBeenCalledWith(`Test Line Text`))
        it(`does not extract text`, () => expect(indenterExtractText).not.toHaveBeenCalled())
        it(`checks white space once`, () => expect(indenterCheckWhiteSpace).toHaveBeenCalledTimes(1))
        it(`checks white space in the extracted indentation`, () => expect(indenterCheckWhiteSpace).toHaveBeenCalledWith(`Test Extracted Indentation`))
        it(`does not call onLine`, () => expect(onLine).not.toHaveBeenCalled())
        it(`does not call onIndent`, () => expect(onIndent).not.toHaveBeenCalled())
        it(`does not call onOutdent`, () => expect(onOutdent).not.toHaveBeenCalled())
        it(`calls onError once`, () => expect(onError).toHaveBeenCalledTimes(1))
        it(`calls onError with the context`, () => expect(onError).toHaveBeenCalledWith(`Test Context`, jasmine.anything(), jasmine.anything()))
        it(`calls onError with the line number`, () => expect(onError).toHaveBeenCalledWith(jasmine.anything(), 3897, jasmine.anything()))
        it(`calls onError with a message informing the user that they cannot mix indentation white space`, () => expect(onError).toHaveBeenCalledWith(jasmine.anything(), jasmine.anything(), `Inconsistent indenting white space characters; it is likely that both spaces and tabs are being used to indent within the same file`))
      })
      
      describe(`when the indentation matches the top of the stack`, () => {
        beforeEach(() => {
          indenter.stack = [0, 4, 6, 10, 26]
          get(`indenterLine`)(indenter, 3897, `Test Line Text`)
        })
        it(`does not change stack`, () => expect(indenter.stack).toEqual([0, 4, 6, 10, 26]))
        it(`does not change indentationCharacter`, () => expect(indenter.indentationCharacter).toEqual(`Test Indentation Character`))
        it(`does not change context`, () => expect(indenter.context).toEqual(`Test Context`))
        it(`does not change onLine`, () => expect(indenter.onLine).toBe(onLine))
        it(`does not change onIndent`, () => expect(indenter.onIndent).toBe(onIndent))
        it(`does not change onOutdent`, () => expect(indenter.onOutdent).toBe(onOutdent))
        it(`does not change onError`, () => expect(indenter.onError).toBe(onError))
        it(`extracts indentation once`, () => expect(indenterExtractIndentation).toHaveBeenCalledTimes(1))
        it(`extracts indentation from the line text`, () => expect(indenterExtractIndentation).toHaveBeenCalledWith(`Test Line Text`))
        it(`does not extract text`, () => expect(indenterExtractText).not.toHaveBeenCalled())
        it(`checks white space once`, () => expect(indenterCheckWhiteSpace).toHaveBeenCalledTimes(1))
        it(`checks white space in the extracted indentation`, () => expect(indenterCheckWhiteSpace).toHaveBeenCalledWith(`Test Extracted Indentation`))
        it(`does not call onLine`, () => expect(onLine).not.toHaveBeenCalled())
        it(`does not call onIndent`, () => expect(onIndent).not.toHaveBeenCalled())
        it(`does not call onOutdent`, () => expect(onOutdent).not.toHaveBeenCalled())
        it(`calls onError once`, () => expect(onError).toHaveBeenCalledTimes(1))
        it(`calls onError with the context`, () => expect(onError).toHaveBeenCalledWith(`Test Context`, jasmine.anything(), jasmine.anything()))
        it(`calls onError with the line number`, () => expect(onError).toHaveBeenCalledWith(jasmine.anything(), 3897, jasmine.anything()))
        it(`calls onError with a message informing the user that they cannot mix indentation white space`, () => expect(onError).toHaveBeenCalledWith(jasmine.anything(), jasmine.anything(), `Inconsistent indenting white space characters; it is likely that both spaces and tabs are being used to indent within the same file`))
      })
      
      describe(`when the indentation is between the top and first under on the stack`, () => {
        beforeEach(() => {
          indenter.stack = [0, 4, 6, 10, 28]
          get(`indenterLine`)(indenter, 3897, `Test Line Text`)
        })
        it(`does not change stack`, () => expect(indenter.stack).toEqual([0, 4, 6, 10, 28]))
        it(`does not change indentationCharacter`, () => expect(indenter.indentationCharacter).toEqual(`Test Indentation Character`))
        it(`does not change context`, () => expect(indenter.context).toEqual(`Test Context`))
        it(`does not change onLine`, () => expect(indenter.onLine).toBe(onLine))
        it(`does not change onIndent`, () => expect(indenter.onIndent).toBe(onIndent))
        it(`does not change onOutdent`, () => expect(indenter.onOutdent).toBe(onOutdent))
        it(`does not change onError`, () => expect(indenter.onError).toBe(onError))
        it(`extracts indentation once`, () => expect(indenterExtractIndentation).toHaveBeenCalledTimes(1))
        it(`extracts indentation from the line text`, () => expect(indenterExtractIndentation).toHaveBeenCalledWith(`Test Line Text`))
        it(`does not extract text`, () => expect(indenterExtractText).not.toHaveBeenCalled())
        it(`checks white space once`, () => expect(indenterCheckWhiteSpace).toHaveBeenCalledTimes(1))
        it(`checks white space in the extracted indentation`, () => expect(indenterCheckWhiteSpace).toHaveBeenCalledWith(`Test Extracted Indentation`))
        it(`does not call onLine`, () => expect(onLine).not.toHaveBeenCalled())
        it(`does not call onIndent`, () => expect(onIndent).not.toHaveBeenCalled())
        it(`does not call onOutdent`, () => expect(onOutdent).not.toHaveBeenCalled())
        it(`calls onError once`, () => expect(onError).toHaveBeenCalledTimes(1))
        it(`calls onError with the context`, () => expect(onError).toHaveBeenCalledWith(`Test Context`, jasmine.anything(), jasmine.anything()))
        it(`calls onError with the line number`, () => expect(onError).toHaveBeenCalledWith(jasmine.anything(), 3897, jasmine.anything()))
        it(`calls onError with a message informing the user that they cannot mix indentation white space`, () => expect(onError).toHaveBeenCalledWith(jasmine.anything(), jasmine.anything(), `Inconsistent indenting white space characters; it is likely that both spaces and tabs are being used to indent within the same file`))
      })
      
      describe(`when the indentation is the first under on the stack`, () => {
        beforeEach(() => {
          indenter.stack = [0, 4, 6, 26, 31]
          get(`indenterLine`)(indenter, 3897, `Test Line Text`)
        })
        it(`does not change stack`, () => expect(indenter.stack).toEqual([0, 4, 6, 26, 31]))
        it(`does not change indentationCharacter`, () => expect(indenter.indentationCharacter).toEqual(`Test Indentation Character`))
        it(`does not change context`, () => expect(indenter.context).toEqual(`Test Context`))
        it(`does not change onLine`, () => expect(indenter.onLine).toBe(onLine))
        it(`does not change onIndent`, () => expect(indenter.onIndent).toBe(onIndent))
        it(`does not change onOutdent`, () => expect(indenter.onOutdent).toBe(onOutdent))
        it(`does not change onError`, () => expect(indenter.onError).toBe(onError))
        it(`extracts indentation once`, () => expect(indenterExtractIndentation).toHaveBeenCalledTimes(1))
        it(`extracts indentation from the line text`, () => expect(indenterExtractIndentation).toHaveBeenCalledWith(`Test Line Text`))
        it(`does not extract text`, () => expect(indenterExtractText).not.toHaveBeenCalled())
        it(`checks white space once`, () => expect(indenterCheckWhiteSpace).toHaveBeenCalledTimes(1))
        it(`checks white space in the extracted indentation`, () => expect(indenterCheckWhiteSpace).toHaveBeenCalledWith(`Test Extracted Indentation`))
        it(`does not call onLine`, () => expect(onLine).not.toHaveBeenCalled())
        it(`does not call onIndent`, () => expect(onIndent).not.toHaveBeenCalled())
        it(`does not call onOutdent`, () => expect(onOutdent).not.toHaveBeenCalled())
        it(`calls onError once`, () => expect(onError).toHaveBeenCalledTimes(1))
        it(`calls onError with the context`, () => expect(onError).toHaveBeenCalledWith(`Test Context`, jasmine.anything(), jasmine.anything()))
        it(`calls onError with the line number`, () => expect(onError).toHaveBeenCalledWith(jasmine.anything(), 3897, jasmine.anything()))
        it(`calls onError with a message informing the user that they cannot mix indentation white space`, () => expect(onError).toHaveBeenCalledWith(jasmine.anything(), jasmine.anything(), `Inconsistent indenting white space characters; it is likely that both spaces and tabs are being used to indent within the same file`))
      })
      
      describe(`when the indentation is between the first and second under on the stack`, () => {
        beforeEach(() => {
          indenter.stack = [0, 4, 6, 29, 31]
          get(`indenterLine`)(indenter, 3897, `Test Line Text`)
        })
        it(`does not change stack`, () => expect(indenter.stack).toEqual([0, 4, 6, 29, 31]))
        it(`does not change indentationCharacter`, () => expect(indenter.indentationCharacter).toEqual(`Test Indentation Character`))
        it(`does not change context`, () => expect(indenter.context).toEqual(`Test Context`))
        it(`does not change onLine`, () => expect(indenter.onLine).toBe(onLine))
        it(`does not change onIndent`, () => expect(indenter.onIndent).toBe(onIndent))
        it(`does not change onOutdent`, () => expect(indenter.onOutdent).toBe(onOutdent))
        it(`does not change onError`, () => expect(indenter.onError).toBe(onError))
        it(`extracts indentation once`, () => expect(indenterExtractIndentation).toHaveBeenCalledTimes(1))
        it(`extracts indentation from the line text`, () => expect(indenterExtractIndentation).toHaveBeenCalledWith(`Test Line Text`))
        it(`does not extract text`, () => expect(indenterExtractText).not.toHaveBeenCalled())
        it(`checks white space once`, () => expect(indenterCheckWhiteSpace).toHaveBeenCalledTimes(1))
        it(`checks white space in the extracted indentation`, () => expect(indenterCheckWhiteSpace).toHaveBeenCalledWith(`Test Extracted Indentation`))
        it(`does not call onLine`, () => expect(onLine).not.toHaveBeenCalled())
        it(`does not call onIndent`, () => expect(onIndent).not.toHaveBeenCalled())
        it(`does not call onOutdent`, () => expect(onOutdent).not.toHaveBeenCalled())
        it(`calls onError once`, () => expect(onError).toHaveBeenCalledTimes(1))
        it(`calls onError with the context`, () => expect(onError).toHaveBeenCalledWith(`Test Context`, jasmine.anything(), jasmine.anything()))
        it(`calls onError with the line number`, () => expect(onError).toHaveBeenCalledWith(jasmine.anything(), 3897, jasmine.anything()))
        it(`calls onError with a message informing the user that they cannot mix indentation white space`, () => expect(onError).toHaveBeenCalledWith(jasmine.anything(), jasmine.anything(), `Inconsistent indenting white space characters; it is likely that both spaces and tabs are being used to indent within the same file`))
      })
      
      describe(`when the indentation is the second under on the stack`, () => {
        beforeEach(() => {
          indenter.stack = [0, 4, 26, 29, 31]
          get(`indenterLine`)(indenter, 3897, `Test Line Text`)
        })
        it(`does not change stack`, () => expect(indenter.stack).toEqual([0, 4, 26, 29, 31]))
        it(`does not change indentationCharacter`, () => expect(indenter.indentationCharacter).toEqual(`Test Indentation Character`))
        it(`does not change context`, () => expect(indenter.context).toEqual(`Test Context`))
        it(`does not change onLine`, () => expect(indenter.onLine).toBe(onLine))
        it(`does not change onIndent`, () => expect(indenter.onIndent).toBe(onIndent))
        it(`does not change onOutdent`, () => expect(indenter.onOutdent).toBe(onOutdent))
        it(`does not change onError`, () => expect(indenter.onError).toBe(onError))
        it(`extracts indentation once`, () => expect(indenterExtractIndentation).toHaveBeenCalledTimes(1))
        it(`extracts indentation from the line text`, () => expect(indenterExtractIndentation).toHaveBeenCalledWith(`Test Line Text`))
        it(`does not extract text`, () => expect(indenterExtractText).not.toHaveBeenCalled())
        it(`checks white space once`, () => expect(indenterCheckWhiteSpace).toHaveBeenCalledTimes(1))
        it(`checks white space in the extracted indentation`, () => expect(indenterCheckWhiteSpace).toHaveBeenCalledWith(`Test Extracted Indentation`))
        it(`does not call onLine`, () => expect(onLine).not.toHaveBeenCalled())
        it(`does not call onIndent`, () => expect(onIndent).not.toHaveBeenCalled())
        it(`does not call onOutdent`, () => expect(onOutdent).not.toHaveBeenCalled())
        it(`calls onError once`, () => expect(onError).toHaveBeenCalledTimes(1))
        it(`calls onError with the context`, () => expect(onError).toHaveBeenCalledWith(`Test Context`, jasmine.anything(), jasmine.anything()))
        it(`calls onError with the line number`, () => expect(onError).toHaveBeenCalledWith(jasmine.anything(), 3897, jasmine.anything()))
        it(`calls onError with a message informing the user that they cannot mix indentation white space`, () => expect(onError).toHaveBeenCalledWith(jasmine.anything(), jasmine.anything(), `Inconsistent indenting white space characters; it is likely that both spaces and tabs are being used to indent within the same file`))
      })
    })
    
    describe(`when the given line has indentation`, () => {
      beforeEach(() => {
        indenterCheckWhiteSpace.and.returnValue(`Test Indentation Character`)
      })
      
      describe(`when the indentation is greater than the top of the stack`, () => {
        beforeEach(() => {
          indenter.stack = [0, 4, 6, 10, 24]
          get(`indenterLine`)(indenter, 3897, `Test Line Text`)
        })
        it(`appends the length of the indentation to the stack`, () => expect(indenter.stack).toEqual([0, 4, 6, 10, 24, 26]))
        it(`sets indentationCharacter to the indentation character`, () => expect(indenter.indentationCharacter).toEqual(`Test Indentation Character`))
        it(`does not change context`, () => expect(indenter.context).toEqual(`Test Context`))
        it(`does not change onLine`, () => expect(indenter.onLine).toBe(onLine))
        it(`does not change onIndent`, () => expect(indenter.onIndent).toBe(onIndent))
        it(`does not change onOutdent`, () => expect(indenter.onOutdent).toBe(onOutdent))
        it(`does not change onError`, () => expect(indenter.onError).toBe(onError))
        it(`extracts indentation once`, () => expect(indenterExtractIndentation).toHaveBeenCalledTimes(1))
        it(`extracts indentation from the line text`, () => expect(indenterExtractIndentation).toHaveBeenCalledWith(`Test Line Text`))
        it(`extracts text once`, () => expect(indenterExtractText).toHaveBeenCalledTimes(1))
        it(`extracts text from the line text`, () => expect(indenterExtractText).toHaveBeenCalledWith(`Test Line Text`))
        it(`checks white space once`, () => expect(indenterCheckWhiteSpace).toHaveBeenCalledTimes(1))
        it(`checks white space in the extracted indentation`, () => expect(indenterCheckWhiteSpace).toHaveBeenCalledWith(`Test Extracted Indentation`))
        it(`calls onLine once`, () => expect(onLine).toHaveBeenCalledTimes(1))
        it(`calls onLine with the context`, () => expect(onLine).toHaveBeenCalledWith(`Test Context`, jasmine.anything(), jasmine.anything()))
        it(`calls onLine with the line number`, () => expect(onLine).toHaveBeenCalledWith(jasmine.anything(), 3897, jasmine.anything()))
        it(`calls onLine with the extracted text`, () => expect(onLine).toHaveBeenCalledWith(jasmine.anything(), jasmine.anything(), `Test Extracted Text`))
        it(`calls onIndent once`, () => expect(onIndent).toHaveBeenCalledTimes(1))
        it(`calls onIndent with the context`, () => expect(onIndent).toHaveBeenCalledWith(`Test Context`, jasmine.anything()))
        it(`calls onIndent with the line number`, () => expect(onIndent).toHaveBeenCalledWith(jasmine.anything(), 3897))
        it(`calls onIndent before onLine`, () => expect(numberOfOnIndentCallsAtTimeOfCallingOnLine).toEqual(1))
        it(`does not call onOutdent`, () => expect(onOutdent).not.toHaveBeenCalled())
        it(`does not call onError`, () => expect(onError).not.toHaveBeenCalled())
      })
      
      describe(`when the indentation matches the top of the stack`, () => {
        beforeEach(() => {
          indenter.stack = [0, 4, 6, 10, 26]
          get(`indenterLine`)(indenter, 3897, `Test Line Text`)
        })
        it(`does not change the stack`, () => expect(indenter.stack).toEqual([0, 4, 6, 10, 26]))
        it(`sets indentationCharacter to the indentation character`, () => expect(indenter.indentationCharacter).toEqual(`Test Indentation Character`))
        it(`does not change context`, () => expect(indenter.context).toEqual(`Test Context`))
        it(`does not change onLine`, () => expect(indenter.onLine).toBe(onLine))
        it(`does not change onIndent`, () => expect(indenter.onIndent).toBe(onIndent))
        it(`does not change onOutdent`, () => expect(indenter.onOutdent).toBe(onOutdent))
        it(`does not change onError`, () => expect(indenter.onError).toBe(onError))
        it(`extracts indentation once`, () => expect(indenterExtractIndentation).toHaveBeenCalledTimes(1))
        it(`extracts indentation from the line text`, () => expect(indenterExtractIndentation).toHaveBeenCalledWith(`Test Line Text`))
        it(`extracts text once`, () => expect(indenterExtractText).toHaveBeenCalledTimes(1))
        it(`extracts text from the line text`, () => expect(indenterExtractText).toHaveBeenCalledWith(`Test Line Text`))
        it(`checks white space once`, () => expect(indenterCheckWhiteSpace).toHaveBeenCalledTimes(1))
        it(`checks white space in the extracted indentation`, () => expect(indenterCheckWhiteSpace).toHaveBeenCalledWith(`Test Extracted Indentation`))
        it(`calls onLine once`, () => expect(onLine).toHaveBeenCalledTimes(1))
        it(`calls onLine with the context`, () => expect(onLine).toHaveBeenCalledWith(`Test Context`, jasmine.anything(), jasmine.anything()))
        it(`calls onLine with the line number`, () => expect(onLine).toHaveBeenCalledWith(jasmine.anything(), 3897, jasmine.anything()))
        it(`calls onLine with the extracted text`, () => expect(onLine).toHaveBeenCalledWith(jasmine.anything(), jasmine.anything(), `Test Extracted Text`))
        it(`does not call onIndent`, () => expect(onIndent).not.toHaveBeenCalled())
        it(`does not call onOutdent`, () => expect(onOutdent).not.toHaveBeenCalled())
        it(`does not call onError`, () => expect(onError).not.toHaveBeenCalled())
      })
      
      describe(`when the indentation is between the top and first under on the stack`, () => {
        beforeEach(() => {
          indenter.stack = [0, 4, 6, 10, 28]
          get(`indenterLine`)(indenter, 3897, `Test Line Text`)
        })
        it(`does not change stack`, () => expect(indenter.stack).toEqual([0, 4, 6, 10, 28]))
        it(`does not change indentationCharacter`, () => expect(indenter.indentationCharacter).toEqual(`Test Indentation Character`))
        it(`does not change context`, () => expect(indenter.context).toEqual(`Test Context`))
        it(`does not change onLine`, () => expect(indenter.onLine).toBe(onLine))
        it(`does not change onIndent`, () => expect(indenter.onIndent).toBe(onIndent))
        it(`does not change onOutdent`, () => expect(indenter.onOutdent).toBe(onOutdent))
        it(`does not change onError`, () => expect(indenter.onError).toBe(onError))
        it(`extracts indentation once`, () => expect(indenterExtractIndentation).toHaveBeenCalledTimes(1))
        it(`extracts indentation from the line text`, () => expect(indenterExtractIndentation).toHaveBeenCalledWith(`Test Line Text`))
        it(`does not extract text`, () => expect(indenterExtractText).not.toHaveBeenCalled())
        it(`checks white space once`, () => expect(indenterCheckWhiteSpace).toHaveBeenCalledTimes(1))
        it(`checks white space in the extracted indentation`, () => expect(indenterCheckWhiteSpace).toHaveBeenCalledWith(`Test Extracted Indentation`))
        it(`does not call onLine`, () => expect(onLine).not.toHaveBeenCalled())
        it(`does not call onIndent`, () => expect(onIndent).not.toHaveBeenCalled())
        it(`does not call onOutdent`, () => expect(onOutdent).not.toHaveBeenCalled())
        it(`calls onError once`, () => expect(onError).toHaveBeenCalledTimes(1))
        it(`calls onError with the context`, () => expect(onError).toHaveBeenCalledWith(`Test Context`, jasmine.anything(), jasmine.anything()))
        it(`calls onError with the line number`, () => expect(onError).toHaveBeenCalledWith(jasmine.anything(), 3897, jasmine.anything()))
        it(`calls onError with a message informing the user that they cannot outdent to a level they have not previously indented to`, () => expect(onError).toHaveBeenCalledWith(jasmine.anything(), jasmine.anything(), `Outdent to level not previously indented to`))
      })
      
      describe(`when the indentation is the first under on the stack`, () => {
        beforeEach(() => {
          indenter.stack = [0, 4, 6, 26, 31]
          get(`indenterLine`)(indenter, 3897, `Test Line Text`)
        })
        it(`removes the last item on the stack`, () => expect(indenter.stack).toEqual([0, 4, 6, 26]))
        it(`sets indentationCharacter to the indentation character`, () => expect(indenter.indentationCharacter).toEqual(`Test Indentation Character`))
        it(`does not change context`, () => expect(indenter.context).toEqual(`Test Context`))
        it(`does not change onLine`, () => expect(indenter.onLine).toBe(onLine))
        it(`does not change onIndent`, () => expect(indenter.onIndent).toBe(onIndent))
        it(`does not change onOutdent`, () => expect(indenter.onOutdent).toBe(onOutdent))
        it(`does not change onError`, () => expect(indenter.onError).toBe(onError))
        it(`extracts indentation once`, () => expect(indenterExtractIndentation).toHaveBeenCalledTimes(1))
        it(`extracts indentation from the line text`, () => expect(indenterExtractIndentation).toHaveBeenCalledWith(`Test Line Text`))
        it(`extracts text once`, () => expect(indenterExtractText).toHaveBeenCalledTimes(1))
        it(`extracts text from the line text`, () => expect(indenterExtractText).toHaveBeenCalledWith(`Test Line Text`))
        it(`checks white space once`, () => expect(indenterCheckWhiteSpace).toHaveBeenCalledTimes(1))
        it(`checks white space in the extracted indentation`, () => expect(indenterCheckWhiteSpace).toHaveBeenCalledWith(`Test Extracted Indentation`))
        it(`calls onLine once`, () => expect(onLine).toHaveBeenCalledTimes(1))
        it(`calls onLine with the context`, () => expect(onLine).toHaveBeenCalledWith(`Test Context`, jasmine.anything(), jasmine.anything()))
        it(`calls onLine with the line number`, () => expect(onLine).toHaveBeenCalledWith(jasmine.anything(), 3897, jasmine.anything()))
        it(`calls onLine with the extracted text`, () => expect(onLine).toHaveBeenCalledWith(jasmine.anything(), jasmine.anything(), `Test Extracted Text`))
        it(`does not call onIndent`, () => expect(onIndent).not.toHaveBeenCalled())
        it(`calls onOutdent once`, () => expect(onOutdent).toHaveBeenCalledTimes(1))
        it(`calls onOutdent with the context`, () => expect(onOutdent).toHaveBeenCalledWith(`Test Context`, jasmine.anything()))
        it(`calls onOutdent with the line number`, () => expect(onOutdent).toHaveBeenCalledWith(jasmine.anything(), 3897))
        it(`calls onOutdent before onLine`, () => expect(numberOfOnOutdentCallsAtTimeOfCallingOnLine).toEqual(1))
        it(`does not call onError`, () => expect(onError).not.toHaveBeenCalled())
      })
      
      describe(`when the indentation is between the first and second under on the stack`, () => {
        beforeEach(() => {
          indenter.stack = [0, 4, 6, 29, 31]
          get(`indenterLine`)(indenter, 3897, `Test Line Text`)
        })
        it(`does not change stack`, () => expect(indenter.stack).toEqual([0, 4, 6, 29, 31]))
        it(`does not change indentationCharacter`, () => expect(indenter.indentationCharacter).toEqual(`Test Indentation Character`))
        it(`does not change context`, () => expect(indenter.context).toEqual(`Test Context`))
        it(`does not change onLine`, () => expect(indenter.onLine).toBe(onLine))
        it(`does not change onIndent`, () => expect(indenter.onIndent).toBe(onIndent))
        it(`does not change onOutdent`, () => expect(indenter.onOutdent).toBe(onOutdent))
        it(`does not change onError`, () => expect(indenter.onError).toBe(onError))
        it(`extracts indentation once`, () => expect(indenterExtractIndentation).toHaveBeenCalledTimes(1))
        it(`extracts indentation from the line text`, () => expect(indenterExtractIndentation).toHaveBeenCalledWith(`Test Line Text`))
        it(`does not extract text`, () => expect(indenterExtractText).not.toHaveBeenCalled())
        it(`checks white space once`, () => expect(indenterCheckWhiteSpace).toHaveBeenCalledTimes(1))
        it(`checks white space in the extracted indentation`, () => expect(indenterCheckWhiteSpace).toHaveBeenCalledWith(`Test Extracted Indentation`))
        it(`does not call onLine`, () => expect(onLine).not.toHaveBeenCalled())
        it(`does not call onIndent`, () => expect(onIndent).not.toHaveBeenCalled())
        it(`does not call onOutdent`, () => expect(onOutdent).not.toHaveBeenCalled())
        it(`calls onError once`, () => expect(onError).toHaveBeenCalledTimes(1))
        it(`calls onError with the context`, () => expect(onError).toHaveBeenCalledWith(`Test Context`, jasmine.anything(), jasmine.anything()))
        it(`calls onError with the line number`, () => expect(onError).toHaveBeenCalledWith(jasmine.anything(), 3897, jasmine.anything()))
        it(`calls onError with a message informing the user that they cannot outdent to a level they have not previously indented to`, () => expect(onError).toHaveBeenCalledWith(jasmine.anything(), jasmine.anything(), `Outdent to level not previously indented to`))
      })
      
      describe(`when the indentation is the second under on the stack`, () => {
        beforeEach(() => {
          indenter.stack = [0, 4, 26, 29, 31]
          get(`indenterLine`)(indenter, 3897, `Test Line Text`)
        })
        it(`removes the subsequent items on the stack`, () => expect(indenter.stack).toEqual([0, 4, 26]))
        it(`sets indentationCharacter to the indentation character`, () => expect(indenter.indentationCharacter).toEqual(`Test Indentation Character`))
        it(`does not change context`, () => expect(indenter.context).toEqual(`Test Context`))
        it(`does not change onLine`, () => expect(indenter.onLine).toBe(onLine))
        it(`does not change onIndent`, () => expect(indenter.onIndent).toBe(onIndent))
        it(`does not change onOutdent`, () => expect(indenter.onOutdent).toBe(onOutdent))
        it(`does not change onError`, () => expect(indenter.onError).toBe(onError))
        it(`extracts indentation once`, () => expect(indenterExtractIndentation).toHaveBeenCalledTimes(1))
        it(`extracts indentation from the line text`, () => expect(indenterExtractIndentation).toHaveBeenCalledWith(`Test Line Text`))
        it(`extracts text once`, () => expect(indenterExtractText).toHaveBeenCalledTimes(1))
        it(`extracts text from the line text`, () => expect(indenterExtractText).toHaveBeenCalledWith(`Test Line Text`))
        it(`checks white space once`, () => expect(indenterCheckWhiteSpace).toHaveBeenCalledTimes(1))
        it(`checks white space in the extracted indentation`, () => expect(indenterCheckWhiteSpace).toHaveBeenCalledWith(`Test Extracted Indentation`))
        it(`calls onLine once`, () => expect(onLine).toHaveBeenCalledTimes(1))
        it(`calls onLine with the context`, () => expect(onLine).toHaveBeenCalledWith(`Test Context`, jasmine.anything(), jasmine.anything()))
        it(`calls onLine with the line number`, () => expect(onLine).toHaveBeenCalledWith(jasmine.anything(), 3897, jasmine.anything()))
        it(`calls onLine with the extracted text`, () => expect(onLine).toHaveBeenCalledWith(jasmine.anything(), jasmine.anything(), `Test Extracted Text`))
        it(`does not call onIndent`, () => expect(onIndent).not.toHaveBeenCalled())
        it(`calls onOutdent twice`, () => expect(onOutdent).toHaveBeenCalledTimes(2))
        it(`calls onOutdent with the context`, () => expect(onOutdent).toHaveBeenCalledWith(`Test Context`, jasmine.anything()))
        it(`calls onOutdent with the line number`, () => expect(onOutdent).toHaveBeenCalledWith(jasmine.anything(), 3897))
        it(`calls onOutdent before onLine`, () => expect(numberOfOnOutdentCallsAtTimeOfCallingOnLine).toEqual(2))
        it(`does not call onError`, () => expect(onError).not.toHaveBeenCalled())
      })
    })
  })
})