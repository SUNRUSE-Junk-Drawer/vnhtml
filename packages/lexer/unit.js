const rewire = require(`rewire`)
const index = rewire(`./index.babel.js`)

const get = name => index.__get__(name)
const set = (name, value) => {
  let replaced
  beforeEach(() => {
    replaced = index.__get__(name)
    index.__set__(name, value)
  })
  afterEach(() => {
    index.__set__(name, replaced)
  })
  return value
}

const setSpy = name => set(name, jasmine.createSpy(name))

describe(`linerCreate`, () => {
  it(`returns an object`, () => expect(get(`linerCreate`)(`Test Context`, `Test On Line`, `Test On End Of File`)).toEqual(jasmine.any(Object)))
  it(`returns line, 1`, () => expect(get(`linerCreate`)(`Test Context`, `Test On Line`, `Test On End Of File`).line).toEqual(1))
  it(`returns text, empty`, () => expect(get(`linerCreate`)(`Test Context`, `Test On Line`, `Test On End Of File`).text).toEqual(``))
  it(`returns lineComment, null`, () => expect(get(`linerCreate`)(`Test Context`, `Test On Line`, `Test On End Of File`).lineComment).toBeNull())
  it(`returns context, given`, () => expect(get(`linerCreate`)(`Test Context`, `Test On Line`, `Test On End Of File`).context).toEqual(`Test Context`))
  it(`returns onLine, given`, () => expect(get(`linerCreate`)(`Test Context`, `Test On Line`, `Test On End Of File`).onLine).toEqual(`Test On Line`))
  it(`returns onEndOfFile, given`, () => expect(get(`linerCreate`)(`Test Context`, `Test On Line`, `Test On End Of File`).onEndOfFile).toEqual(`Test On End Of File`))
  it(`returns a new object every call`, () => expect(get(`linerCreate`)(`Test Context`, `Test On Line`, `Test On End Of File`)).not.toBe(get(`linerCreate`)(`Test Context`, `Test On Line`, `Test On End Of File`)))
  it(`returns the same value every call`, () => expect(get(`linerCreate`)(`Test Context`, `Test On Line`, `Test On End Of File`)).toEqual(get(`linerCreate`)(`Test Context`, `Test On Line`, `Test On End Of File`)))
})

describe(`linerClassifyCharacter`, () => {
  const run = (input, output) => describe(`given "${input}"`, () => it(`returns "${output}"`, () => expect(get(`linerClassifyCharacter`)(input)).toEqual(output)))
  run(`a`, `partOfLine`)
  run(`d`, `partOfLine`)
  run(`q`, `partOfLine`)
  run(`z`, `partOfLine`)
  run(`0`, `partOfLine`)
  run(`4`, `partOfLine`)
  run(`9`, `partOfLine`)
  run(`0`, `partOfLine`)
  run(`!`, `partOfLine`)
  run(`$`, `partOfLine`)
  run(`?`, `partOfLine`)
  run(`#`, `partOfLine`)
  run(`ã‹`, `partOfLine`)
  run(` `, `partOfLine`)
  run(`\t`, `partOfLine`)
  run(`\r`, `newLine`)
  run(`\n`, `newLine`)
  run(`\``, `lineComment`)
})

describe(`linerTextNotEmpty`, () => {
  const run = (input, output) => describe(`given "${input}"`, () => it(`returns ${output}`, () => expect(get(`linerTextNotEmpty`)(input)).toBe(output)))
  run(``, false)
  run(` `, false)
  run(`\t`, false)
  run(`   \t     \t  `, false)
  run(`a`, true)
  run(` a`, true)
  run(`\ta`, true)
  run(`   \t     \t  a`, true)
  run(`awdhk\tauwdh iyi`, true)
  run(` awdhk\tauwdh iyi`, true)
  run(`\tawdhk\tauwdh iyi`, true)
  run(`   \t     \t  awdhk auwdh iyi`, true)
  run(`awdhk\tauwdh iyi `, true)
  run(`awdhk\tauwdh iyi\t`, true)
  run(`awdhk\tauwdh iyi   \t     \t  `, true)
  run(` awdhk\tauwdh iyi `, true)
  run(` awdhk\tauwdh iyi\t`, true)
  run(` awdhk\tauwdh iyi   \t     \t  `, true)
  run(`\tawdhk\tauwdh iyi `, true)
  run(`\tawdhk\tauwdh iyi\t`, true)
  run(`\tawdhk\tauwdh iyi   \t     \t  `, true)
  run(`  \t \t  \t  awdhk\tauwdh iyi `, true)
  run(`  \t \t  \t  awdhk\tauwdh iyi\t`, true)
  run(`  \t \t  \t  awdhk\tauwdh iyi   \t     \t  `, true)
})

describe(`linerCharacter`, () => {
  const linerClassifyCharacter = setSpy(`linerClassifyCharacter`)
  const linerTextNotEmpty = setSpy(`linerTextNotEmpty`)
  const onLine = jasmine.createSpy(`onLine`)
  const onEndOfFile = jasmine.createSpy(`onEndOfFile`)
  afterEach(() => {
    linerClassifyCharacter.calls.reset()
    linerTextNotEmpty.calls.reset()
    onLine.calls.reset()
    onEndOfFile.calls.reset()
  })
  let liner
  beforeEach(() => liner = {
    line: 2368,
    text: `Test Text`,
    context: `Test Context`,
    onLine,
    onEndOfFile
  })

  describe(`when not inside a line comment`, () => {
    beforeEach(() => liner.lineComment = null)
    describe(`when given a line comment`, () => {
      beforeEach(() => {
        linerClassifyCharacter.and.returnValue(`lineComment`)
        get(`linerCharacter`)(liner, `Test Character`)
      })
      it(`does not change line`, () => expect(liner.line).toEqual(2368))
      it(`does not change text`, () => expect(liner.text).toEqual(`Test Text`))
      it(`starts a line comment`, () => expect(liner.lineComment).toEqual(`Test Character`))
      it(`does not change the context`, () => expect(liner.context).toEqual(`Test Context`))
      it(`does not change onLine`, () => expect(liner.onLine).toBe(onLine))
      it(`does not change onEndOfFile`, () => expect(liner.onEndOfFile).toBe(onEndOfFile))
      it(`calls linerClassifyCharacter once`, () => expect(linerClassifyCharacter).toHaveBeenCalledTimes(1))
      it(`calls linerClassifyCharacter with the given character`, () => expect(linerClassifyCharacter).toHaveBeenCalledWith(`Test Character`))
      it(`does not call linerTextNotEmpty`, () => expect(linerTextNotEmpty).not.toHaveBeenCalled())
      it(`does not call onLine`, () => expect(onLine).not.toHaveBeenCalled())
      it(`does not call onEndOfFile`, () => expect(onEndOfFile).not.toHaveBeenCalled())
    })

    describe(`when given a new line`, () => {
      beforeEach(() => linerClassifyCharacter.and.returnValue(`newLine`))
      describe(`when the accumulated text is empty`, () => {
        beforeEach(() => {
          linerTextNotEmpty.and.returnValue(false)
          get(`linerCharacter`)(liner, `Test Character`)
        })
        it(`increments line`, () => expect(liner.line).toEqual(2369))
        it(`empties text`, () => expect(liner.text).toEqual(``))
        it(`does not start a line comment`, () => expect(liner.lineComment).toBeNull())
        it(`does not change the context`, () => expect(liner.context).toEqual(`Test Context`))
        it(`does not change onLine`, () => expect(liner.onLine).toBe(onLine))
        it(`does not change onEndOfFile`, () => expect(liner.onEndOfFile).toBe(onEndOfFile))
        it(`calls linerClassifyCharacter once`, () => expect(linerClassifyCharacter).toHaveBeenCalledTimes(1))
        it(`calls linerClassifyCharacter with the given character`, () => expect(linerClassifyCharacter).toHaveBeenCalledWith(`Test Character`))
        it(`calls linerTextNotEmpty once`, () => expect(linerTextNotEmpty).toHaveBeenCalledTimes(1))
        it(`calls linerTextNotEmpty with the text`, () => expect(linerTextNotEmpty).toHaveBeenCalledWith(`Test Text`))
        it(`does not call onLine`, () => expect(onLine).not.toHaveBeenCalled())
        it(`does not call onEndOfFile`, () => expect(onEndOfFile).not.toHaveBeenCalled())
      })

      describe(`when the accumulated text is not empty`, () => {
        beforeEach(() => {
          linerTextNotEmpty.and.returnValue(true)
          get(`linerCharacter`)(liner, `Test Character`)
        })
        it(`increments line`, () => expect(liner.line).toEqual(2369))
        it(`empties text`, () => expect(liner.text).toEqual(``))
        it(`does not start a line comment`, () => expect(liner.lineComment).toBeNull())
        it(`does not change the context`, () => expect(liner.context).toEqual(`Test Context`))
        it(`does not change onLine`, () => expect(liner.onLine).toBe(onLine))
        it(`does not change onEndOfFile`, () => expect(liner.onEndOfFile).toBe(onEndOfFile))
        it(`calls linerClassifyCharacter once`, () => expect(linerClassifyCharacter).toHaveBeenCalledTimes(1))
        it(`calls linerClassifyCharacter with the given character`, () => expect(linerClassifyCharacter).toHaveBeenCalledWith(`Test Character`))
        it(`calls linerTextNotEmpty once`, () => expect(linerTextNotEmpty).toHaveBeenCalledTimes(1))
        it(`calls linerTextNotEmpty with the text`, () => expect(linerTextNotEmpty).toHaveBeenCalledWith(`Test Text`))
        it(`calls onLine once`, () => expect(onLine).toHaveBeenCalledTimes(1))
        it(`calls onLine with the context`, () => expect(onLine).toHaveBeenCalledWith(`Test Context`, jasmine.anything(), jasmine.anything()))
        it(`calls onLine with the line number`, () => expect(onLine).toHaveBeenCalledWith(jasmine.anything(), 2368, jasmine.anything()))
        it(`calls onLine with the text`, () => expect(onLine).toHaveBeenCalledWith(jasmine.anything(), jasmine.anything(), `Test Text`))
        it(`does not call onEndOfFile`, () => expect(onEndOfFile).not.toHaveBeenCalled())
      })
    })

    describe(`when given a part of line`, () => {
      beforeEach(() => {
        linerClassifyCharacter.and.returnValue(`partOfLine`)
        get(`linerCharacter`)(liner, `Test Character`)
      })
      it(`does not change line`, () => expect(liner.line).toEqual(2368))
      it(`appends it to the end of text`, () => expect(liner.text).toEqual(`Test TextTest Character`))
      it(`does not start a line comment`, () => expect(liner.lineComment).toBeNull())
      it(`does not change the context`, () => expect(liner.context).toEqual(`Test Context`))
      it(`does not change onLine`, () => expect(liner.onLine).toBe(onLine))
      it(`does not change onEndOfFile`, () => expect(liner.onEndOfFile).toBe(onEndOfFile))
      it(`calls linerClassifyCharacter once`, () => expect(linerClassifyCharacter).toHaveBeenCalledTimes(1))
      it(`calls linerClassifyCharacter with the given character`, () => expect(linerClassifyCharacter).toHaveBeenCalledWith(`Test Character`))
      it(`does not call linerTextNotEmpty`, () => expect(linerTextNotEmpty).not.toHaveBeenCalled())
      it(`does not call onLine`, () => expect(onLine).not.toHaveBeenCalled())
      it(`does not call onEndOfFile`, () => expect(onEndOfFile).not.toHaveBeenCalled())
    })
  })

  describe(`when in a line comment`, () => {
    beforeEach(() => liner.lineComment = `Test Line Comment`)
    describe(`when given a line comment`, () => {
      beforeEach(() => {
        linerClassifyCharacter.and.returnValue(`lineComment`)
        get(`linerCharacter`)(liner, `Test Character`)
      })
      it(`does not change line`, () => expect(liner.line).toEqual(2368))
      it(`does not change text`, () => expect(liner.text).toEqual(`Test Text`))
      it(`appends it to the end of the line comment`, () => expect(liner.lineComment).toEqual(`Test Line CommentTest Character`))
      it(`does not change the context`, () => expect(liner.context).toEqual(`Test Context`))
      it(`does not change onLine`, () => expect(liner.onLine).toBe(onLine))
      it(`does not change onEndOfFile`, () => expect(liner.onEndOfFile).toBe(onEndOfFile))
      it(`calls linerClassifyCharacter once`, () => expect(linerClassifyCharacter).toHaveBeenCalledTimes(1))
      it(`calls linerClassifyCharacter with the given character`, () => expect(linerClassifyCharacter).toHaveBeenCalledWith(`Test Character`))
      it(`does not call linerTextNotEmpty`, () => expect(linerTextNotEmpty).not.toHaveBeenCalled())
      it(`does not call onLine`, () => expect(onLine).not.toHaveBeenCalled())
      it(`does not call onEndOfFile`, () => expect(onEndOfFile).not.toHaveBeenCalled())
    })

    describe(`when given a new line`, () => {
      beforeEach(() => linerClassifyCharacter.and.returnValue(`newLine`))
      describe(`when the accumulated text is empty`, () => {
        beforeEach(() => {
          linerTextNotEmpty.and.returnValue(false)
          get(`linerCharacter`)(liner, `Test Character`)
        })
        it(`increments line`, () => expect(liner.line).toEqual(2369))
        it(`empties text`, () => expect(liner.text).toEqual(``))
        it(`ends the line comment`, () => expect(liner.lineComment).toBeNull())
        it(`does not change the context`, () => expect(liner.context).toEqual(`Test Context`))
        it(`does not change onLine`, () => expect(liner.onLine).toBe(onLine))
        it(`does not change onEndOfFile`, () => expect(liner.onEndOfFile).toBe(onEndOfFile))
        it(`calls linerClassifyCharacter once`, () => expect(linerClassifyCharacter).toHaveBeenCalledTimes(1))
        it(`calls linerClassifyCharacter with the given character`, () => expect(linerClassifyCharacter).toHaveBeenCalledWith(`Test Character`))
        it(`calls linerTextNotEmpty once`, () => expect(linerTextNotEmpty).toHaveBeenCalledTimes(1))
        it(`calls linerTextNotEmpty with the text`, () => expect(linerTextNotEmpty).toHaveBeenCalledWith(`Test Text`))
        it(`does not call onLine`, () => expect(onLine).not.toHaveBeenCalled())
        it(`does not call onEndOfFile`, () => expect(onEndOfFile).not.toHaveBeenCalled())
      })

      describe(`when the accumulated text is not empty`, () => {
        beforeEach(() => {
          linerTextNotEmpty.and.returnValue(true)
          get(`linerCharacter`)(liner, `Test Character`)
        })
        it(`increments line`, () => expect(liner.line).toEqual(2369))
        it(`empties text`, () => expect(liner.text).toEqual(``))
        it(`ends the line comment`, () => expect(liner.lineComment).toBeNull())
        it(`does not change the context`, () => expect(liner.context).toEqual(`Test Context`))
        it(`does not change onLine`, () => expect(liner.onLine).toBe(onLine))
        it(`does not change onEndOfFile`, () => expect(liner.onEndOfFile).toBe(onEndOfFile))
        it(`calls linerClassifyCharacter once`, () => expect(linerClassifyCharacter).toHaveBeenCalledTimes(1))
        it(`calls linerClassifyCharacter with the given character`, () => expect(linerClassifyCharacter).toHaveBeenCalledWith(`Test Character`))
        it(`calls linerTextNotEmpty once`, () => expect(linerTextNotEmpty).toHaveBeenCalledTimes(1))
        it(`calls linerTextNotEmpty with the text`, () => expect(linerTextNotEmpty).toHaveBeenCalledWith(`Test Text`))
        it(`calls onLine once`, () => expect(onLine).toHaveBeenCalledTimes(1))
        it(`calls onLine with the context`, () => expect(onLine).toHaveBeenCalledWith(`Test Context`, jasmine.anything(), jasmine.anything()))
        it(`calls onLine with the line number`, () => expect(onLine).toHaveBeenCalledWith(jasmine.anything(), 2368, jasmine.anything()))
        it(`calls onLine with the text`, () => expect(onLine).toHaveBeenCalledWith(jasmine.anything(), jasmine.anything(), `Test Text`))
        it(`does not call onEndOfFile`, () => expect(onEndOfFile).not.toHaveBeenCalled())
      })
    })

    describe(`when given a part of line`, () => {
      beforeEach(() => {
        linerClassifyCharacter.and.returnValue(`partOfLine`)
        get(`linerCharacter`)(liner, `Test Character`)
      })
      it(`does not change line`, () => expect(liner.line).toEqual(2368))
      it(`does not change text`, () => expect(liner.text).toEqual(`Test Text`))
      it(`appends it to the end of the line comment`, () => expect(liner.lineComment).toEqual(`Test Line CommentTest Character`))
      it(`does not change the context`, () => expect(liner.context).toEqual(`Test Context`))
      it(`does not change onLine`, () => expect(liner.onLine).toBe(onLine))
      it(`does not change onEndOfFile`, () => expect(liner.onEndOfFile).toBe(onEndOfFile))
      it(`calls linerClassifyCharacter once`, () => expect(linerClassifyCharacter).toHaveBeenCalledTimes(1))
      it(`calls linerClassifyCharacter with the given character`, () => expect(linerClassifyCharacter).toHaveBeenCalledWith(`Test Character`))
      it(`does not call linerTextNotEmpty`, () => expect(linerTextNotEmpty).not.toHaveBeenCalled())
      it(`does not call onLine`, () => expect(onLine).not.toHaveBeenCalled())
      it(`does not call onEndOfFile`, () => expect(onEndOfFile).not.toHaveBeenCalled())
    })
  })
})

describe(`linerEndOfFile`, () => {
  const linerClassifyCharacter = setSpy(`linerClassifyCharacter`)
  const linerTextNotEmpty = setSpy(`linerTextNotEmpty`)
  const onLine = jasmine.createSpy(`onLine`)
  const onEndOfFile = jasmine.createSpy(`onEndOfFile`)
  let numberOfOnLineCallsAtTimeOfCallingOnEndOfFile
  onEndOfFile.and.callFake(() => {
    numberOfOnLineCallsAtTimeOfCallingOnEndOfFile = onLine.calls.count()
  })
  afterEach(() => {
    linerClassifyCharacter.calls.reset()
    linerTextNotEmpty.calls.reset()
    onLine.calls.reset()
    onEndOfFile.calls.reset()
  })
  let liner
  beforeEach(() => liner = {
    line: 2368,
    text: `Test Text`,
    context: `Test Context`,
    onLine,
    onEndOfFile
  })

  describe(`when not in a line comment`, () => {
    beforeEach(() => liner.lineComment = null)

    describe(`when the accumulated text is empty`, () => {
      beforeEach(() => {
        linerTextNotEmpty.and.returnValue(false)
        get(`linerEndOfFile`)(liner)
      })
      it(`does not call linerClassifyCharacter`, () => expect(linerClassifyCharacter).not.toHaveBeenCalled())
      it(`calls linerTextNotEmpty once`, () => expect(linerTextNotEmpty).toHaveBeenCalledTimes(1))
      it(`calls linerTextNotEmpty with the text`, () => expect(linerTextNotEmpty).toHaveBeenCalledWith(`Test Text`))
      it(`does not call onLine`, () => expect(onLine).not.toHaveBeenCalled())
      it(`calls onEndOfFile once`, () => expect(onEndOfFile).toHaveBeenCalledTimes(1))
    })

    describe(`when the accumulated text is not empty`, () => {
      beforeEach(() => {
        linerTextNotEmpty.and.returnValue(true)
        get(`linerEndOfFile`)(liner)
      })
      it(`does not call linerClassifyCharacter`, () => expect(linerClassifyCharacter).not.toHaveBeenCalled())
      it(`calls linerTextNotEmpty once`, () => expect(linerTextNotEmpty).toHaveBeenCalledTimes(1))
      it(`calls linerTextNotEmpty with the text`, () => expect(linerTextNotEmpty).toHaveBeenCalledWith(`Test Text`))
      it(`calls onLine once`, () => expect(onLine).toHaveBeenCalledTimes(1))
      it(`calls onLine with the context`, () => expect(onLine).toHaveBeenCalledWith(`Test Context`, jasmine.anything(), jasmine.anything()))
      it(`calls onLine with the line number`, () => expect(onLine).toHaveBeenCalledWith(jasmine.anything(), 2368, jasmine.anything()))
      it(`calls onLine with the text`, () => expect(onLine).toHaveBeenCalledWith(jasmine.anything(), jasmine.anything(), `Test Text`))
      it(`calls onEndOfFile once`, () => expect(onEndOfFile).toHaveBeenCalledTimes(1))
      it(`calls onLine before onEndOfFile`, () => expect(numberOfOnLineCallsAtTimeOfCallingOnEndOfFile).toEqual(1))
    })
  })

  describe(`when in a line comment`, () => {
    beforeEach(() => liner.lineComment = `Test Line Comment`)

    describe(`when the accumulated text is empty`, () => {
      beforeEach(() => {
        linerTextNotEmpty.and.returnValue(false)
        get(`linerEndOfFile`)(liner)
      })
      it(`does not call linerClassifyCharacter`, () => expect(linerClassifyCharacter).not.toHaveBeenCalled())
      it(`calls linerTextNotEmpty once`, () => expect(linerTextNotEmpty).toHaveBeenCalledTimes(1))
      it(`calls linerTextNotEmpty with the text`, () => expect(linerTextNotEmpty).toHaveBeenCalledWith(`Test Text`))
      it(`does not call onLine`, () => expect(onLine).not.toHaveBeenCalled())
      it(`calls onEndOfFile once`, () => expect(onEndOfFile).toHaveBeenCalledTimes(1))
    })

    describe(`when the accumulated text is not empty`, () => {
      beforeEach(() => {
        linerTextNotEmpty.and.returnValue(true)
        get(`linerEndOfFile`)(liner)
      })
      it(`does not call linerClassifyCharacter`, () => expect(linerClassifyCharacter).not.toHaveBeenCalled())
      it(`calls linerTextNotEmpty once`, () => expect(linerTextNotEmpty).toHaveBeenCalledTimes(1))
      it(`calls linerTextNotEmpty with the text`, () => expect(linerTextNotEmpty).toHaveBeenCalledWith(`Test Text`))
      it(`calls onLine once`, () => expect(onLine).toHaveBeenCalledTimes(1))
      it(`calls onLine with the context`, () => expect(onLine).toHaveBeenCalledWith(`Test Context`, jasmine.anything(), jasmine.anything()))
      it(`calls onLine with the line number`, () => expect(onLine).toHaveBeenCalledWith(jasmine.anything(), 2368, jasmine.anything()))
      it(`calls onLine with the text`, () => expect(onLine).toHaveBeenCalledWith(jasmine.anything(), jasmine.anything(), `Test Text`))
      it(`calls onEndOfFile once`, () => expect(onEndOfFile).toHaveBeenCalledTimes(1))
      it(`calls onLine before onEndOfFile`, () => expect(numberOfOnLineCallsAtTimeOfCallingOnEndOfFile).toEqual(1))
    })
  })
})

describe(`indenterCreate`, () => {
  it(`returns an object`, () => expect(get(`indenterCreate`)(`Test Context`, `Test On Line`, `Test On Indent`, `Test On Outdent`, `Test On Error`, `Test On End Of File`)).toEqual(jasmine.any(Object)))
  it(`returns stack, an array containing zero`, () => expect(get(`indenterCreate`)(`Test Context`, `Test On Line`, `Test On Indent`, `Test On Outdent`, `Test On Error`, `Test On End Of File`).stack).toEqual([0]))
  it(`returns indentationCharacter, null`, () => expect(get(`indenterCreate`)(`Test Context`, `Test On Line`, `Test On Indent`, `Test On Outdent`, `Test On Error`, `Test On End Of File`).indentationCharacter).toBeNull())
  it(`returns context, given`, () => expect(get(`indenterCreate`)(`Test Context`, `Test On Line`, `Test On Indent`, `Test On Outdent`, `Test On Error`, `Test On End Of File`).context).toEqual(`Test Context`))
  it(`returns onLine, given`, () => expect(get(`indenterCreate`)(`Test Context`, `Test On Line`, `Test On Indent`, `Test On Outdent`, `Test On Error`, `Test On End Of File`).onLine).toEqual(`Test On Line`))
  it(`returns onIndent, given`, () => expect(get(`indenterCreate`)(`Test Context`, `Test On Line`, `Test On Indent`, `Test On Outdent`, `Test On Error`, `Test On End Of File`).onIndent).toEqual(`Test On Indent`))
  it(`returns onOutdent, given`, () => expect(get(`indenterCreate`)(`Test Context`, `Test On Line`, `Test On Indent`, `Test On Outdent`, `Test On Error`, `Test On End Of File`).onOutdent).toEqual(`Test On Outdent`))
  it(`returns onError, given`, () => expect(get(`indenterCreate`)(`Test Context`, `Test On Line`, `Test On Indent`, `Test On Outdent`, `Test On Error`, `Test On End Of File`).onError).toEqual(`Test On Error`))
  it(`returns onEndOfFile, given`, () => expect(get(`indenterCreate`)(`Test Context`, `Test On Line`, `Test On Indent`, `Test On Outdent`, `Test On Error`, `Test On End Of File`).onEndOfFile).toEqual(`Test On End Of File`))
  it(`returns a new object every call`, () => expect(get(`indenterCreate`)(`Test Context`, `Test On Line`, `Test On Indent`, `Test On Outdent`, `Test On Error`, `Test On End Of File`)).not.toBe(get(`indenterCreate`)(`Test Context`, `Test On Line`, `Test On Indent`, `Test On Outdent`, `Test On Error`, `Test On End Of File`)))
  it(`returns a new stack every call`, () => expect(get(`indenterCreate`)(`Test Context`, `Test On Line`, `Test On Indent`, `Test On Outdent`, `Test On Error`, `Test On End Of File`).stack).not.toBe(get(`indenterCreate`)(`Test Context`, `Test On Line`, `Test On Indent`, `Test On Outdent`, `Test On Error`, `Test On End Of File`).stack))
  it(`returns the same value every call`, () => expect(get(`indenterCreate`)(`Test Context`, `Test On Line`, `Test On Indent`, `Test On Outdent`, `Test On Error`, `Test On End Of File`)).toEqual(get(`indenterCreate`)(`Test Context`, `Test On Line`, `Test On Indent`, `Test On Outdent`, `Test On Error`, `Test On End Of File`)))
})

describe(`indenterExtractIndentation`, () => {
  const run = (input, output) => describe(`given "${input}"`, () => it(`returns ${output}`, () => expect(get(`indenterExtractIndentation`)(input)).toEqual(output)))
  run(``, ``)
  run(` `, ` `)
  run(`\t`, `\t`)
  run(`   \t     \t  `, `   \t     \t  `)
  run(`a`, ``)
  run(` a`, ` `)
  run(`\ta`, `\t`)
  run(`   \t     \t  a`, `   \t     \t  `)
  run(`awdhk\tauwdh iyi`, ``)
  run(` awdhk\tauwdh iyi`, ` `)
  run(`\tawdhk\tauwdh iyi`, `\t`)
  run(`   \t     \t  awdhk auwdh iyi`, `   \t     \t  `)
  run(`awdhk\tauwdh iyi `, ``)
  run(`awdhk\tauwdh iyi\t`, ``)
  run(`awdhk\tauwdh iyi   \t     \t  `, ``)
  run(` awdhk\tauwdh iyi `, ` `)
  run(` awdhk\tauwdh iyi\t`, ` `)
  run(` awdhk\tauwdh iyi   \t     \t  `, ` `)
  run(`\tawdhk\tauwdh iyi `, `\t`)
  run(`\tawdhk\tauwdh iyi\t`, `\t`)
  run(`\tawdhk\tauwdh iyi   \t     \t  `, `\t`)
  run(`  \t \t  \t  awdhk\tauwdh iyi `, `  \t \t  \t  `)
  run(`  \t \t  \t  awdhk\tauwdh iyi\t`, `  \t \t  \t  `)
  run(`  \t \t  \t  awdhk\tauwdh iyi   \t     \t  `, `  \t \t  \t  `)
})

describe(`indenterExtractText`, () => {
  const run = (input, output) => describe(`given "${input}"`, () => it(`returns ${output}`, () => expect(get(`indenterExtractText`)(input)).toEqual(output)))
  run(``, ``)
  run(` `, ``)
  run(`\t`, ``)
  run(`   \t     \t  `, ``)
  run(`a`, `a`)
  run(` a`, `a`)
  run(`\ta`, `a`)
  run(`   \t     \t  a`, `a`)
  run(`awdhk\tauwdh iyi`, `awdhk\tauwdh iyi`)
  run(` awdhk\tauwdh iyi`, `awdhk\tauwdh iyi`)
  run(`\tawdhk\tauwdh iyi`, `awdhk\tauwdh iyi`)
  run(`   \t     \t  awdhk\tauwdh iyi`, `awdhk\tauwdh iyi`)
  run(`awdhk\tauwdh iyi `, `awdhk\tauwdh iyi`)
  run(`awdhk\tauwdh iyi\t`, `awdhk\tauwdh iyi`)
  run(`awdhk\tauwdh iyi   \t     \t  `, `awdhk\tauwdh iyi`)
  run(` awdhk\tauwdh iyi `, `awdhk\tauwdh iyi`)
  run(` awdhk\tauwdh iyi\t`, `awdhk\tauwdh iyi`)
  run(` awdhk\tauwdh iyi   \t     \t  `, `awdhk\tauwdh iyi`)
  run(`\tawdhk\tauwdh iyi `, `awdhk\tauwdh iyi`)
  run(`\tawdhk\tauwdh iyi\t`, `awdhk\tauwdh iyi`)
  run(`\tawdhk\tauwdh iyi   \t     \t  `, `awdhk\tauwdh iyi`)
  run(`  \t \t  \t  awdhk\tauwdh iyi `, `awdhk\tauwdh iyi`)
  run(`  \t \t  \t  awdhk\tauwdh iyi\t`, `awdhk\tauwdh iyi`)
  run(`  \t \t  \t  awdhk\tauwdh iyi   \t     \t  `, `awdhk\tauwdh iyi`)
})

describe(`indenterCheckWhiteSpace`, () => {
  const run = (input, output) => describe(`given "${input}"`, () => it(`returns ${output}`, () => expect(get(`indenterCheckWhiteSpace`)(input)).toEqual(output)))
  run(``, `none`)
  run(`a`, `a`)
  run(`aa`, `a`)
  run(`aaa`, `a`)
  run(`aaaa`, `a`)
  run(`ab`, `inconsistent`)
  run(`baa`, `inconsistent`)
  run(`aba`, `inconsistent`)
  run(`aab`, `inconsistent`)
  run(`abc`, `inconsistent`)
})

describe(`indenterLine`, () => {
  const indenterExtractIndentation = setSpy(`indenterExtractIndentation`)
  indenterExtractIndentation.and.returnValue(`Test Extracted Indentation`)
  const indenterExtractText = setSpy(`indenterExtractText`)
  indenterExtractText.and.returnValue(`Test Extracted Text`)
  const indenterMatch = setSpy(`indenterMatch`)
  indenterMatch.and.returnValue(`Test Matched Statement`)
  const indenterCheckWhiteSpace = setSpy(`indenterCheckWhiteSpace`)
  let numberOfOnIndentCallsAtTimeOfCallingOnLine
  let numberOfOnOutdentCallsAtTimeOfCallingOnLine
  const onLine = jasmine.createSpy(`onLine`)
  onLine.and.callFake(() => {
    numberOfOnIndentCallsAtTimeOfCallingOnLine = onIndent.calls.count()
    numberOfOnOutdentCallsAtTimeOfCallingOnLine = onOutdent.calls.count()
  })
  const onIndent = jasmine.createSpy(`onIndent`)
  const onOutdent = jasmine.createSpy(`onOutdent`)
  const onError = jasmine.createSpy(`onError`)
  const onEndOfFile = jasmine.createSpy(`onEndOfFile`)
  afterEach(() => {
    indenterExtractIndentation.calls.reset()
    indenterExtractText.calls.reset()
    indenterMatch.calls.reset()
    indenterCheckWhiteSpace.calls.reset()
    onLine.calls.reset()
    onIndent.calls.reset()
    onOutdent.calls.reset()
    onError.calls.reset()
    onEndOfFile.calls.reset()
  })
  let indenter
  beforeEach(() => indenter = {
    stack: [0],
    context: `Test Context`,
    onLine,
    onIndent,
    onOutdent,
    onError,
    onEndOfFile
  })

  describe(`when no indentation character has been found`, () => {
    beforeEach(() => indenter.indentationCharacter = null)

    describe(`when the given line does not have indentation`, () => {
      beforeEach(() => {
        indenterCheckWhiteSpace.and.returnValue(`none`)
        get(`indenterLine`)(indenter, 3897, `Test Line Text`)
      })
      it(`does not change stack`, () => expect(indenter.stack).toEqual([0]))
      it(`does not change indentationCharacter`, () => expect(indenter.indentationCharacter).toBeNull())
      it(`does not change context`, () => expect(indenter.context).toEqual(`Test Context`))
      it(`does not change onLine`, () => expect(indenter.onLine).toBe(onLine))
      it(`does not change onIndent`, () => expect(indenter.onIndent).toBe(onIndent))
      it(`does not change onOutdent`, () => expect(indenter.onOutdent).toBe(onOutdent))
      it(`does not change onError`, () => expect(indenter.onError).toBe(onError))
      it(`extracts indentation once`, () => expect(indenterExtractIndentation).toHaveBeenCalledTimes(1))
      it(`extracts indentation from the line text`, () => expect(indenterExtractIndentation).toHaveBeenCalledWith(`Test Line Text`))
      it(`extracts text once`, () => expect(indenterExtractText).toHaveBeenCalledTimes(1))
      it(`extracts text from the line text`, () => expect(indenterExtractText).toHaveBeenCalledWith(`Test Line Text`))
      it(`matches statements once`, () => expect(indenterMatch).toHaveBeenCalledTimes(1))
      it(`matches against the extracted text`, () => expect(indenterMatch).toHaveBeenCalledWith(`Test Extracted Text`))
      it(`checks white space once`, () => expect(indenterCheckWhiteSpace).toHaveBeenCalledTimes(1))
      it(`checks white space in the extracted indentation`, () => expect(indenterCheckWhiteSpace).toHaveBeenCalledWith(`Test Extracted Indentation`))
      it(`calls onLine once`, () => expect(onLine).toHaveBeenCalledTimes(1))
      it(`calls onLine with the context`, () => expect(onLine).toHaveBeenCalledWith(`Test Context`, jasmine.anything(), jasmine.anything(), jasmine.anything()))
      it(`calls onLine with the line number`, () => expect(onLine).toHaveBeenCalledWith(jasmine.anything(), 3897, jasmine.anything(), jasmine.anything()))
      it(`calls onLine with the extracted text`, () => expect(onLine).toHaveBeenCalledWith(jasmine.anything(), jasmine.anything(), `Test Extracted Text`, jasmine.anything()))
      it(`calls onLine with the matched statement`, () => expect(onLine).toHaveBeenCalledWith(jasmine.anything(), jasmine.anything(), jasmine.anything(), `Test Matched Statement`))
      it(`does not call onIndent`, () => expect(onIndent).not.toHaveBeenCalled())
      it(`does not call onOutdent`, () => expect(onOutdent).not.toHaveBeenCalled())
      it(`does not call onError`, () => expect(onError).not.toHaveBeenCalled())
      it(`does not call onEndOfFile`, () => expect(onEndOfFile).not.toHaveBeenCalled())
    })

    describe(`when the given line has inconsistent indentation`, () => {
      beforeEach(() => {
        indenterCheckWhiteSpace.and.returnValue(`inconsistent`)
        get(`indenterLine`)(indenter, 3897, `Test Line Text`)
      })
      it(`does not change stack`, () => expect(indenter.stack).toEqual([0]))
      it(`does not change indentationCharacter`, () => expect(indenter.indentationCharacter).toBeNull())
      it(`does not change context`, () => expect(indenter.context).toEqual(`Test Context`))
      it(`does not change onLine`, () => expect(indenter.onLine).toBe(onLine))
      it(`does not change onIndent`, () => expect(indenter.onIndent).toBe(onIndent))
      it(`does not change onOutdent`, () => expect(indenter.onOutdent).toBe(onOutdent))
      it(`does not change onError`, () => expect(indenter.onError).toBe(onError))
      it(`extracts indentation once`, () => expect(indenterExtractIndentation).toHaveBeenCalledTimes(1))
      it(`extracts indentation from the line text`, () => expect(indenterExtractIndentation).toHaveBeenCalledWith(`Test Line Text`))
      it(`does not extract text`, () => expect(indenterExtractText).not.toHaveBeenCalled())
      it(`does not match statements`, () => expect(indenterMatch).not.toHaveBeenCalled())
      it(`checks white space once`, () => expect(indenterCheckWhiteSpace).toHaveBeenCalledTimes(1))
      it(`checks white space in the extracted indentation`, () => expect(indenterCheckWhiteSpace).toHaveBeenCalledWith(`Test Extracted Indentation`))
      it(`does not call onLine`, () => expect(onLine).not.toHaveBeenCalled())
      it(`does not call onIndent`, () => expect(onIndent).not.toHaveBeenCalled())
      it(`does not call onOutdent`, () => expect(onOutdent).not.toHaveBeenCalled())
      it(`calls onError once`, () => expect(onError).toHaveBeenCalledTimes(1))
      it(`calls onError with the context`, () => expect(onError).toHaveBeenCalledWith(`Test Context`, jasmine.anything(), jasmine.anything()))
      it(`calls onError with the line number`, () => expect(onError).toHaveBeenCalledWith(jasmine.anything(), 3897, jasmine.anything()))
      it(`calls onError with a message informing the user that they cannot mix indentation white space`, () => expect(onError).toHaveBeenCalledWith(jasmine.anything(), jasmine.anything(), `Inconsistent indenting white space characters; it is likely that both spaces and tabs are being used to indent within the same file`))
      it(`does not call onEndOfFile`, () => expect(onEndOfFile).not.toHaveBeenCalled())
    })

    describe(`when the given line has indentation`, () => {
      beforeEach(() => {
        indenterCheckWhiteSpace.and.returnValue(`Test Indentation Character A`)
        get(`indenterLine`)(indenter, 3897, `Test Line Text`)
      })
      it(`appends the length of the indentation to the stack`, () => expect(indenter.stack).toEqual([0, 26]))
      it(`sets indentationCharacter to the indentation character`, () => expect(indenter.indentationCharacter).toEqual(`Test Indentation Character A`))
      it(`does not change context`, () => expect(indenter.context).toEqual(`Test Context`))
      it(`does not change onLine`, () => expect(indenter.onLine).toBe(onLine))
      it(`does not change onIndent`, () => expect(indenter.onIndent).toBe(onIndent))
      it(`does not change onOutdent`, () => expect(indenter.onOutdent).toBe(onOutdent))
      it(`does not change onError`, () => expect(indenter.onError).toBe(onError))
      it(`extracts indentation once`, () => expect(indenterExtractIndentation).toHaveBeenCalledTimes(1))
      it(`extracts indentation from the line text`, () => expect(indenterExtractIndentation).toHaveBeenCalledWith(`Test Line Text`))
      it(`extracts text once`, () => expect(indenterExtractText).toHaveBeenCalledTimes(1))
      it(`extracts text from the line text`, () => expect(indenterExtractText).toHaveBeenCalledWith(`Test Line Text`))
      it(`matches statements once`, () => expect(indenterMatch).toHaveBeenCalledTimes(1))
      it(`matches against the extracted text`, () => expect(indenterMatch).toHaveBeenCalledWith(`Test Extracted Text`))
      it(`checks white space once`, () => expect(indenterCheckWhiteSpace).toHaveBeenCalledTimes(1))
      it(`checks white space in the extracted indentation`, () => expect(indenterCheckWhiteSpace).toHaveBeenCalledWith(`Test Extracted Indentation`))
      it(`calls onLine once`, () => expect(onLine).toHaveBeenCalledTimes(1))
      it(`calls onLine with the context`, () => expect(onLine).toHaveBeenCalledWith(`Test Context`, jasmine.anything(), jasmine.anything(), jasmine.anything()))
      it(`calls onLine with the line number`, () => expect(onLine).toHaveBeenCalledWith(jasmine.anything(), 3897, jasmine.anything(), jasmine.anything()))
      it(`calls onLine with the extracted text`, () => expect(onLine).toHaveBeenCalledWith(jasmine.anything(), jasmine.anything(), `Test Extracted Text`, jasmine.anything()))
      it(`calls onLine with the matched statement`, () => expect(onLine).toHaveBeenCalledWith(jasmine.anything(), jasmine.anything(), jasmine.anything(), `Test Matched Statement`))
      it(`calls onIndent once`, () => expect(onIndent).toHaveBeenCalledTimes(1))
      it(`calls onIndent with the context`, () => expect(onIndent).toHaveBeenCalledWith(`Test Context`, jasmine.anything()))
      it(`calls onIndent with the line number`, () => expect(onIndent).toHaveBeenCalledWith(jasmine.anything(), 3897))
      it(`calls onIndent before onLine`, () => expect(numberOfOnIndentCallsAtTimeOfCallingOnLine).toEqual(1))
      it(`does not call onOutdent`, () => expect(onOutdent).not.toHaveBeenCalled())
      it(`does not call onError`, () => expect(onError).not.toHaveBeenCalled())
      it(`does not call onEndOfFile`, () => expect(onEndOfFile).not.toHaveBeenCalled())
    })
  })

  describe(`when an indentation character has been found`, () => {
    beforeEach(() => indenter.indentationCharacter = `Test Indentation Character A`)

    describe(`when the given line does not have indentation`, () => {
      beforeEach(() => {
        indenter.stack = [0, 14, 27, 36, 42]
        indenterCheckWhiteSpace.and.returnValue(`none`)
        get(`indenterLine`)(indenter, 3897, `Test Line Text`)
      })
      it(`clears the stack`, () => expect(indenter.stack).toEqual([0]))
      it(`does not change the indentation character`, () => expect(indenter.indentationCharacter).toEqual(`Test Indentation Character A`))
      it(`does not change context`, () => expect(indenter.context).toEqual(`Test Context`))
      it(`does not change onLine`, () => expect(indenter.onLine).toBe(onLine))
      it(`does not change onIndent`, () => expect(indenter.onIndent).toBe(onIndent))
      it(`does not change onOutdent`, () => expect(indenter.onOutdent).toBe(onOutdent))
      it(`does not change onError`, () => expect(indenter.onError).toBe(onError))
      it(`extracts indentation once`, () => expect(indenterExtractIndentation).toHaveBeenCalledTimes(1))
      it(`extracts indentation from the line text`, () => expect(indenterExtractIndentation).toHaveBeenCalledWith(`Test Line Text`))
      it(`extracts text once`, () => expect(indenterExtractText).toHaveBeenCalledTimes(1))
      it(`extracts text from the line text`, () => expect(indenterExtractText).toHaveBeenCalledWith(`Test Line Text`))
      it(`matches statements once`, () => expect(indenterMatch).toHaveBeenCalledTimes(1))
      it(`matches against the extracted text`, () => expect(indenterMatch).toHaveBeenCalledWith(`Test Extracted Text`))
      it(`checks white space once`, () => expect(indenterCheckWhiteSpace).toHaveBeenCalledTimes(1))
      it(`checks white space in the extracted indentation`, () => expect(indenterCheckWhiteSpace).toHaveBeenCalledWith(`Test Extracted Indentation`))
      it(`calls onLine once`, () => expect(onLine).toHaveBeenCalledTimes(1))
      it(`calls onLine with the context`, () => expect(onLine).toHaveBeenCalledWith(`Test Context`, jasmine.anything(), jasmine.anything(), jasmine.anything()))
      it(`calls onLine with the line number`, () => expect(onLine).toHaveBeenCalledWith(jasmine.anything(), 3897, jasmine.anything(), jasmine.anything()))
      it(`calls onLine with the extracted text`, () => expect(onLine).toHaveBeenCalledWith(jasmine.anything(), jasmine.anything(), `Test Extracted Text`, jasmine.anything()))
      it(`calls onLine with the matched statement`, () => expect(onLine).toHaveBeenCalledWith(jasmine.anything(), jasmine.anything(), jasmine.anything(), `Test Matched Statement`))
      it(`does not call onIndent`, () => expect(onIndent).not.toHaveBeenCalled())
      it(`calls onOutdent once per eliminated stack level`, () => expect(onOutdent).toHaveBeenCalledTimes(4))
      it(`calls onOutdent with the context`, () => {
        expect(onOutdent.calls.argsFor(0)).toEqual([`Test Context`, jasmine.anything()])
        expect(onOutdent.calls.argsFor(1)).toEqual([`Test Context`, jasmine.anything()])
        expect(onOutdent.calls.argsFor(2)).toEqual([`Test Context`, jasmine.anything()])
        expect(onOutdent.calls.argsFor(3)).toEqual([`Test Context`, jasmine.anything()])
      })
      it(`calls onOutdent with the line number`, () => {
        expect(onOutdent.calls.argsFor(0)).toEqual([jasmine.anything(), 3897])
        expect(onOutdent.calls.argsFor(1)).toEqual([jasmine.anything(), 3897])
        expect(onOutdent.calls.argsFor(2)).toEqual([jasmine.anything(), 3897])
        expect(onOutdent.calls.argsFor(3)).toEqual([jasmine.anything(), 3897])
      })
      it(`calls onOutdent before onLine`, () => expect(numberOfOnOutdentCallsAtTimeOfCallingOnLine).toEqual(4))
      it(`does not call onError`, () => expect(onError).not.toHaveBeenCalled())
      it(`does not call onEndOfFile`, () => expect(onEndOfFile).not.toHaveBeenCalled())
    })

    describe(`when the given line has inconsistent indentation`, () => {
      beforeEach(() => {
        indenter.stack = [0, 14, 27, 36, 42]
        indenterCheckWhiteSpace.and.returnValue(`inconsistent`)
        get(`indenterLine`)(indenter, 3897, `Test Line Text`)
      })
      it(`does not change stack`, () => expect(indenter.stack).toEqual([0, 14, 27, 36, 42]))
      it(`does not change indentationCharacter`, () => expect(indenter.indentationCharacter).toEqual(`Test Indentation Character A`))
      it(`does not change context`, () => expect(indenter.context).toEqual(`Test Context`))
      it(`does not change onLine`, () => expect(indenter.onLine).toBe(onLine))
      it(`does not change onIndent`, () => expect(indenter.onIndent).toBe(onIndent))
      it(`does not change onOutdent`, () => expect(indenter.onOutdent).toBe(onOutdent))
      it(`does not change onError`, () => expect(indenter.onError).toBe(onError))
      it(`extracts indentation once`, () => expect(indenterExtractIndentation).toHaveBeenCalledTimes(1))
      it(`extracts indentation from the line text`, () => expect(indenterExtractIndentation).toHaveBeenCalledWith(`Test Line Text`))
      it(`does not extract text`, () => expect(indenterExtractText).not.toHaveBeenCalled())
      it(`does not match statements`, () => expect(indenterMatch).not.toHaveBeenCalled())
      it(`checks white space once`, () => expect(indenterCheckWhiteSpace).toHaveBeenCalledTimes(1))
      it(`checks white space in the extracted indentation`, () => expect(indenterCheckWhiteSpace).toHaveBeenCalledWith(`Test Extracted Indentation`))
      it(`does not call onLine`, () => expect(onLine).not.toHaveBeenCalled())
      it(`does not call onIndent`, () => expect(onIndent).not.toHaveBeenCalled())
      it(`does not call onOutdent`, () => expect(onOutdent).not.toHaveBeenCalled())
      it(`calls onError once`, () => expect(onError).toHaveBeenCalledTimes(1))
      it(`calls onError with the context`, () => expect(onError).toHaveBeenCalledWith(`Test Context`, jasmine.anything(), jasmine.anything()))
      it(`calls onError with the line number`, () => expect(onError).toHaveBeenCalledWith(jasmine.anything(), 3897, jasmine.anything()))
      it(`calls onError with a message informing the user that they cannot mix indentation white space`, () => expect(onError).toHaveBeenCalledWith(jasmine.anything(), jasmine.anything(), `Inconsistent indenting white space characters; it is likely that both spaces and tabs are being used to indent within the same file`))
      it(`does not call onEndOfFile`, () => expect(onEndOfFile).not.toHaveBeenCalled())
    })

    describe(`when the given line has indentation inconsistent with the rest of the file`, () => {
      beforeEach(() => indenterCheckWhiteSpace.and.returnValue(`Test Indentation Character B`))
      describe(`when the indentation is greater than the top of the stack`, () => {
        beforeEach(() => {
          indenter.stack = [0, 4, 6, 10, 24]
          get(`indenterLine`)(indenter, 3897, `Test Line Text`)
        })
        it(`does not change stack`, () => expect(indenter.stack).toEqual([0, 4, 6, 10, 24]))
        it(`does not change indentationCharacter`, () => expect(indenter.indentationCharacter).toEqual(`Test Indentation Character A`))
        it(`does not change context`, () => expect(indenter.context).toEqual(`Test Context`))
        it(`does not change onLine`, () => expect(indenter.onLine).toBe(onLine))
        it(`does not change onIndent`, () => expect(indenter.onIndent).toBe(onIndent))
        it(`does not change onOutdent`, () => expect(indenter.onOutdent).toBe(onOutdent))
        it(`does not change onError`, () => expect(indenter.onError).toBe(onError))
        it(`extracts indentation once`, () => expect(indenterExtractIndentation).toHaveBeenCalledTimes(1))
        it(`extracts indentation from the line text`, () => expect(indenterExtractIndentation).toHaveBeenCalledWith(`Test Line Text`))
        it(`does not extract text`, () => expect(indenterExtractText).not.toHaveBeenCalled())
        it(`does not match statements`, () => expect(indenterMatch).not.toHaveBeenCalled())
        it(`checks white space once`, () => expect(indenterCheckWhiteSpace).toHaveBeenCalledTimes(1))
        it(`checks white space in the extracted indentation`, () => expect(indenterCheckWhiteSpace).toHaveBeenCalledWith(`Test Extracted Indentation`))
        it(`does not call onLine`, () => expect(onLine).not.toHaveBeenCalled())
        it(`does not call onIndent`, () => expect(onIndent).not.toHaveBeenCalled())
        it(`does not call onOutdent`, () => expect(onOutdent).not.toHaveBeenCalled())
        it(`calls onError once`, () => expect(onError).toHaveBeenCalledTimes(1))
        it(`calls onError with the context`, () => expect(onError).toHaveBeenCalledWith(`Test Context`, jasmine.anything(), jasmine.anything()))
        it(`calls onError with the line number`, () => expect(onError).toHaveBeenCalledWith(jasmine.anything(), 3897, jasmine.anything()))
        it(`calls onError with a message informing the user that they cannot mix indentation white space`, () => expect(onError).toHaveBeenCalledWith(jasmine.anything(), jasmine.anything(), `Inconsistent indenting white space characters; it is likely that both spaces and tabs are being used to indent within the same file`))
        it(`does not call onEndOfFile`, () => expect(onEndOfFile).not.toHaveBeenCalled())
      })

      describe(`when the indentation matches the top of the stack`, () => {
        beforeEach(() => {
          indenter.stack = [0, 4, 6, 10, 26]
          get(`indenterLine`)(indenter, 3897, `Test Line Text`)
        })
        it(`does not change stack`, () => expect(indenter.stack).toEqual([0, 4, 6, 10, 26]))
        it(`does not change indentationCharacter`, () => expect(indenter.indentationCharacter).toEqual(`Test Indentation Character A`))
        it(`does not change context`, () => expect(indenter.context).toEqual(`Test Context`))
        it(`does not change onLine`, () => expect(indenter.onLine).toBe(onLine))
        it(`does not change onIndent`, () => expect(indenter.onIndent).toBe(onIndent))
        it(`does not change onOutdent`, () => expect(indenter.onOutdent).toBe(onOutdent))
        it(`does not change onError`, () => expect(indenter.onError).toBe(onError))
        it(`extracts indentation once`, () => expect(indenterExtractIndentation).toHaveBeenCalledTimes(1))
        it(`extracts indentation from the line text`, () => expect(indenterExtractIndentation).toHaveBeenCalledWith(`Test Line Text`))
        it(`does not extract text`, () => expect(indenterExtractText).not.toHaveBeenCalled())
        it(`does not match statements`, () => expect(indenterMatch).not.toHaveBeenCalled())
        it(`checks white space once`, () => expect(indenterCheckWhiteSpace).toHaveBeenCalledTimes(1))
        it(`checks white space in the extracted indentation`, () => expect(indenterCheckWhiteSpace).toHaveBeenCalledWith(`Test Extracted Indentation`))
        it(`does not call onLine`, () => expect(onLine).not.toHaveBeenCalled())
        it(`does not call onIndent`, () => expect(onIndent).not.toHaveBeenCalled())
        it(`does not call onOutdent`, () => expect(onOutdent).not.toHaveBeenCalled())
        it(`calls onError once`, () => expect(onError).toHaveBeenCalledTimes(1))
        it(`calls onError with the context`, () => expect(onError).toHaveBeenCalledWith(`Test Context`, jasmine.anything(), jasmine.anything()))
        it(`calls onError with the line number`, () => expect(onError).toHaveBeenCalledWith(jasmine.anything(), 3897, jasmine.anything()))
        it(`calls onError with a message informing the user that they cannot mix indentation white space`, () => expect(onError).toHaveBeenCalledWith(jasmine.anything(), jasmine.anything(), `Inconsistent indenting white space characters; it is likely that both spaces and tabs are being used to indent within the same file`))
        it(`does not call onEndOfFile`, () => expect(onEndOfFile).not.toHaveBeenCalled())
      })

      describe(`when the indentation is between the top and first under on the stack`, () => {
        beforeEach(() => {
          indenter.stack = [0, 4, 6, 10, 28]
          get(`indenterLine`)(indenter, 3897, `Test Line Text`)
        })
        it(`does not change stack`, () => expect(indenter.stack).toEqual([0, 4, 6, 10, 28]))
        it(`does not change indentationCharacter`, () => expect(indenter.indentationCharacter).toEqual(`Test Indentation Character A`))
        it(`does not change context`, () => expect(indenter.context).toEqual(`Test Context`))
        it(`does not change onLine`, () => expect(indenter.onLine).toBe(onLine))
        it(`does not change onIndent`, () => expect(indenter.onIndent).toBe(onIndent))
        it(`does not change onOutdent`, () => expect(indenter.onOutdent).toBe(onOutdent))
        it(`does not change onError`, () => expect(indenter.onError).toBe(onError))
        it(`extracts indentation once`, () => expect(indenterExtractIndentation).toHaveBeenCalledTimes(1))
        it(`extracts indentation from the line text`, () => expect(indenterExtractIndentation).toHaveBeenCalledWith(`Test Line Text`))
        it(`does not extract text`, () => expect(indenterExtractText).not.toHaveBeenCalled())
        it(`does not match statements`, () => expect(indenterMatch).not.toHaveBeenCalled())
        it(`checks white space once`, () => expect(indenterCheckWhiteSpace).toHaveBeenCalledTimes(1))
        it(`checks white space in the extracted indentation`, () => expect(indenterCheckWhiteSpace).toHaveBeenCalledWith(`Test Extracted Indentation`))
        it(`does not call onLine`, () => expect(onLine).not.toHaveBeenCalled())
        it(`does not call onIndent`, () => expect(onIndent).not.toHaveBeenCalled())
        it(`does not call onOutdent`, () => expect(onOutdent).not.toHaveBeenCalled())
        it(`calls onError once`, () => expect(onError).toHaveBeenCalledTimes(1))
        it(`calls onError with the context`, () => expect(onError).toHaveBeenCalledWith(`Test Context`, jasmine.anything(), jasmine.anything()))
        it(`calls onError with the line number`, () => expect(onError).toHaveBeenCalledWith(jasmine.anything(), 3897, jasmine.anything()))
        it(`calls onError with a message informing the user that they cannot mix indentation white space`, () => expect(onError).toHaveBeenCalledWith(jasmine.anything(), jasmine.anything(), `Inconsistent indenting white space characters; it is likely that both spaces and tabs are being used to indent within the same file`))
        it(`does not call onEndOfFile`, () => expect(onEndOfFile).not.toHaveBeenCalled())
      })

      describe(`when the indentation is the first under on the stack`, () => {
        beforeEach(() => {
          indenter.stack = [0, 4, 6, 26, 31]
          get(`indenterLine`)(indenter, 3897, `Test Line Text`)
        })
        it(`does not change stack`, () => expect(indenter.stack).toEqual([0, 4, 6, 26, 31]))
        it(`does not change indentationCharacter`, () => expect(indenter.indentationCharacter).toEqual(`Test Indentation Character A`))
        it(`does not change context`, () => expect(indenter.context).toEqual(`Test Context`))
        it(`does not change onLine`, () => expect(indenter.onLine).toBe(onLine))
        it(`does not change onIndent`, () => expect(indenter.onIndent).toBe(onIndent))
        it(`does not change onOutdent`, () => expect(indenter.onOutdent).toBe(onOutdent))
        it(`does not change onError`, () => expect(indenter.onError).toBe(onError))
        it(`extracts indentation once`, () => expect(indenterExtractIndentation).toHaveBeenCalledTimes(1))
        it(`extracts indentation from the line text`, () => expect(indenterExtractIndentation).toHaveBeenCalledWith(`Test Line Text`))
        it(`does not extract text`, () => expect(indenterExtractText).not.toHaveBeenCalled())
        it(`does not match statements`, () => expect(indenterMatch).not.toHaveBeenCalled())
        it(`checks white space once`, () => expect(indenterCheckWhiteSpace).toHaveBeenCalledTimes(1))
        it(`checks white space in the extracted indentation`, () => expect(indenterCheckWhiteSpace).toHaveBeenCalledWith(`Test Extracted Indentation`))
        it(`does not call onLine`, () => expect(onLine).not.toHaveBeenCalled())
        it(`does not call onIndent`, () => expect(onIndent).not.toHaveBeenCalled())
        it(`does not call onOutdent`, () => expect(onOutdent).not.toHaveBeenCalled())
        it(`calls onError once`, () => expect(onError).toHaveBeenCalledTimes(1))
        it(`calls onError with the context`, () => expect(onError).toHaveBeenCalledWith(`Test Context`, jasmine.anything(), jasmine.anything()))
        it(`calls onError with the line number`, () => expect(onError).toHaveBeenCalledWith(jasmine.anything(), 3897, jasmine.anything()))
        it(`calls onError with a message informing the user that they cannot mix indentation white space`, () => expect(onError).toHaveBeenCalledWith(jasmine.anything(), jasmine.anything(), `Inconsistent indenting white space characters; it is likely that both spaces and tabs are being used to indent within the same file`))
        it(`does not call onEndOfFile`, () => expect(onEndOfFile).not.toHaveBeenCalled())
      })

      describe(`when the indentation is between the first and second under on the stack`, () => {
        beforeEach(() => {
          indenter.stack = [0, 4, 6, 29, 31]
          get(`indenterLine`)(indenter, 3897, `Test Line Text`)
        })
        it(`does not change stack`, () => expect(indenter.stack).toEqual([0, 4, 6, 29, 31]))
        it(`does not change indentationCharacter`, () => expect(indenter.indentationCharacter).toEqual(`Test Indentation Character A`))
        it(`does not change context`, () => expect(indenter.context).toEqual(`Test Context`))
        it(`does not change onLine`, () => expect(indenter.onLine).toBe(onLine))
        it(`does not change onIndent`, () => expect(indenter.onIndent).toBe(onIndent))
        it(`does not change onOutdent`, () => expect(indenter.onOutdent).toBe(onOutdent))
        it(`does not change onError`, () => expect(indenter.onError).toBe(onError))
        it(`extracts indentation once`, () => expect(indenterExtractIndentation).toHaveBeenCalledTimes(1))
        it(`extracts indentation from the line text`, () => expect(indenterExtractIndentation).toHaveBeenCalledWith(`Test Line Text`))
        it(`does not extract text`, () => expect(indenterExtractText).not.toHaveBeenCalled())
        it(`does not match statements`, () => expect(indenterMatch).not.toHaveBeenCalled())
        it(`checks white space once`, () => expect(indenterCheckWhiteSpace).toHaveBeenCalledTimes(1))
        it(`checks white space in the extracted indentation`, () => expect(indenterCheckWhiteSpace).toHaveBeenCalledWith(`Test Extracted Indentation`))
        it(`does not call onLine`, () => expect(onLine).not.toHaveBeenCalled())
        it(`does not call onIndent`, () => expect(onIndent).not.toHaveBeenCalled())
        it(`does not call onOutdent`, () => expect(onOutdent).not.toHaveBeenCalled())
        it(`calls onError once`, () => expect(onError).toHaveBeenCalledTimes(1))
        it(`calls onError with the context`, () => expect(onError).toHaveBeenCalledWith(`Test Context`, jasmine.anything(), jasmine.anything()))
        it(`calls onError with the line number`, () => expect(onError).toHaveBeenCalledWith(jasmine.anything(), 3897, jasmine.anything()))
        it(`calls onError with a message informing the user that they cannot mix indentation white space`, () => expect(onError).toHaveBeenCalledWith(jasmine.anything(), jasmine.anything(), `Inconsistent indenting white space characters; it is likely that both spaces and tabs are being used to indent within the same file`))
        it(`does not call onEndOfFile`, () => expect(onEndOfFile).not.toHaveBeenCalled())
      })

      describe(`when the indentation is the second under on the stack`, () => {
        beforeEach(() => {
          indenter.stack = [0, 4, 26, 29, 31]
          get(`indenterLine`)(indenter, 3897, `Test Line Text`)
        })
        it(`does not change stack`, () => expect(indenter.stack).toEqual([0, 4, 26, 29, 31]))
        it(`does not change indentationCharacter`, () => expect(indenter.indentationCharacter).toEqual(`Test Indentation Character A`))
        it(`does not change context`, () => expect(indenter.context).toEqual(`Test Context`))
        it(`does not change onLine`, () => expect(indenter.onLine).toBe(onLine))
        it(`does not change onIndent`, () => expect(indenter.onIndent).toBe(onIndent))
        it(`does not change onOutdent`, () => expect(indenter.onOutdent).toBe(onOutdent))
        it(`does not change onError`, () => expect(indenter.onError).toBe(onError))
        it(`extracts indentation once`, () => expect(indenterExtractIndentation).toHaveBeenCalledTimes(1))
        it(`extracts indentation from the line text`, () => expect(indenterExtractIndentation).toHaveBeenCalledWith(`Test Line Text`))
        it(`does not extract text`, () => expect(indenterExtractText).not.toHaveBeenCalled())
        it(`does not match statements`, () => expect(indenterMatch).not.toHaveBeenCalled())
        it(`checks white space once`, () => expect(indenterCheckWhiteSpace).toHaveBeenCalledTimes(1))
        it(`checks white space in the extracted indentation`, () => expect(indenterCheckWhiteSpace).toHaveBeenCalledWith(`Test Extracted Indentation`))
        it(`does not call onLine`, () => expect(onLine).not.toHaveBeenCalled())
        it(`does not call onIndent`, () => expect(onIndent).not.toHaveBeenCalled())
        it(`does not call onOutdent`, () => expect(onOutdent).not.toHaveBeenCalled())
        it(`calls onError once`, () => expect(onError).toHaveBeenCalledTimes(1))
        it(`calls onError with the context`, () => expect(onError).toHaveBeenCalledWith(`Test Context`, jasmine.anything(), jasmine.anything()))
        it(`calls onError with the line number`, () => expect(onError).toHaveBeenCalledWith(jasmine.anything(), 3897, jasmine.anything()))
        it(`calls onError with a message informing the user that they cannot mix indentation white space`, () => expect(onError).toHaveBeenCalledWith(jasmine.anything(), jasmine.anything(), `Inconsistent indenting white space characters; it is likely that both spaces and tabs are being used to indent within the same file`))
        it(`does not call onEndOfFile`, () => expect(onEndOfFile).not.toHaveBeenCalled())
      })
    })

    describe(`when the given line has indentation`, () => {
      beforeEach(() => {
        indenterCheckWhiteSpace.and.returnValue(`Test Indentation Character A`)
      })

      describe(`when the indentation is greater than the top of the stack`, () => {
        beforeEach(() => {
          indenter.stack = [0, 4, 6, 10, 24]
          get(`indenterLine`)(indenter, 3897, `Test Line Text`)
        })
        it(`appends the length of the indentation to the stack`, () => expect(indenter.stack).toEqual([0, 4, 6, 10, 24, 26]))
        it(`sets indentationCharacter to the indentation character`, () => expect(indenter.indentationCharacter).toEqual(`Test Indentation Character A`))
        it(`does not change context`, () => expect(indenter.context).toEqual(`Test Context`))
        it(`does not change onLine`, () => expect(indenter.onLine).toBe(onLine))
        it(`does not change onIndent`, () => expect(indenter.onIndent).toBe(onIndent))
        it(`does not change onOutdent`, () => expect(indenter.onOutdent).toBe(onOutdent))
        it(`does not change onError`, () => expect(indenter.onError).toBe(onError))
        it(`extracts indentation once`, () => expect(indenterExtractIndentation).toHaveBeenCalledTimes(1))
        it(`extracts indentation from the line text`, () => expect(indenterExtractIndentation).toHaveBeenCalledWith(`Test Line Text`))
        it(`extracts text once`, () => expect(indenterExtractText).toHaveBeenCalledTimes(1))
        it(`extracts text from the line text`, () => expect(indenterExtractText).toHaveBeenCalledWith(`Test Line Text`))
        it(`matches statements once`, () => expect(indenterMatch).toHaveBeenCalledTimes(1))
        it(`matches against the extracted text`, () => expect(indenterMatch).toHaveBeenCalledWith(`Test Extracted Text`))
        it(`checks white space once`, () => expect(indenterCheckWhiteSpace).toHaveBeenCalledTimes(1))
        it(`checks white space in the extracted indentation`, () => expect(indenterCheckWhiteSpace).toHaveBeenCalledWith(`Test Extracted Indentation`))
        it(`calls onLine once`, () => expect(onLine).toHaveBeenCalledTimes(1))
        it(`calls onLine with the context`, () => expect(onLine).toHaveBeenCalledWith(`Test Context`, jasmine.anything(), jasmine.anything(), jasmine.anything()))
        it(`calls onLine with the line number`, () => expect(onLine).toHaveBeenCalledWith(jasmine.anything(), 3897, jasmine.anything(), jasmine.anything()))
        it(`calls onLine with the extracted text`, () => expect(onLine).toHaveBeenCalledWith(jasmine.anything(), jasmine.anything(), `Test Extracted Text`, jasmine.anything()))
        it(`calls onLine with the matched statement`, () => expect(onLine).toHaveBeenCalledWith(jasmine.anything(), jasmine.anything(), jasmine.anything(), `Test Matched Statement`))
        it(`calls onIndent once`, () => expect(onIndent).toHaveBeenCalledTimes(1))
        it(`calls onIndent with the context`, () => expect(onIndent).toHaveBeenCalledWith(`Test Context`, jasmine.anything()))
        it(`calls onIndent with the line number`, () => expect(onIndent).toHaveBeenCalledWith(jasmine.anything(), 3897))
        it(`calls onIndent before onLine`, () => expect(numberOfOnIndentCallsAtTimeOfCallingOnLine).toEqual(1))
        it(`does not call onOutdent`, () => expect(onOutdent).not.toHaveBeenCalled())
        it(`does not call onError`, () => expect(onError).not.toHaveBeenCalled())
        it(`does not call onEndOfFile`, () => expect(onEndOfFile).not.toHaveBeenCalled())
      })

      describe(`when the indentation matches the top of the stack`, () => {
        beforeEach(() => {
          indenter.stack = [0, 4, 6, 10, 26]
          get(`indenterLine`)(indenter, 3897, `Test Line Text`)
        })
        it(`does not change the stack`, () => expect(indenter.stack).toEqual([0, 4, 6, 10, 26]))
        it(`sets indentationCharacter to the indentation character`, () => expect(indenter.indentationCharacter).toEqual(`Test Indentation Character A`))
        it(`does not change context`, () => expect(indenter.context).toEqual(`Test Context`))
        it(`does not change onLine`, () => expect(indenter.onLine).toBe(onLine))
        it(`does not change onIndent`, () => expect(indenter.onIndent).toBe(onIndent))
        it(`does not change onOutdent`, () => expect(indenter.onOutdent).toBe(onOutdent))
        it(`does not change onError`, () => expect(indenter.onError).toBe(onError))
        it(`extracts indentation once`, () => expect(indenterExtractIndentation).toHaveBeenCalledTimes(1))
        it(`extracts indentation from the line text`, () => expect(indenterExtractIndentation).toHaveBeenCalledWith(`Test Line Text`))
        it(`extracts text once`, () => expect(indenterExtractText).toHaveBeenCalledTimes(1))
        it(`extracts text from the line text`, () => expect(indenterExtractText).toHaveBeenCalledWith(`Test Line Text`))
        it(`matches statements once`, () => expect(indenterMatch).toHaveBeenCalledTimes(1))
        it(`matches against the extracted text`, () => expect(indenterMatch).toHaveBeenCalledWith(`Test Extracted Text`))
        it(`checks white space once`, () => expect(indenterCheckWhiteSpace).toHaveBeenCalledTimes(1))
        it(`checks white space in the extracted indentation`, () => expect(indenterCheckWhiteSpace).toHaveBeenCalledWith(`Test Extracted Indentation`))
        it(`calls onLine once`, () => expect(onLine).toHaveBeenCalledTimes(1))
        it(`calls onLine with the context`, () => expect(onLine).toHaveBeenCalledWith(`Test Context`, jasmine.anything(), jasmine.anything(), jasmine.anything()))
        it(`calls onLine with the line number`, () => expect(onLine).toHaveBeenCalledWith(jasmine.anything(), 3897, jasmine.anything(), jasmine.anything()))
        it(`calls onLine with the extracted text`, () => expect(onLine).toHaveBeenCalledWith(jasmine.anything(), jasmine.anything(), `Test Extracted Text`, jasmine.anything()))
        it(`calls onLine with the matched statement`, () => expect(onLine).toHaveBeenCalledWith(jasmine.anything(), jasmine.anything(), jasmine.anything(), `Test Matched Statement`))
        it(`does not call onIndent`, () => expect(onIndent).not.toHaveBeenCalled())
        it(`does not call onOutdent`, () => expect(onOutdent).not.toHaveBeenCalled())
        it(`does not call onError`, () => expect(onError).not.toHaveBeenCalled())
        it(`does not call onEndOfFile`, () => expect(onEndOfFile).not.toHaveBeenCalled())
      })

      describe(`when the indentation is between the top and first under on the stack`, () => {
        beforeEach(() => {
          indenter.stack = [0, 4, 6, 10, 28]
          get(`indenterLine`)(indenter, 3897, `Test Line Text`)
        })
        it(`does not change stack`, () => expect(indenter.stack).toEqual([0, 4, 6, 10, 28]))
        it(`does not change indentationCharacter`, () => expect(indenter.indentationCharacter).toEqual(`Test Indentation Character A`))
        it(`does not change context`, () => expect(indenter.context).toEqual(`Test Context`))
        it(`does not change onLine`, () => expect(indenter.onLine).toBe(onLine))
        it(`does not change onIndent`, () => expect(indenter.onIndent).toBe(onIndent))
        it(`does not change onOutdent`, () => expect(indenter.onOutdent).toBe(onOutdent))
        it(`does not change onError`, () => expect(indenter.onError).toBe(onError))
        it(`extracts indentation once`, () => expect(indenterExtractIndentation).toHaveBeenCalledTimes(1))
        it(`extracts indentation from the line text`, () => expect(indenterExtractIndentation).toHaveBeenCalledWith(`Test Line Text`))
        it(`does not extract text`, () => expect(indenterExtractText).not.toHaveBeenCalled())
        it(`does not match statements`, () => expect(indenterMatch).not.toHaveBeenCalled())
        it(`checks white space once`, () => expect(indenterCheckWhiteSpace).toHaveBeenCalledTimes(1))
        it(`checks white space in the extracted indentation`, () => expect(indenterCheckWhiteSpace).toHaveBeenCalledWith(`Test Extracted Indentation`))
        it(`does not call onLine`, () => expect(onLine).not.toHaveBeenCalled())
        it(`does not call onIndent`, () => expect(onIndent).not.toHaveBeenCalled())
        it(`does not call onOutdent`, () => expect(onOutdent).not.toHaveBeenCalled())
        it(`calls onError once`, () => expect(onError).toHaveBeenCalledTimes(1))
        it(`calls onError with the context`, () => expect(onError).toHaveBeenCalledWith(`Test Context`, jasmine.anything(), jasmine.anything()))
        it(`calls onError with the line number`, () => expect(onError).toHaveBeenCalledWith(jasmine.anything(), 3897, jasmine.anything()))
        it(`calls onError with a message informing the user that they cannot outdent to a level they have not previously indented to`, () => expect(onError).toHaveBeenCalledWith(jasmine.anything(), jasmine.anything(), `Outdent to level not previously indented to`))
        it(`does not call onEndOfFile`, () => expect(onEndOfFile).not.toHaveBeenCalled())
      })

      describe(`when the indentation is the first under on the stack`, () => {
        beforeEach(() => {
          indenter.stack = [0, 4, 6, 26, 31]
          get(`indenterLine`)(indenter, 3897, `Test Line Text`)
        })
        it(`removes the last item on the stack`, () => expect(indenter.stack).toEqual([0, 4, 6, 26]))
        it(`sets indentationCharacter to the indentation character`, () => expect(indenter.indentationCharacter).toEqual(`Test Indentation Character A`))
        it(`does not change context`, () => expect(indenter.context).toEqual(`Test Context`))
        it(`does not change onLine`, () => expect(indenter.onLine).toBe(onLine))
        it(`does not change onIndent`, () => expect(indenter.onIndent).toBe(onIndent))
        it(`does not change onOutdent`, () => expect(indenter.onOutdent).toBe(onOutdent))
        it(`does not change onError`, () => expect(indenter.onError).toBe(onError))
        it(`extracts indentation once`, () => expect(indenterExtractIndentation).toHaveBeenCalledTimes(1))
        it(`extracts indentation from the line text`, () => expect(indenterExtractIndentation).toHaveBeenCalledWith(`Test Line Text`))
        it(`extracts text once`, () => expect(indenterExtractText).toHaveBeenCalledTimes(1))
        it(`extracts text from the line text`, () => expect(indenterExtractText).toHaveBeenCalledWith(`Test Line Text`))
        it(`matches statements once`, () => expect(indenterMatch).toHaveBeenCalledTimes(1))
        it(`matches against the extracted text`, () => expect(indenterMatch).toHaveBeenCalledWith(`Test Extracted Text`))
        it(`checks white space once`, () => expect(indenterCheckWhiteSpace).toHaveBeenCalledTimes(1))
        it(`checks white space in the extracted indentation`, () => expect(indenterCheckWhiteSpace).toHaveBeenCalledWith(`Test Extracted Indentation`))
        it(`calls onLine once`, () => expect(onLine).toHaveBeenCalledTimes(1))
        it(`calls onLine with the context`, () => expect(onLine).toHaveBeenCalledWith(`Test Context`, jasmine.anything(), jasmine.anything(), jasmine.anything()))
        it(`calls onLine with the line number`, () => expect(onLine).toHaveBeenCalledWith(jasmine.anything(), 3897, jasmine.anything(), jasmine.anything()))
        it(`calls onLine with the extracted text`, () => expect(onLine).toHaveBeenCalledWith(jasmine.anything(), jasmine.anything(), `Test Extracted Text`, jasmine.anything()))
        it(`calls onLine with the matched statement`, () => expect(onLine).toHaveBeenCalledWith(jasmine.anything(), jasmine.anything(), jasmine.anything(), `Test Matched Statement`))
        it(`does not call onIndent`, () => expect(onIndent).not.toHaveBeenCalled())
        it(`calls onOutdent once`, () => expect(onOutdent).toHaveBeenCalledTimes(1))
        it(`calls onOutdent with the context`, () => expect(onOutdent).toHaveBeenCalledWith(`Test Context`, jasmine.anything()))
        it(`calls onOutdent with the line number`, () => expect(onOutdent).toHaveBeenCalledWith(jasmine.anything(), 3897))
        it(`calls onOutdent before onLine`, () => expect(numberOfOnOutdentCallsAtTimeOfCallingOnLine).toEqual(1))
        it(`does not call onError`, () => expect(onError).not.toHaveBeenCalled())
        it(`does not call onEndOfFile`, () => expect(onEndOfFile).not.toHaveBeenCalled())
      })

      describe(`when the indentation is between the first and second under on the stack`, () => {
        beforeEach(() => {
          indenter.stack = [0, 4, 6, 29, 31]
          get(`indenterLine`)(indenter, 3897, `Test Line Text`)
        })
        it(`does not change stack`, () => expect(indenter.stack).toEqual([0, 4, 6, 29, 31]))
        it(`does not change indentationCharacter`, () => expect(indenter.indentationCharacter).toEqual(`Test Indentation Character A`))
        it(`does not change context`, () => expect(indenter.context).toEqual(`Test Context`))
        it(`does not change onLine`, () => expect(indenter.onLine).toBe(onLine))
        it(`does not change onIndent`, () => expect(indenter.onIndent).toBe(onIndent))
        it(`does not change onOutdent`, () => expect(indenter.onOutdent).toBe(onOutdent))
        it(`does not change onError`, () => expect(indenter.onError).toBe(onError))
        it(`extracts indentation once`, () => expect(indenterExtractIndentation).toHaveBeenCalledTimes(1))
        it(`extracts indentation from the line text`, () => expect(indenterExtractIndentation).toHaveBeenCalledWith(`Test Line Text`))
        it(`does not extract text`, () => expect(indenterExtractText).not.toHaveBeenCalled())
        it(`does not match statements`, () => expect(indenterMatch).not.toHaveBeenCalled())
        it(`checks white space once`, () => expect(indenterCheckWhiteSpace).toHaveBeenCalledTimes(1))
        it(`checks white space in the extracted indentation`, () => expect(indenterCheckWhiteSpace).toHaveBeenCalledWith(`Test Extracted Indentation`))
        it(`does not call onLine`, () => expect(onLine).not.toHaveBeenCalled())
        it(`does not call onIndent`, () => expect(onIndent).not.toHaveBeenCalled())
        it(`does not call onOutdent`, () => expect(onOutdent).not.toHaveBeenCalled())
        it(`calls onError once`, () => expect(onError).toHaveBeenCalledTimes(1))
        it(`calls onError with the context`, () => expect(onError).toHaveBeenCalledWith(`Test Context`, jasmine.anything(), jasmine.anything()))
        it(`calls onError with the line number`, () => expect(onError).toHaveBeenCalledWith(jasmine.anything(), 3897, jasmine.anything()))
        it(`calls onError with a message informing the user that they cannot outdent to a level they have not previously indented to`, () => expect(onError).toHaveBeenCalledWith(jasmine.anything(), jasmine.anything(), `Outdent to level not previously indented to`))
        it(`does not call onEndOfFile`, () => expect(onEndOfFile).not.toHaveBeenCalled())
      })

      describe(`when the indentation is the second under on the stack`, () => {
        beforeEach(() => {
          indenter.stack = [0, 4, 26, 29, 31]
          get(`indenterLine`)(indenter, 3897, `Test Line Text`)
        })
        it(`removes the subsequent items on the stack`, () => expect(indenter.stack).toEqual([0, 4, 26]))
        it(`sets indentationCharacter to the indentation character`, () => expect(indenter.indentationCharacter).toEqual(`Test Indentation Character A`))
        it(`does not change context`, () => expect(indenter.context).toEqual(`Test Context`))
        it(`does not change onLine`, () => expect(indenter.onLine).toBe(onLine))
        it(`does not change onIndent`, () => expect(indenter.onIndent).toBe(onIndent))
        it(`does not change onOutdent`, () => expect(indenter.onOutdent).toBe(onOutdent))
        it(`does not change onError`, () => expect(indenter.onError).toBe(onError))
        it(`extracts indentation once`, () => expect(indenterExtractIndentation).toHaveBeenCalledTimes(1))
        it(`extracts indentation from the line text`, () => expect(indenterExtractIndentation).toHaveBeenCalledWith(`Test Line Text`))
        it(`extracts text once`, () => expect(indenterExtractText).toHaveBeenCalledTimes(1))
        it(`extracts text from the line text`, () => expect(indenterExtractText).toHaveBeenCalledWith(`Test Line Text`))
        it(`matches statements once`, () => expect(indenterMatch).toHaveBeenCalledTimes(1))
        it(`matches against the extracted text`, () => expect(indenterMatch).toHaveBeenCalledWith(`Test Extracted Text`))
        it(`checks white space once`, () => expect(indenterCheckWhiteSpace).toHaveBeenCalledTimes(1))
        it(`checks white space in the extracted indentation`, () => expect(indenterCheckWhiteSpace).toHaveBeenCalledWith(`Test Extracted Indentation`))
        it(`calls onLine once`, () => expect(onLine).toHaveBeenCalledTimes(1))
        it(`calls onLine with the context`, () => expect(onLine).toHaveBeenCalledWith(`Test Context`, jasmine.anything(), jasmine.anything(), jasmine.anything()))
        it(`calls onLine with the line number`, () => expect(onLine).toHaveBeenCalledWith(jasmine.anything(), 3897, jasmine.anything(), jasmine.anything()))
        it(`calls onLine with the extracted text`, () => expect(onLine).toHaveBeenCalledWith(jasmine.anything(), jasmine.anything(), `Test Extracted Text`, jasmine.anything()))
        it(`calls onLine with the matched statement`, () => expect(onLine).toHaveBeenCalledWith(jasmine.anything(), jasmine.anything(), jasmine.anything(), `Test Matched Statement`))
        it(`does not call onIndent`, () => expect(onIndent).not.toHaveBeenCalled())
        it(`calls onOutdent twice`, () => expect(onOutdent).toHaveBeenCalledTimes(2))
        it(`calls onOutdent with the context`, () => expect(onOutdent).toHaveBeenCalledWith(`Test Context`, jasmine.anything()))
        it(`calls onOutdent with the line number`, () => expect(onOutdent).toHaveBeenCalledWith(jasmine.anything(), 3897))
        it(`calls onOutdent before onLine`, () => expect(numberOfOnOutdentCallsAtTimeOfCallingOnLine).toEqual(2))
        it(`does not call onError`, () => expect(onError).not.toHaveBeenCalled())
        it(`does not call onEndOfFile`, () => expect(onEndOfFile).not.toHaveBeenCalled())
      })
    })
  })
})

describe(`indenterMatch`, () => {
  const run = (input, output) => describe(`given ${JSON.stringify(input)}`, () => it(`returns the expected "${JSON.stringify(output)}"`, () => expect(get(`indenterMatch`)(input)).toEqual(output)))
  describe(`free text`, () => {
    run(`:`, null)
    run(`a`, null)
    run(`An example of a sentence which does not match anything.`, null)
  })
  describe(`line`, () => {
    run(`a:`, { line: { characters: [`a`] } })
    run(`a    \t   \t :`, { line: { characters: [`a`] } })
    run(`aBC:`, { line: { characters: [`aBC`] } })
    run(`aBC    \t   \t :`, { line: { characters: [`aBC`] } })
    run(`a  \t  \t \t  AnD \t \t\t \t \tb:`, { line: { characters: [`a`, `b`] } })
    run(`a  \t  \t \t  AnD \t \t\t \t \tb    \t   \t :`, { line: { characters: [`a`, `b`] } })
    run(`aBC  \t  \t \t  AnD \t \t\t \t \td:`, { line: { characters: [`aBC`, `d`] } })
    run(`aBC  \t  \t \t  AnD \t \t\t \t \td    \t   \t :`, { line: { characters: [`aBC`, `d`] } })
    run(`a  \t  \t \t  AnD \t \t\t \t \tBCd:`, { line: { characters: [`a`, `BCd`] } })
    run(`a  \t  \t \t  AnD \t \t\t \t \tBCd    \t   \t :`, { line: { characters: [`a`, `BCd`] } })
    run(`a   \t \t \t  b  \t  \t \t  AnD \t \t\t \t \tc:`, { line: { characters: [`a`, `b`, `c`] } })
    run(`a   \t \t \t  b  \t  \t \t  AnD \t \t\t \t \tc    \t   \t :`, { line: { characters: [`a`, `b`, `c`] } })
    run(`aBC   \t \t \t  d  \t  \t \t  AnD \t \t\t \t \te:`, { line: { characters: [`aBC`, `d`, `e`] } })
    run(`aBC   \t \t \t  d  \t  \t \t  AnD \t \t\t \t \te    \t   \t :`, { line: { characters: [`aBC`, `d`, `e`] } })
    run(`a   \t \t \t  BCd  \t  \t \t  AnD \t \t\t \t \te:`, { line: { characters: [`a`, `BCd`, `e`] } })
    run(`a   \t \t \t  BCd  \t  \t \t  AnD \t \t\t \t \te    \t   \t :`, { line: { characters: [`a`, `BCd`, `e`] } })
    run(`a   \t \t \t  b  \t  \t \t  AnD \t \t\t \t \tcDE:`, { line: { characters: [`a`, `b`, `cDE`] } })
    run(`a   \t \t \t  b  \t  \t \t  AnD \t \t\t \t \tcDE    \t   \t :`, { line: { characters: [`a`, `b`, `cDE`] } })
    run(`a \t \t \t   \t\t b \t \tc    \t AnD \t\t d:`, { line: { characters: [`a`, `b`, `c`, `d`] } })
    run(`a \t \t \t   \t\t b \t \tc    \t AnD \t\t d \t \t\t \t :`, { line: { characters: [`a`, `b`, `c`, `d`] } })
    run(`aBC \t \t \t   \t\t d \t \te    \t AnD \t\t f:`, { line: { characters: [`aBC`, `d`, `e`, `f`] } })
    run(`aBC \t \t \t   \t\t d \t \te    \t AnD \t\t f \t \t\t \t :`, { line: { characters: [`aBC`, `d`, `e`, `f`] } })
    run(`a \t \t \t   \t\t BCd \t \te    \t AnD \t\t f:`, { line: { characters: [`a`, `BCd`, `e`, `f`] } })
    run(`a \t \t \t   \t\t BCd \t \te    \t AnD \t\t f \t \t\t \t :`, { line: { characters: [`a`, `BCd`, `e`, `f`] } })
    run(`a \t \t \t   \t\t b \t \tcDE    \t AnD \t\t f:`, { line: { characters: [`a`, `b`, `cDE`, `f`] } })
    run(`a \t \t \t   \t\t b \t \tcDE    \t AnD \t\t f \t \t\t \t :`, { line: { characters: [`a`, `b`, `cDE`, `f`] } })
    run(`a \t \t \t   \t\t b \t \tc    \t AnD \t\t dEf:`, { line: { characters: [`a`, `b`, `c`, `dEf`] } })
    run(`a \t \t \t   \t\t b \t \tc    \t AnD \t\t dEf \t \t\t \t :`, { line: { characters: [`a`, `b`, `c`, `dEf`] } })
  })
  describe(`line with emote`, () => {
    run(`a(b):`, { lineWithEmote: { characters: [`a`], emote: `b` } })
    run(`a \t \t\t (b):`, { lineWithEmote: { characters: [`a`], emote: `b` } })
    run(`a( \t \t\t b):`, { lineWithEmote: { characters: [`a`], emote: `b` } })
    run(`a(b   \t\t \t ):`, { lineWithEmote: { characters: [`a`], emote: `b` } })
    run(`a(b)   \t\t \t    \t   \t :`, { lineWithEmote: { characters: [`a`], emote: `b` } })
    run(`aBC(d):`, { lineWithEmote: { characters: [`aBC`], emote: `d` } })
    run(`aBC \t \t\t (d):`, { lineWithEmote: { characters: [`aBC`], emote: `d` } })
    run(`aBC( \t \t\t d):`, { lineWithEmote: { characters: [`aBC`], emote: `d` } })
    run(`aBC(d   \t\t \t ):`, { lineWithEmote: { characters: [`aBC`], emote: `d` } })
    run(`aBC(d)   \t\t \t    \t   \t :`, { lineWithEmote: { characters: [`aBC`], emote: `d` } })
    run(`a(BCd):`, { lineWithEmote: { characters: [`a`], emote: `BCd` } })
    run(`a \t \t\t (BCd):`, { lineWithEmote: { characters: [`a`], emote: `BCd` } })
    run(`a( \t \t\t BCd):`, { lineWithEmote: { characters: [`a`], emote: `BCd` } })
    run(`a(BCd   \t\t \t ):`, { lineWithEmote: { characters: [`a`], emote: `BCd` } })
    run(`a(BCd)   \t\t \t    \t   \t :`, { lineWithEmote: { characters: [`a`], emote: `BCd` } })
    run(`a  \t  \t \t  AnD \t \t\t \t \tb(c):`, { lineWithEmote: { characters: [`a`, `b`], emote: `c` } })
    run(`a  \t  \t \t  AnD \t \t\t \t \tb \t \t\t (c):`, { lineWithEmote: { characters: [`a`, `b`], emote: `c` } })
    run(`a  \t  \t \t  AnD \t \t\t \t \tb( \t \t\t c):`, { lineWithEmote: { characters: [`a`, `b`], emote: `c` } })
    run(`a  \t  \t \t  AnD \t \t\t \t \tb(c   \t\t \t ):`, { lineWithEmote: { characters: [`a`, `b`], emote: `c` } })
    run(`a  \t  \t \t  AnD \t \t\t \t \tb(c)   \t\t \t    \t   \t :`, { lineWithEmote: { characters: [`a`, `b`], emote: `c` } })
    run(`aBC  \t  \t \t  AnD \t \t\t \t \td(e):`, { lineWithEmote: { characters: [`aBC`, `d`], emote: `e` } })
    run(`aBC  \t  \t \t  AnD \t \t\t \t \td \t \t\t (e):`, { lineWithEmote: { characters: [`aBC`, `d`], emote: `e` } })
    run(`aBC  \t  \t \t  AnD \t \t\t \t \td( \t \t\t e):`, { lineWithEmote: { characters: [`aBC`, `d`], emote: `e` } })
    run(`aBC  \t  \t \t  AnD \t \t\t \t \td(e   \t\t \t ):`, { lineWithEmote: { characters: [`aBC`, `d`], emote: `e` } })
    run(`aBC  \t  \t \t  AnD \t \t\t \t \td(e)   \t\t \t    \t   \t :`, { lineWithEmote: { characters: [`aBC`, `d`], emote: `e` } })
    run(`a  \t  \t \t  AnD \t \t\t \t \tBCd(e):`, { lineWithEmote: { characters: [`a`, `BCd`], emote: `e` } })
    run(`a  \t  \t \t  AnD \t \t\t \t \tBCd \t \t\t (e):`, { lineWithEmote: { characters: [`a`, `BCd`], emote: `e` } })
    run(`a  \t  \t \t  AnD \t \t\t \t \tBCd( \t \t\t e):`, { lineWithEmote: { characters: [`a`, `BCd`], emote: `e` } })
    run(`a  \t  \t \t  AnD \t \t\t \t \tBCd(e   \t\t \t ):`, { lineWithEmote: { characters: [`a`, `BCd`], emote: `e` } })
    run(`a  \t  \t \t  AnD \t \t\t \t \tBCd(e)   \t\t \t    \t   \t :`, { lineWithEmote: { characters: [`a`, `BCd`], emote: `e` } })
    run(`a  \t  \t \t  AnD \t \t\t \t \tb(cDE):`, { lineWithEmote: { characters: [`a`, `b`], emote: `cDE` } })
    run(`a  \t  \t \t  AnD \t \t\t \t \tb \t \t\t (cDE):`, { lineWithEmote: { characters: [`a`, `b`], emote: `cDE` } })
    run(`a  \t  \t \t  AnD \t \t\t \t \tb( \t \t\t cDE):`, { lineWithEmote: { characters: [`a`, `b`], emote: `cDE` } })
    run(`a  \t  \t \t  AnD \t \t\t \t \tb(cDE   \t\t \t ):`, { lineWithEmote: { characters: [`a`, `b`], emote: `cDE` } })
    run(`a  \t  \t \t  AnD \t \t\t \t \tb(cDE)   \t\t \t    \t   \t :`, { lineWithEmote: { characters: [`a`, `b`], emote: `cDE` } })
    run(`a   \t \t \t  b  \t  \t \t  AnD \t \t\t \t \tc(d):`, { lineWithEmote: { characters: [`a`, `b`, `c`], emote: `d` } })
    run(`a   \t \t \t  b  \t  \t \t  AnD \t \t\t \t \tc \t \t\t (d):`, { lineWithEmote: { characters: [`a`, `b`, `c`], emote: `d` } })
    run(`a   \t \t \t  b  \t  \t \t  AnD \t \t\t \t \tc( \t \t\t d):`, { lineWithEmote: { characters: [`a`, `b`, `c`], emote: `d` } })
    run(`a   \t \t \t  b  \t  \t \t  AnD \t \t\t \t \tc(d   \t\t \t ):`, { lineWithEmote: { characters: [`a`, `b`, `c`], emote: `d` } })
    run(`a   \t \t \t  b  \t  \t \t  AnD \t \t\t \t \tc(d)   \t\t \t    \t   \t :`, { lineWithEmote: { characters: [`a`, `b`, `c`], emote: `d` } })
    run(`aBC   \t \t \t  d  \t  \t \t  AnD \t \t\t \t \te(f):`, { lineWithEmote: { characters: [`aBC`, `d`, `e`], emote: `f` } })
    run(`aBC   \t \t \t  d  \t  \t \t  AnD \t \t\t \t \te \t \t\t (f):`, { lineWithEmote: { characters: [`aBC`, `d`, `e`], emote: `f` } })
    run(`aBC   \t \t \t  d  \t  \t \t  AnD \t \t\t \t \te( \t \t\t f):`, { lineWithEmote: { characters: [`aBC`, `d`, `e`], emote: `f` } })
    run(`aBC   \t \t \t  d  \t  \t \t  AnD \t \t\t \t \te(f   \t\t \t ):`, { lineWithEmote: { characters: [`aBC`, `d`, `e`], emote: `f` } })
    run(`aBC   \t \t \t  d  \t  \t \t  AnD \t \t\t \t \te(f)   \t\t \t    \t   \t :`, { lineWithEmote: { characters: [`aBC`, `d`, `e`], emote: `f` } })
    run(`a   \t \t \t  BCd  \t  \t \t  AnD \t \t\t \t \te(f):`, { lineWithEmote: { characters: [`a`, `BCd`, `e`], emote: `f` } })
    run(`a   \t \t \t  BCd  \t  \t \t  AnD \t \t\t \t \te \t \t\t (f):`, { lineWithEmote: { characters: [`a`, `BCd`, `e`], emote: `f` } })
    run(`a   \t \t \t  BCd  \t  \t \t  AnD \t \t\t \t \te( \t \t\t f):`, { lineWithEmote: { characters: [`a`, `BCd`, `e`], emote: `f` } })
    run(`a   \t \t \t  BCd  \t  \t \t  AnD \t \t\t \t \te(f   \t\t \t ):`, { lineWithEmote: { characters: [`a`, `BCd`, `e`], emote: `f` } })
    run(`a   \t \t \t  BCd  \t  \t \t  AnD \t \t\t \t \te(f)   \t\t \t    \t   \t :`, { lineWithEmote: { characters: [`a`, `BCd`, `e`], emote: `f` } })
    run(`a   \t \t \t  b  \t  \t \t  AnD \t \t\t \t \tcDE(f):`, { lineWithEmote: { characters: [`a`, `b`, `cDE`], emote: `f` } })
    run(`a   \t \t \t  b  \t  \t \t  AnD \t \t\t \t \tcDE \t \t\t (f):`, { lineWithEmote: { characters: [`a`, `b`, `cDE`], emote: `f` } })
    run(`a   \t \t \t  b  \t  \t \t  AnD \t \t\t \t \tcDE( \t \t\t f):`, { lineWithEmote: { characters: [`a`, `b`, `cDE`], emote: `f` } })
    run(`a   \t \t \t  b  \t  \t \t  AnD \t \t\t \t \tcDE(f   \t\t \t ):`, { lineWithEmote: { characters: [`a`, `b`, `cDE`], emote: `f` } })
    run(`a   \t \t \t  b  \t  \t \t  AnD \t \t\t \t \tcDE(f)   \t\t \t    \t   \t :`, { lineWithEmote: { characters: [`a`, `b`, `cDE`], emote: `f` } })
    run(`a   \t \t \t  b  \t  \t \t  AnD \t \t\t \t \tc(dEf):`, { lineWithEmote: { characters: [`a`, `b`, `c`], emote: `dEf` } })
    run(`a   \t \t \t  b  \t  \t \t  AnD \t \t\t \t \tc \t \t\t (dEf):`, { lineWithEmote: { characters: [`a`, `b`, `c`], emote: `dEf` } })
    run(`a   \t \t \t  b  \t  \t \t  AnD \t \t\t \t \tc( \t \t\t dEf):`, { lineWithEmote: { characters: [`a`, `b`, `c`], emote: `dEf` } })
    run(`a   \t \t \t  b  \t  \t \t  AnD \t \t\t \t \tc(dEf   \t\t \t ):`, { lineWithEmote: { characters: [`a`, `b`, `c`], emote: `dEf` } })
    run(`a   \t \t \t  b  \t  \t \t  AnD \t \t\t \t \tc(dEf)   \t\t \t    \t   \t :`, { lineWithEmote: { characters: [`a`, `b`, `c`], emote: `dEf` } })
    run(`a  \t  \t \t  b \t c\t\t AnD \t  \td(e):`, { lineWithEmote: { characters: [`a`, `b`, `c`, `d`], emote: `e` } })
    run(`a  \t  \t \t  b \t c\t\t AnD \t  \td   \t\t \t(e):`, { lineWithEmote: { characters: [`a`, `b`, `c`, `d`], emote: `e` } })
    run(`a  \t  \t \t  b \t c\t\t AnD \t  \td(  \t\t \t e):`, { lineWithEmote: { characters: [`a`, `b`, `c`, `d`], emote: `e` } })
    run(`a  \t  \t \t  b \t c\t\t AnD \t  \td(e \t\t     ):`, { lineWithEmote: { characters: [`a`, `b`, `c`, `d`], emote: `e` } })
    run(`a  \t  \t \t  b \t c\t\t AnD \t  \td(e)  \t \t   :`, { lineWithEmote: { characters: [`a`, `b`, `c`, `d`], emote: `e` } })
    run(`aBC  \t  \t \t  d \t e\t\t AnD \t  \tf(g):`, { lineWithEmote: { characters: [`aBC`, `d`, `e`, `f`], emote: `g` } })
    run(`aBC  \t  \t \t  d \t e\t\t AnD \t  \tf   \t\t \t(g):`, { lineWithEmote: { characters: [`aBC`, `d`, `e`, `f`], emote: `g` } })
    run(`aBC  \t  \t \t  d \t e\t\t AnD \t  \tf(  \t\t \t g):`, { lineWithEmote: { characters: [`aBC`, `d`, `e`, `f`], emote: `g` } })
    run(`aBC  \t  \t \t  d \t e\t\t AnD \t  \tf(g \t\t     ):`, { lineWithEmote: { characters: [`aBC`, `d`, `e`, `f`], emote: `g` } })
    run(`aBC  \t  \t \t  d \t e\t\t AnD \t  \tf(g)  \t \t   :`, { lineWithEmote: { characters: [`aBC`, `d`, `e`, `f`], emote: `g` } })
    run(`a  \t  \t \t  BCd \t e\t\t AnD \t  \tf(g):`, { lineWithEmote: { characters: [`a`, `BCd`, `e`, `f`], emote: `g` } })
    run(`a  \t  \t \t  BCd \t e\t\t AnD \t  \tf   \t\t \t(g):`, { lineWithEmote: { characters: [`a`, `BCd`, `e`, `f`], emote: `g` } })
    run(`a  \t  \t \t  BCd \t e\t\t AnD \t  \tf(  \t\t \t g):`, { lineWithEmote: { characters: [`a`, `BCd`, `e`, `f`], emote: `g` } })
    run(`a  \t  \t \t  BCd \t e\t\t AnD \t  \tf(g \t\t     ):`, { lineWithEmote: { characters: [`a`, `BCd`, `e`, `f`], emote: `g` } })
    run(`a  \t  \t \t  BCd \t e\t\t AnD \t  \tf(g)  \t \t   :`, { lineWithEmote: { characters: [`a`, `BCd`, `e`, `f`], emote: `g` } })
    run(`a  \t  \t \t  b \t cDE\t\t AnD \t  \tf(g):`, { lineWithEmote: { characters: [`a`, `b`, `cDE`, `f`], emote: `g` } })
    run(`a  \t  \t \t  b \t cDE\t\t AnD \t  \tf   \t\t \t(g):`, { lineWithEmote: { characters: [`a`, `b`, `cDE`, `f`], emote: `g` } })
    run(`a  \t  \t \t  b \t cDE\t\t AnD \t  \tf(  \t\t \t g):`, { lineWithEmote: { characters: [`a`, `b`, `cDE`, `f`], emote: `g` } })
    run(`a  \t  \t \t  b \t cDE\t\t AnD \t  \tf(g \t\t     ):`, { lineWithEmote: { characters: [`a`, `b`, `cDE`, `f`], emote: `g` } })
    run(`a  \t  \t \t  b \t cDE\t\t AnD \t  \tf(g)  \t \t   :`, { lineWithEmote: { characters: [`a`, `b`, `cDE`, `f`], emote: `g` } })
    run(`a  \t  \t \t  b \t c\t\t AnD \t  \tdEf(g):`, { lineWithEmote: { characters: [`a`, `b`, `c`, `dEf`], emote: `g` } })
    run(`a  \t  \t \t  b \t c\t\t AnD \t  \tdEf   \t\t \t(g):`, { lineWithEmote: { characters: [`a`, `b`, `c`, `dEf`], emote: `g` } })
    run(`a  \t  \t \t  b \t c\t\t AnD \t  \tdEf(  \t\t \t g):`, { lineWithEmote: { characters: [`a`, `b`, `c`, `dEf`], emote: `g` } })
    run(`a  \t  \t \t  b \t c\t\t AnD \t  \tdEf(g \t\t     ):`, { lineWithEmote: { characters: [`a`, `b`, `c`, `dEf`], emote: `g` } })
    run(`a  \t  \t \t  b \t c\t\t AnD \t  \tdEf(g)  \t \t   :`, { lineWithEmote: { characters: [`a`, `b`, `c`, `dEf`], emote: `g` } })
    run(`a  \t  \t \t  b \t c\t\t AnD \t  \td(eFG):`, { lineWithEmote: { characters: [`a`, `b`, `c`, `d`], emote: `eFG` } })
    run(`a  \t  \t \t  b \t c\t\t AnD \t  \td   \t\t \t(eFG):`, { lineWithEmote: { characters: [`a`, `b`, `c`, `d`], emote: `eFG` } })
    run(`a  \t  \t \t  b \t c\t\t AnD \t  \td(  \t\t \t eFG):`, { lineWithEmote: { characters: [`a`, `b`, `c`, `d`], emote: `eFG` } })
    run(`a  \t  \t \t  b \t c\t\t AnD \t  \td(eFG \t\t     ):`, { lineWithEmote: { characters: [`a`, `b`, `c`, `d`], emote: `eFG` } })
    run(`a  \t  \t \t  b \t c\t\t AnD \t  \td(eFG)  \t \t   :`, { lineWithEmote: { characters: [`a`, `b`, `c`, `d`], emote: `eFG` } })
  })
  describe(`line with text`, () => {
    run(`a:b`, { lineWithText: { characters: [`a`], text: `b` } })
    run(`a  \t \t :b`, { lineWithText: { characters: [`a`], text: `b` } })
    run(`a:\t\t  \t b`, { lineWithText: { characters: [`a`], text: `b` } })
    run(`aBC:d`, { lineWithText: { characters: [`aBC`], text: `d` } })
    run(`aBC  \t \t :d`, { lineWithText: { characters: [`aBC`], text: `d` } })
    run(`aBC:\t\t  \t d`, { lineWithText: { characters: [`aBC`], text: `d` } })
    run(`a:BCd \t \t \t\t eFGh \t : \t \t\t ijKL`, { lineWithText: { characters: [`a`], text: `BCd \t \t \t\t eFGh \t : \t \t\t ijKL` } })
    run(`a  \t \t :BCd \t \t \t\t eFGh \t : \t \t\t ijKL`, { lineWithText: { characters: [`a`], text: `BCd \t \t \t\t eFGh \t : \t \t\t ijKL` } })
    run(`a:\t\t  \t BCd \t \t \t\t eFGh \t : \t \t\t ijKL`, { lineWithText: { characters: [`a`], text: `BCd \t \t \t\t eFGh \t : \t \t\t ijKL` } })
    run(`a \t\t  \t AnD \t \t  b:c`, { lineWithText: { characters: [`a`, `b`], text: `c` } })
    run(`a \t\t  \t AnD \t \t  b\t   \t\t:c`, { lineWithText: { characters: [`a`, `b`], text: `c` } })
    run(`a \t\t  \t AnD \t \t  b: \t\t  \t c`, { lineWithText: { characters: [`a`, `b`], text: `c` } })
    run(`aBC \t\t  \t AnD \t \t  d:e`, { lineWithText: { characters: [`aBC`, `d`], text: `e` } })
    run(`aBC \t\t  \t AnD \t \t  d\t   \t\t:e`, { lineWithText: { characters: [`aBC`, `d`], text: `e` } })
    run(`aBC \t\t  \t AnD \t \t  d: \t\t  \t e`, { lineWithText: { characters: [`aBC`, `d`], text: `e` } })
    run(`a \t\t  \t AnD \t \t  BCd:e`, { lineWithText: { characters: [`a`, `BCd`], text: `e` } })
    run(`a \t\t  \t AnD \t \t  BCd\t   \t\t:e`, { lineWithText: { characters: [`a`, `BCd`], text: `e` } })
    run(`a \t\t  \t AnD \t \t  BCd: \t\t  \t e`, { lineWithText: { characters: [`a`, `BCd`], text: `e` } })
    run(`a \t\t  \t AnD \t \t  b:cDE \t \t \t\t FGhi \t : \t \t\t jkl`, { lineWithText: { characters: [`a`, `b`], text: `cDE \t \t \t\t FGhi \t : \t \t\t jkl` } })
    run(`a \t\t  \t AnD \t \t  b\t   \t\t:cDE \t \t \t\t FGhi \t : \t \t\t jkl`, { lineWithText: { characters: [`a`, `b`], text: `cDE \t \t \t\t FGhi \t : \t \t\t jkl` } })
    run(`a \t\t  \t AnD \t \t  b: \t\t  \t cDE \t \t \t\t FGhi \t : \t \t\t jkl`, { lineWithText: { characters: [`a`, `b`], text: `cDE \t \t \t\t FGhi \t : \t \t\t jkl` } })
    run(`a \t\t  \t b   \t\t AnD  \t \t \t c:d`, { lineWithText: { characters: [`a`, `b`, `c`], text: `d` } })
    run(`a \t\t  \t b   \t\t AnD  \t \t \t c  \t \t :d`, { lineWithText: { characters: [`a`, `b`, `c`], text: `d` } })
    run(`a \t\t  \t b   \t\t AnD  \t \t \t c:  \t \t d`, { lineWithText: { characters: [`a`, `b`, `c`], text: `d` } })
    run(`aBC \t\t  \t d   \t\t AnD  \t \t \t e:f`, { lineWithText: { characters: [`aBC`, `d`, `e`], text: `f` } })
    run(`aBC \t\t  \t d   \t\t AnD  \t \t \t e  \t \t :f`, { lineWithText: { characters: [`aBC`, `d`, `e`], text: `f` } })
    run(`aBC \t\t  \t d   \t\t AnD  \t \t \t e:  \t \t f`, { lineWithText: { characters: [`aBC`, `d`, `e`], text: `f` } })
    run(`a \t\t  \t BCd   \t\t AnD  \t \t \t e:f`, { lineWithText: { characters: [`a`, `BCd`, `e`], text: `f` } })
    run(`a \t\t  \t BCd   \t\t AnD  \t \t \t e  \t \t :f`, { lineWithText: { characters: [`a`, `BCd`, `e`], text: `f` } })
    run(`a \t\t  \t BCd   \t\t AnD  \t \t \t e:  \t \t f`, { lineWithText: { characters: [`a`, `BCd`, `e`], text: `f` } })
    run(`a \t\t  \t b   \t\t AnD  \t \t \t cDE:f`, { lineWithText: { characters: [`a`, `b`, `cDE`], text: `f` } })
    run(`a \t\t  \t b   \t\t AnD  \t \t \t cDE  \t \t :f`, { lineWithText: { characters: [`a`, `b`, `cDE`], text: `f` } })
    run(`a \t\t  \t b   \t\t AnD  \t \t \t cDE:  \t \t f`, { lineWithText: { characters: [`a`, `b`, `cDE`], text: `f` } })
    run(`a \t\t  \t b   \t\t AnD  \t \t \t c:dEf \t \t \t\t GhiJ \t : \t \t\t klm`, { lineWithText: { characters: [`a`, `b`, `c`], text: `dEf \t \t \t\t GhiJ \t : \t \t\t klm` } })
    run(`a \t\t  \t b   \t\t AnD  \t \t \t c  \t \t :dEf \t \t \t\t GhiJ \t : \t \t\t klm`, { lineWithText: { characters: [`a`, `b`, `c`], text: `dEf \t \t \t\t GhiJ \t : \t \t\t klm` } })
    run(`a \t\t  \t b   \t\t AnD  \t \t \t c:  \t \t dEf \t \t \t\t GhiJ \t : \t \t\t klm`, { lineWithText: { characters: [`a`, `b`, `c`], text: `dEf \t \t \t\t GhiJ \t : \t \t\t klm` } })
    run(`a \t \t \t   \t\t b \t \tc    \t AnD \t\t d:e`, { lineWithText: { characters: [`a`, `b`, `c`, `d`], text: `e` } })
    run(`a \t \t \t   \t\t b \t \tc    \t AnD \t\t d \t \t\t \t :e`, { lineWithText: { characters: [`a`, `b`, `c`, `d`], text: `e` } })
    run(`a \t \t \t   \t\t b \t \tc    \t AnD \t\t d: \t \t\t \t e`, { lineWithText: { characters: [`a`, `b`, `c`, `d`], text: `e` } })
    run(`aBC \t \t \t   \t\t d \t \te    \t AnD \t\t f:g`, { lineWithText: { characters: [`aBC`, `d`, `e`, `f`], text: `g` } })
    run(`aBC \t \t \t   \t\t d \t \te    \t AnD \t\t f \t \t\t \t :g`, { lineWithText: { characters: [`aBC`, `d`, `e`, `f`], text: `g` } })
    run(`aBC \t \t \t   \t\t d \t \te    \t AnD \t\t f: \t \t\t \t g`, { lineWithText: { characters: [`aBC`, `d`, `e`, `f`], text: `g` } })
    run(`a \t \t \t   \t\t BCd \t \te    \t AnD \t\t f:g`, { lineWithText: { characters: [`a`, `BCd`, `e`, `f`], text: `g` } })
    run(`a \t \t \t   \t\t BCd \t \te    \t AnD \t\t f \t \t\t \t :g`, { lineWithText: { characters: [`a`, `BCd`, `e`, `f`], text: `g` } })
    run(`a \t \t \t   \t\t BCd \t \te    \t AnD \t\t f: \t \t\t \t g`, { lineWithText: { characters: [`a`, `BCd`, `e`, `f`], text: `g` } })
    run(`a \t \t \t   \t\t b \t \tcDE    \t AnD \t\t f:g`, { lineWithText: { characters: [`a`, `b`, `cDE`, `f`], text: `g` } })
    run(`a \t \t \t   \t\t b \t \tcDE    \t AnD \t\t f \t \t\t \t :g`, { lineWithText: { characters: [`a`, `b`, `cDE`, `f`], text: `g` } })
    run(`a \t \t \t   \t\t b \t \tcDE    \t AnD \t\t f: \t \t\t \t g`, { lineWithText: { characters: [`a`, `b`, `cDE`, `f`], text: `g` } })
    run(`a \t \t \t   \t\t b \t \tc    \t AnD \t\t dEf:g`, { lineWithText: { characters: [`a`, `b`, `c`, `dEf`], text: `g` } })
    run(`a \t \t \t   \t\t b \t \tc    \t AnD \t\t dEf \t \t\t \t :g`, { lineWithText: { characters: [`a`, `b`, `c`, `dEf`], text: `g` } })
    run(`a \t \t \t   \t\t b \t \tc    \t AnD \t\t dEf: \t \t\t \t g`, { lineWithText: { characters: [`a`, `b`, `c`, `dEf`], text: `g` } })
    run(`a \t \t \t   \t\t b \t \tc    \t AnD \t\t d:eFG \t \t \t\t hIJk \t : \t \t\t LMN`, { lineWithText: { characters: [`a`, `b`, `c`, `d`], text: `eFG \t \t \t\t hIJk \t : \t \t\t LMN` } })
    run(`a \t \t \t   \t\t b \t \tc    \t AnD \t\t d \t \t\t \t :eFG \t \t \t\t hIJk \t : \t \t\t LMN`, { lineWithText: { characters: [`a`, `b`, `c`, `d`], text: `eFG \t \t \t\t hIJk \t : \t \t\t LMN` } })
    run(`a \t \t \t   \t\t b \t \tc    \t AnD \t\t d: \t \t\t \t eFG \t \t \t\t hIJk \t : \t \t\t LMN`, { lineWithText: { characters: [`a`, `b`, `c`, `d`], text: `eFG \t \t \t\t hIJk \t : \t \t\t LMN` } })
  })
  describe(`line with emote and text`, () => {
    run(`a(b):c`, { lineWithEmoteAndText: { characters: [`a`], emote: `b`, text: `c` } })
    run(`a \t \t\t (b):c`, { lineWithEmoteAndText: { characters: [`a`], emote: `b`, text: `c` } })
    run(`a( \t \t\t b):c`, { lineWithEmoteAndText: { characters: [`a`], emote: `b`, text: `c` } })
    run(`a(b   \t\t \t ):c`, { lineWithEmoteAndText: { characters: [`a`], emote: `b`, text: `c` } })
    run(`a(b)   \t\t \t    \t   \t :c`, { lineWithEmoteAndText: { characters: [`a`], emote: `b`, text: `c` } })
    run(`a(b):   \t\t \t    \t   \t c`, { lineWithEmoteAndText: { characters: [`a`], emote: `b`, text: `c` } })
    run(`aBC(d):e`, { lineWithEmoteAndText: { characters: [`aBC`], emote: `d`, text: `e` } })
    run(`aBC \t \t\t (d):e`, { lineWithEmoteAndText: { characters: [`aBC`], emote: `d`, text: `e` } })
    run(`aBC( \t \t\t d):e`, { lineWithEmoteAndText: { characters: [`aBC`], emote: `d`, text: `e` } })
    run(`aBC(d   \t\t \t ):e`, { lineWithEmoteAndText: { characters: [`aBC`], emote: `d`, text: `e` } })
    run(`aBC(d)   \t\t \t    \t   \t :e`, { lineWithEmoteAndText: { characters: [`aBC`], emote: `d`, text: `e` } })
    run(`aBC(d):   \t\t \t    \t   \t e`, { lineWithEmoteAndText: { characters: [`aBC`], emote: `d`, text: `e` } })
    run(`a(BCd):e`, { lineWithEmoteAndText: { characters: [`a`], emote: `BCd`, text: `e` } })
    run(`a \t \t\t (BCd):e`, { lineWithEmoteAndText: { characters: [`a`], emote: `BCd`, text: `e` } })
    run(`a( \t \t\t BCd):e`, { lineWithEmoteAndText: { characters: [`a`], emote: `BCd`, text: `e` } })
    run(`a(BCd   \t\t \t ):e`, { lineWithEmoteAndText: { characters: [`a`], emote: `BCd`, text: `e` } })
    run(`a(BCd)   \t\t \t    \t   \t :e`, { lineWithEmoteAndText: { characters: [`a`], emote: `BCd`, text: `e` } })
    run(`a(BCd):   \t\t \t    \t   \t e`, { lineWithEmoteAndText: { characters: [`a`], emote: `BCd`, text: `e` } })
    run(`a \t \t\t (b):cDE \t \t \t\t FGhi \t : \t \t\t jkl`, { lineWithEmoteAndText: { characters: [`a`], emote: `b`, text: `cDE \t \t \t\t FGhi \t : \t \t\t jkl` } })
    run(`a \t \t\t (   \t\t \t b):cDE \t \t \t\t FGhi \t : \t \t\t jkl`, { lineWithEmoteAndText: { characters: [`a`], emote: `b`, text: `cDE \t \t \t\t FGhi \t : \t \t\t jkl` } })
    run(`a \t \t\t (b   \t\t \t ):cDE \t \t \t\t FGhi \t : \t \t\t jkl`, { lineWithEmoteAndText: { characters: [`a`], emote: `b`, text: `cDE \t \t \t\t FGhi \t : \t \t\t jkl` } })
    run(`a \t \t\t (b)   \t\t \t :cDE \t \t \t\t FGhi \t : \t \t\t jkl`, { lineWithEmoteAndText: { characters: [`a`], emote: `b`, text: `cDE \t \t \t\t FGhi \t : \t \t\t jkl` } })
    run(`a \t \t\t (b):   \t\t \t cDE \t \t \t\t FGhi \t : \t \t\t jkl`, { lineWithEmoteAndText: { characters: [`a`], emote: `b`, text: `cDE \t \t \t\t FGhi \t : \t \t\t jkl` } })
    run(`a  \t  \t \t  AnD \t \t\t \t \tb(c):d`, { lineWithEmoteAndText: { characters: [`a`, `b`], emote: `c`, text: `d` } })
    run(`a  \t  \t \t  AnD \t \t\t \t \tb \t \t\t (c):d`, { lineWithEmoteAndText: { characters: [`a`, `b`], emote: `c`, text: `d` } })
    run(`a  \t  \t \t  AnD \t \t\t \t \tb( \t \t\t c):d`, { lineWithEmoteAndText: { characters: [`a`, `b`], emote: `c`, text: `d` } })
    run(`a  \t  \t \t  AnD \t \t\t \t \tb(c   \t\t \t ):d`, { lineWithEmoteAndText: { characters: [`a`, `b`], emote: `c`, text: `d` } })
    run(`a  \t  \t \t  AnD \t \t\t \t \tb(c)   \t\t \t    \t   \t :d`, { lineWithEmoteAndText: { characters: [`a`, `b`], emote: `c`, text: `d` } })
    run(`a  \t  \t \t  AnD \t \t\t \t \tb(c):   \t\t \t    \t   \t d`, { lineWithEmoteAndText: { characters: [`a`, `b`], emote: `c`, text: `d` } })
    run(`aBC  \t  \t \t  AnD \t \t\t \t \td(e):f`, { lineWithEmoteAndText: { characters: [`aBC`, `d`], emote: `e`, text: `f` } })
    run(`aBC  \t  \t \t  AnD \t \t\t \t \td \t \t\t (e):f`, { lineWithEmoteAndText: { characters: [`aBC`, `d`], emote: `e`, text: `f` } })
    run(`aBC  \t  \t \t  AnD \t \t\t \t \td( \t \t\t e):f`, { lineWithEmoteAndText: { characters: [`aBC`, `d`], emote: `e`, text: `f` } })
    run(`aBC  \t  \t \t  AnD \t \t\t \t \td(e   \t\t \t ):f`, { lineWithEmoteAndText: { characters: [`aBC`, `d`], emote: `e`, text: `f` } })
    run(`aBC  \t  \t \t  AnD \t \t\t \t \td(e)   \t\t \t    \t   \t :f`, { lineWithEmoteAndText: { characters: [`aBC`, `d`], emote: `e`, text: `f` } })
    run(`aBC  \t  \t \t  AnD \t \t\t \t \td(e):   \t\t \t    \t   \t f`, { lineWithEmoteAndText: { characters: [`aBC`, `d`], emote: `e`, text: `f` } })
    run(`a  \t  \t \t  AnD \t \t\t \t \tBCd(e):f`, { lineWithEmoteAndText: { characters: [`a`, `BCd`], emote: `e`, text: `f` } })
    run(`a  \t  \t \t  AnD \t \t\t \t \tBCd \t \t\t (e):f`, { lineWithEmoteAndText: { characters: [`a`, `BCd`], emote: `e`, text: `f` } })
    run(`a  \t  \t \t  AnD \t \t\t \t \tBCd( \t \t\t e):f`, { lineWithEmoteAndText: { characters: [`a`, `BCd`], emote: `e`, text: `f` } })
    run(`a  \t  \t \t  AnD \t \t\t \t \tBCd(e   \t\t \t ):f`, { lineWithEmoteAndText: { characters: [`a`, `BCd`], emote: `e`, text: `f` } })
    run(`a  \t  \t \t  AnD \t \t\t \t \tBCd(e)   \t\t \t    \t   \t :f`, { lineWithEmoteAndText: { characters: [`a`, `BCd`], emote: `e`, text: `f` } })
    run(`a  \t  \t \t  AnD \t \t\t \t \tBCd(e):   \t\t \t    \t   \t f`, { lineWithEmoteAndText: { characters: [`a`, `BCd`], emote: `e`, text: `f` } })
    run(`a  \t  \t \t  AnD \t \t\t \t \tb(cDE):f`, { lineWithEmoteAndText: { characters: [`a`, `b`], emote: `cDE`, text: `f` } })
    run(`a  \t  \t \t  AnD \t \t\t \t \tb \t \t\t (cDE):f`, { lineWithEmoteAndText: { characters: [`a`, `b`], emote: `cDE`, text: `f` } })
    run(`a  \t  \t \t  AnD \t \t\t \t \tb( \t \t\t cDE):f`, { lineWithEmoteAndText: { characters: [`a`, `b`], emote: `cDE`, text: `f` } })
    run(`a  \t  \t \t  AnD \t \t\t \t \tb(cDE   \t\t \t ):f`, { lineWithEmoteAndText: { characters: [`a`, `b`], emote: `cDE`, text: `f` } })
    run(`a  \t  \t \t  AnD \t \t\t \t \tb(cDE)   \t\t \t    \t   \t :f`, { lineWithEmoteAndText: { characters: [`a`, `b`], emote: `cDE`, text: `f` } })
    run(`a  \t  \t \t  AnD \t \t\t \t \tb(cDE):   \t\t \t    \t   \t f`, { lineWithEmoteAndText: { characters: [`a`, `b`], emote: `cDE`, text: `f` } })
    run(`a  \t  \t \t  AnD \t \t\t \t \tb \t \t\t (c):dEf \t \t \t\t GhiJ \t : \t \t\t klm`, { lineWithEmoteAndText: { characters: [`a`, `b`], emote: `c`, text: `dEf \t \t \t\t GhiJ \t : \t \t\t klm` } })
    run(`a  \t  \t \t  AnD \t \t\t \t \tb \t \t\t (   \t\t \t    \t   \t c):dEf \t \t \t\t GhiJ \t : \t \t\t klm`, { lineWithEmoteAndText: { characters: [`a`, `b`], emote: `c`, text: `dEf \t \t \t\t GhiJ \t : \t \t\t klm` } })
    run(`a  \t  \t \t  AnD \t \t\t \t \tb \t \t\t (c   \t\t \t    \t   \t ):dEf \t \t \t\t GhiJ \t : \t \t\t klm`, { lineWithEmoteAndText: { characters: [`a`, `b`], emote: `c`, text: `dEf \t \t \t\t GhiJ \t : \t \t\t klm` } })
    run(`a  \t  \t \t  AnD \t \t\t \t \tb \t \t\t (c)   \t\t \t    \t   \t :dEf \t \t \t\t GhiJ \t : \t \t\t klm`, { lineWithEmoteAndText: { characters: [`a`, `b`], emote: `c`, text: `dEf \t \t \t\t GhiJ \t : \t \t\t klm` } })
    run(`a  \t  \t \t  AnD \t \t\t \t \tb \t \t\t (c):   \t\t \t    \t   \t dEf \t \t \t\t GhiJ \t : \t \t\t klm`, { lineWithEmoteAndText: { characters: [`a`, `b`], emote: `c`, text: `dEf \t \t \t\t GhiJ \t : \t \t\t klm` } })
    run(`a   \t \t \t  b  \t  \t \t  AnD \t \t\t \t \tc(d):e`, { lineWithEmoteAndText: { characters: [`a`, `b`, `c`], emote: `d`, text: `e` } })
    run(`a   \t \t \t  b  \t  \t \t  AnD \t \t\t \t \tc \t \t\t (d):e`, { lineWithEmoteAndText: { characters: [`a`, `b`, `c`], emote: `d`, text: `e` } })
    run(`a   \t \t \t  b  \t  \t \t  AnD \t \t\t \t \tc( \t \t\t d):e`, { lineWithEmoteAndText: { characters: [`a`, `b`, `c`], emote: `d`, text: `e` } })
    run(`a   \t \t \t  b  \t  \t \t  AnD \t \t\t \t \tc(d   \t\t \t ):e`, { lineWithEmoteAndText: { characters: [`a`, `b`, `c`], emote: `d`, text: `e` } })
    run(`a   \t \t \t  b  \t  \t \t  AnD \t \t\t \t \tc(d)   \t\t \t    \t   \t :e`, { lineWithEmoteAndText: { characters: [`a`, `b`, `c`], emote: `d`, text: `e` } })
    run(`a   \t \t \t  b  \t  \t \t  AnD \t \t\t \t \tc(d):   \t\t \t    \t   \t e`, { lineWithEmoteAndText: { characters: [`a`, `b`, `c`], emote: `d`, text: `e` } })
    run(`aBC   \t \t \t  d  \t  \t \t  AnD \t \t\t \t \te(f):g`, { lineWithEmoteAndText: { characters: [`aBC`, `d`, `e`], emote: `f`, text: `g` } })
    run(`aBC   \t \t \t  d  \t  \t \t  AnD \t \t\t \t \te \t \t\t (f):g`, { lineWithEmoteAndText: { characters: [`aBC`, `d`, `e`], emote: `f`, text: `g` } })
    run(`aBC   \t \t \t  d  \t  \t \t  AnD \t \t\t \t \te( \t \t\t f):g`, { lineWithEmoteAndText: { characters: [`aBC`, `d`, `e`], emote: `f`, text: `g` } })
    run(`aBC   \t \t \t  d  \t  \t \t  AnD \t \t\t \t \te(f   \t\t \t ):g`, { lineWithEmoteAndText: { characters: [`aBC`, `d`, `e`], emote: `f`, text: `g` } })
    run(`aBC   \t \t \t  d  \t  \t \t  AnD \t \t\t \t \te(f)   \t\t \t    \t   \t :g`, { lineWithEmoteAndText: { characters: [`aBC`, `d`, `e`], emote: `f`, text: `g` } })
    run(`aBC   \t \t \t  d  \t  \t \t  AnD \t \t\t \t \te(f):   \t\t \t    \t   \t g`, { lineWithEmoteAndText: { characters: [`aBC`, `d`, `e`], emote: `f`, text: `g` } })
    run(`a   \t \t \t  BCd  \t  \t \t  AnD \t \t\t \t \te(f):g`, { lineWithEmoteAndText: { characters: [`a`, `BCd`, `e`], emote: `f`, text: `g` } })
    run(`a   \t \t \t  BCd  \t  \t \t  AnD \t \t\t \t \te \t \t\t (f):g`, { lineWithEmoteAndText: { characters: [`a`, `BCd`, `e`], emote: `f`, text: `g` } })
    run(`a   \t \t \t  BCd  \t  \t \t  AnD \t \t\t \t \te( \t \t\t f):g`, { lineWithEmoteAndText: { characters: [`a`, `BCd`, `e`], emote: `f`, text: `g` } })
    run(`a   \t \t \t  BCd  \t  \t \t  AnD \t \t\t \t \te(f   \t\t \t ):g`, { lineWithEmoteAndText: { characters: [`a`, `BCd`, `e`], emote: `f`, text: `g` } })
    run(`a   \t \t \t  BCd  \t  \t \t  AnD \t \t\t \t \te(f)   \t\t \t    \t   \t :g`, { lineWithEmoteAndText: { characters: [`a`, `BCd`, `e`], emote: `f`, text: `g` } })
    run(`a   \t \t \t  BCd  \t  \t \t  AnD \t \t\t \t \te(f):   \t\t \t    \t   \t g`, { lineWithEmoteAndText: { characters: [`a`, `BCd`, `e`], emote: `f`, text: `g` } })
    run(`a   \t \t \t  b  \t  \t \t  AnD \t \t\t \t \tcDE(f):g`, { lineWithEmoteAndText: { characters: [`a`, `b`, `cDE`], emote: `f`, text: `g` } })
    run(`a   \t \t \t  b  \t  \t \t  AnD \t \t\t \t \tcDE \t \t\t (f):g`, { lineWithEmoteAndText: { characters: [`a`, `b`, `cDE`], emote: `f`, text: `g` } })
    run(`a   \t \t \t  b  \t  \t \t  AnD \t \t\t \t \tcDE( \t \t\t f):g`, { lineWithEmoteAndText: { characters: [`a`, `b`, `cDE`], emote: `f`, text: `g` } })
    run(`a   \t \t \t  b  \t  \t \t  AnD \t \t\t \t \tcDE(f   \t\t \t ):g`, { lineWithEmoteAndText: { characters: [`a`, `b`, `cDE`], emote: `f`, text: `g` } })
    run(`a   \t \t \t  b  \t  \t \t  AnD \t \t\t \t \tcDE(f)   \t\t \t    \t   \t :g`, { lineWithEmoteAndText: { characters: [`a`, `b`, `cDE`], emote: `f`, text: `g` } })
    run(`a   \t \t \t  b  \t  \t \t  AnD \t \t\t \t \tcDE(f):   \t\t \t    \t   \t g`, { lineWithEmoteAndText: { characters: [`a`, `b`, `cDE`], emote: `f`, text: `g` } })
    run(`a   \t \t \t  b  \t  \t \t  AnD \t \t\t \t \tc(dEf):g`, { lineWithEmoteAndText: { characters: [`a`, `b`, `c`], emote: `dEf`, text: `g` } })
    run(`a   \t \t \t  b  \t  \t \t  AnD \t \t\t \t \tc \t \t\t (dEf):g`, { lineWithEmoteAndText: { characters: [`a`, `b`, `c`], emote: `dEf`, text: `g` } })
    run(`a   \t \t \t  b  \t  \t \t  AnD \t \t\t \t \tc( \t \t\t dEf):g`, { lineWithEmoteAndText: { characters: [`a`, `b`, `c`], emote: `dEf`, text: `g` } })
    run(`a   \t \t \t  b  \t  \t \t  AnD \t \t\t \t \tc(dEf   \t\t \t ):g`, { lineWithEmoteAndText: { characters: [`a`, `b`, `c`], emote: `dEf`, text: `g` } })
    run(`a   \t \t \t  b  \t  \t \t  AnD \t \t\t \t \tc(dEf)   \t\t \t    \t   \t :g`, { lineWithEmoteAndText: { characters: [`a`, `b`, `c`], emote: `dEf`, text: `g` } })
    run(`a   \t \t \t  b  \t  \t \t  AnD \t \t\t \t \tc(dEf):   \t\t \t    \t   \t g`, { lineWithEmoteAndText: { characters: [`a`, `b`, `c`], emote: `dEf`, text: `g` } })
    run(`a   \t \t \t  b  \t  \t \t  AnD \t \t\t \t \tc \t \t\t (d):eFG \t \t \t\t hIJk \t : \t \t\t LMN`, { lineWithEmoteAndText: { characters: [`a`, `b`, `c`], emote: `d`, text: `eFG \t \t \t\t hIJk \t : \t \t\t LMN` } })
    run(`a   \t \t \t  b  \t  \t \t  AnD \t \t\t \t \tc \t \t\t (   \t\t \t    \t   \t d):eFG \t \t \t\t hIJk \t : \t \t\t LMN`, { lineWithEmoteAndText: { characters: [`a`, `b`, `c`], emote: `d`, text: `eFG \t \t \t\t hIJk \t : \t \t\t LMN` } })
    run(`a   \t \t \t  b  \t  \t \t  AnD \t \t\t \t \tc \t \t\t (d   \t\t \t    \t   \t ):eFG \t \t \t\t hIJk \t : \t \t\t LMN`, { lineWithEmoteAndText: { characters: [`a`, `b`, `c`], emote: `d`, text: `eFG \t \t \t\t hIJk \t : \t \t\t LMN` } })
    run(`a   \t \t \t  b  \t  \t \t  AnD \t \t\t \t \tc \t \t\t (d)   \t\t \t    \t   \t :eFG \t \t \t\t hIJk \t : \t \t\t LMN`, { lineWithEmoteAndText: { characters: [`a`, `b`, `c`], emote: `d`, text: `eFG \t \t \t\t hIJk \t : \t \t\t LMN` } })
    run(`a   \t \t \t  b  \t  \t \t  AnD \t \t\t \t \tc \t \t\t (d):   \t\t \t    \t   \t eFG \t \t \t\t hIJk \t : \t \t\t LMN`, { lineWithEmoteAndText: { characters: [`a`, `b`, `c`], emote: `d`, text: `eFG \t \t \t\t hIJk \t : \t \t\t LMN` } })
    run(`a  \t  \t \t  b \t c\t\t AnD \t  \td(e):f`, { lineWithEmoteAndText: { characters: [`a`, `b`, `c`, `d`], emote: `e`, text: `f` } })
    run(`a  \t  \t \t  b \t c\t\t AnD \t  \td   \t\t \t(e):f`, { lineWithEmoteAndText: { characters: [`a`, `b`, `c`, `d`], emote: `e`, text: `f` } })
    run(`a  \t  \t \t  b \t c\t\t AnD \t  \td(  \t\t \t e):f`, { lineWithEmoteAndText: { characters: [`a`, `b`, `c`, `d`], emote: `e`, text: `f` } })
    run(`a  \t  \t \t  b \t c\t\t AnD \t  \td(e \t\t     ):f`, { lineWithEmoteAndText: { characters: [`a`, `b`, `c`, `d`], emote: `e`, text: `f` } })
    run(`a  \t  \t \t  b \t c\t\t AnD \t  \td(e)  \t \t   :f`, { lineWithEmoteAndText: { characters: [`a`, `b`, `c`, `d`], emote: `e`, text: `f` } })
    run(`a  \t  \t \t  b \t c\t\t AnD \t  \td(e):  \t \t   f`, { lineWithEmoteAndText: { characters: [`a`, `b`, `c`, `d`], emote: `e`, text: `f` } })
    run(`aBC  \t  \t \t  d \t e\t\t AnD \t  \tf(g):h`, { lineWithEmoteAndText: { characters: [`aBC`, `d`, `e`, `f`], emote: `g`, text: `h` } })
    run(`aBC  \t  \t \t  d \t e\t\t AnD \t  \tf   \t\t \t(g):h`, { lineWithEmoteAndText: { characters: [`aBC`, `d`, `e`, `f`], emote: `g`, text: `h` } })
    run(`aBC  \t  \t \t  d \t e\t\t AnD \t  \tf(  \t\t \t g):h`, { lineWithEmoteAndText: { characters: [`aBC`, `d`, `e`, `f`], emote: `g`, text: `h` } })
    run(`aBC  \t  \t \t  d \t e\t\t AnD \t  \tf(g \t\t     ):h`, { lineWithEmoteAndText: { characters: [`aBC`, `d`, `e`, `f`], emote: `g`, text: `h` } })
    run(`aBC  \t  \t \t  d \t e\t\t AnD \t  \tf(g)  \t \t   :h`, { lineWithEmoteAndText: { characters: [`aBC`, `d`, `e`, `f`], emote: `g`, text: `h` } })
    run(`aBC  \t  \t \t  d \t e\t\t AnD \t  \tf(g):  \t \t   h`, { lineWithEmoteAndText: { characters: [`aBC`, `d`, `e`, `f`], emote: `g`, text: `h` } })
    run(`a  \t  \t \t  BCd \t e\t\t AnD \t  \tf(g):h`, { lineWithEmoteAndText: { characters: [`a`, `BCd`, `e`, `f`], emote: `g`, text: `h` } })
    run(`a  \t  \t \t  BCd \t e\t\t AnD \t  \tf   \t\t \t(g):h`, { lineWithEmoteAndText: { characters: [`a`, `BCd`, `e`, `f`], emote: `g`, text: `h` } })
    run(`a  \t  \t \t  BCd \t e\t\t AnD \t  \tf(  \t\t \t g):h`, { lineWithEmoteAndText: { characters: [`a`, `BCd`, `e`, `f`], emote: `g`, text: `h` } })
    run(`a  \t  \t \t  BCd \t e\t\t AnD \t  \tf(g \t\t     ):h`, { lineWithEmoteAndText: { characters: [`a`, `BCd`, `e`, `f`], emote: `g`, text: `h` } })
    run(`a  \t  \t \t  BCd \t e\t\t AnD \t  \tf(g)  \t \t   :h`, { lineWithEmoteAndText: { characters: [`a`, `BCd`, `e`, `f`], emote: `g`, text: `h` } })
    run(`a  \t  \t \t  BCd \t e\t\t AnD \t  \tf(g):  \t \t   h`, { lineWithEmoteAndText: { characters: [`a`, `BCd`, `e`, `f`], emote: `g`, text: `h` } })
    run(`a  \t  \t \t  b \t cDE\t\t AnD \t  \tf(g):h`, { lineWithEmoteAndText: { characters: [`a`, `b`, `cDE`, `f`], emote: `g`, text: `h` } })
    run(`a  \t  \t \t  b \t cDE\t\t AnD \t  \tf   \t\t \t(g):h`, { lineWithEmoteAndText: { characters: [`a`, `b`, `cDE`, `f`], emote: `g`, text: `h` } })
    run(`a  \t  \t \t  b \t cDE\t\t AnD \t  \tf(  \t\t \t g):h`, { lineWithEmoteAndText: { characters: [`a`, `b`, `cDE`, `f`], emote: `g`, text: `h` } })
    run(`a  \t  \t \t  b \t cDE\t\t AnD \t  \tf(g \t\t     ):h`, { lineWithEmoteAndText: { characters: [`a`, `b`, `cDE`, `f`], emote: `g`, text: `h` } })
    run(`a  \t  \t \t  b \t cDE\t\t AnD \t  \tf(g)  \t \t   :h`, { lineWithEmoteAndText: { characters: [`a`, `b`, `cDE`, `f`], emote: `g`, text: `h` } })
    run(`a  \t  \t \t  b \t cDE\t\t AnD \t  \tf(g):  \t \t   h`, { lineWithEmoteAndText: { characters: [`a`, `b`, `cDE`, `f`], emote: `g`, text: `h` } })
    run(`a  \t  \t \t  b \t c\t\t AnD \t  \tdEf(g):h`, { lineWithEmoteAndText: { characters: [`a`, `b`, `c`, `dEf`], emote: `g`, text: `h` } })
    run(`a  \t  \t \t  b \t c\t\t AnD \t  \tdEf   \t\t \t(g):h`, { lineWithEmoteAndText: { characters: [`a`, `b`, `c`, `dEf`], emote: `g`, text: `h` } })
    run(`a  \t  \t \t  b \t c\t\t AnD \t  \tdEf(  \t\t \t g):h`, { lineWithEmoteAndText: { characters: [`a`, `b`, `c`, `dEf`], emote: `g`, text: `h` } })
    run(`a  \t  \t \t  b \t c\t\t AnD \t  \tdEf(g \t\t     ):h`, { lineWithEmoteAndText: { characters: [`a`, `b`, `c`, `dEf`], emote: `g`, text: `h` } })
    run(`a  \t  \t \t  b \t c\t\t AnD \t  \tdEf(g)  \t \t   :h`, { lineWithEmoteAndText: { characters: [`a`, `b`, `c`, `dEf`], emote: `g`, text: `h` } })
    run(`a  \t  \t \t  b \t c\t\t AnD \t  \tdEf(g):  \t \t   h`, { lineWithEmoteAndText: { characters: [`a`, `b`, `c`, `dEf`], emote: `g`, text: `h` } })
    run(`a  \t  \t \t  b \t c\t\t AnD \t  \td(eFG):h`, { lineWithEmoteAndText: { characters: [`a`, `b`, `c`, `d`], emote: `eFG`, text: `h` } })
    run(`a  \t  \t \t  b \t c\t\t AnD \t  \td   \t\t \t(eFG):h`, { lineWithEmoteAndText: { characters: [`a`, `b`, `c`, `d`], emote: `eFG`, text: `h` } })
    run(`a  \t  \t \t  b \t c\t\t AnD \t  \td(  \t\t \t eFG):h`, { lineWithEmoteAndText: { characters: [`a`, `b`, `c`, `d`], emote: `eFG`, text: `h` } })
    run(`a  \t  \t \t  b \t c\t\t AnD \t  \td(eFG \t\t     ):h`, { lineWithEmoteAndText: { characters: [`a`, `b`, `c`, `d`], emote: `eFG`, text: `h` } })
    run(`a  \t  \t \t  b \t c\t\t AnD \t  \td(eFG)  \t \t   :h`, { lineWithEmoteAndText: { characters: [`a`, `b`, `c`, `d`], emote: `eFG`, text: `h` } })
    run(`a  \t  \t \t  b \t c\t\t AnD \t  \td(eFG):  \t \t   h`, { lineWithEmoteAndText: { characters: [`a`, `b`, `c`, `d`], emote: `eFG`, text: `h` } })
    run(`a  \t  \t \t  b \t c\t\t AnD \t  \td   \t\t \t(e):fgh \t \t \t\t ijKL \t : \t \t\t mno`, { lineWithEmoteAndText: { characters: [`a`, `b`, `c`, `d`], emote: `e`, text: `fgh \t \t \t\t ijKL \t : \t \t\t mno` } })
    run(`a  \t  \t \t  b \t c\t\t AnD \t  \td   \t\t \t(  \t \t   e):fgh \t \t \t\t ijKL \t : \t \t\t mno`, { lineWithEmoteAndText: { characters: [`a`, `b`, `c`, `d`], emote: `e`, text: `fgh \t \t \t\t ijKL \t : \t \t\t mno` } })
    run(`a  \t  \t \t  b \t c\t\t AnD \t  \td   \t\t \t(e  \t \t   ):fgh \t \t \t\t ijKL \t : \t \t\t mno`, { lineWithEmoteAndText: { characters: [`a`, `b`, `c`, `d`], emote: `e`, text: `fgh \t \t \t\t ijKL \t : \t \t\t mno` } })
    run(`a  \t  \t \t  b \t c\t\t AnD \t  \td   \t\t \t(e)  \t \t   :fgh \t \t \t\t ijKL \t : \t \t\t mno`, { lineWithEmoteAndText: { characters: [`a`, `b`, `c`, `d`], emote: `e`, text: `fgh \t \t \t\t ijKL \t : \t \t\t mno` } })
    run(`a  \t  \t \t  b \t c\t\t AnD \t  \td   \t\t \t(e):  \t \t   fgh \t \t \t\t ijKL \t : \t \t\t mno`, { lineWithEmoteAndText: { characters: [`a`, `b`, `c`, `d`], emote: `e`, text: `fgh \t \t \t\t ijKL \t : \t \t\t mno` } })
  })
})

describe(`indenterEndOfFile`, () => {
  const onLine = jasmine.createSpy(`onLine`)
  const onIndent = jasmine.createSpy(`onIndent`)
  const onOutdent = jasmine.createSpy(`onOutdent`)
  const onError = jasmine.createSpy(`onError`)
  const onEndOfFile = jasmine.createSpy(`onEndOfFile`)
  let numberOfOnOutdentCallsAtTimeOfCallingOnLine
  onEndOfFile.and.callFake(() => {
    numberOfOnOutdentCallsAtTimeOfCallingOnLine = onOutdent.calls.count()
  })
  afterEach(() => {
    onLine.calls.reset()
    onIndent.calls.reset()
    onOutdent.calls.reset()
    onError.calls.reset()
    onEndOfFile.calls.reset()
  })
  let indenter
  beforeEach(() => indenter = {
    context: `Test Context`,
    onLine,
    onIndent,
    onOutdent,
    onError,
    onEndOfFile
  })

  describe(`when there is not an indentation character`, () => {
    beforeEach(() => {
      indenter.stack = [0]
      indenter.indentationCharacter = null
      get(`indenterEndOfFile`)(indenter)
    })
    it(`does not call onLine`, () => expect(onLine).not.toHaveBeenCalled())
    it(`does not call onIndent`, () => expect(onIndent).not.toHaveBeenCalled())
    it(`does not call onOutdent`, () => expect(onOutdent).not.toHaveBeenCalled())
    it(`does not call onError`, () => expect(onError).not.toHaveBeenCalled())
    it(`calls onEndOfFile once`, () => expect(onEndOfFile).toHaveBeenCalledTimes(1))
    it(`calls onEndOfFile with the context`, () => expect(onEndOfFile).toHaveBeenCalledWith(`Test Context`))
  })

  describe(`when there is an indentation character`, () => {
    beforeEach(() => {
      indenter.stack = [0, 24, 33, 51, 78]
      indenter.indentationCharacter = `Test Indentation Character`
      get(`indenterEndOfFile`)(indenter)
    })
    it(`does not call onLine`, () => expect(onLine).not.toHaveBeenCalled())
    it(`does not call onIndent`, () => expect(onIndent).not.toHaveBeenCalled())
    it(`calls onOutdent once per stack level`, () => expect(onOutdent).toHaveBeenCalledTimes(4))
    it(`calls onOutdent with the context`, () => {
      expect(onOutdent.calls.argsFor(0)).toEqual([`Test Context`])
      expect(onOutdent.calls.argsFor(1)).toEqual([`Test Context`])
      expect(onOutdent.calls.argsFor(2)).toEqual([`Test Context`])
      expect(onOutdent.calls.argsFor(3)).toEqual([`Test Context`])
    })
    it(`does not call onError`, () => expect(onError).not.toHaveBeenCalled())
    it(`calls onEndOfFile once`, () => expect(onEndOfFile).toHaveBeenCalledTimes(1))
    it(`calls onEndOfFile with the context`, () => expect(onEndOfFile).toHaveBeenCalledWith(`Test Context`))
    it(`calls onOutdent before onEndOfFile`, () => expect(numberOfOnOutdentCallsAtTimeOfCallingOnLine).toEqual(4))
  })
})

describe(`create`, () => {
  const linerCreate = setSpy(`linerCreate`)
  linerCreate.and.returnValue(`Test Liner`)
  const indenterCreate = setSpy(`indenterCreate`)
  indenterCreate.and.returnValue(`Test Indenter`)
  const indenterLine = setSpy(`indenterLine`)
  const indenterEndOfFile = setSpy(`indenterEndOfFile`)
  afterEach(() => {
    linerCreate.calls.reset()
    indenterCreate.calls.reset()
    indenterLine.calls.reset()
    indenterEndOfFile.calls.reset()
  })
  let result
  beforeEach(() => result = index.create(`Test Context`, `Test On Line`, `Test On Indent`, `Test On Outdent`, `Test On Error`, `Test On End Of File`))
  it(`creates one liner`, () => expect(linerCreate).toHaveBeenCalledTimes(1))
  it(`creates the liner using the indenter`, () => expect(linerCreate).toHaveBeenCalledWith(`Test Indenter`, jasmine.anything(), jasmine.anything()))
  it(`creates the liner using indenterLine`, () => expect(linerCreate).toHaveBeenCalledWith(jasmine.anything(), indenterLine, jasmine.anything()))
  it(`creates the liner using indenterEndOfFile`, () => expect(linerCreate).toHaveBeenCalledWith(jasmine.anything(), jasmine.anything(), indenterEndOfFile))
  it(`creates one indenter`, () => expect(indenterCreate).toHaveBeenCalledTimes(1))
  it(`creates the indenter using the context`, () => expect(indenterCreate).toHaveBeenCalledWith(`Test Context`, jasmine.anything(), jasmine.anything(), jasmine.anything(), jasmine.anything(), jasmine.anything()))
  it(`creates the indenter using the onLine`, () => expect(indenterCreate).toHaveBeenCalledWith(jasmine.anything(), `Test On Line`, jasmine.anything(), jasmine.anything(), jasmine.anything(), jasmine.anything()))
  it(`creates the indenter using the onIndent`, () => expect(indenterCreate).toHaveBeenCalledWith(jasmine.anything(), jasmine.anything(), `Test On Indent`, jasmine.anything(), jasmine.anything(), jasmine.anything()))
  it(`creates the indenter using the onOutdent`, () => expect(indenterCreate).toHaveBeenCalledWith(jasmine.anything(), jasmine.anything(), jasmine.anything(), `Test On Outdent`, jasmine.anything(), jasmine.anything()))
  it(`creates the indenter using the onError`, () => expect(indenterCreate).toHaveBeenCalledWith(jasmine.anything(), jasmine.anything(), jasmine.anything(), jasmine.anything(), `Test On Error`, jasmine.anything()))
  it(`creates the indenter using the onEndOfFile`, () => expect(indenterCreate).toHaveBeenCalledWith(jasmine.anything(), jasmine.anything(), jasmine.anything(), jasmine.anything(), jasmine.anything(), `Test On End Of File`))
  it(`returns an object`, () => expect(result).toEqual(jasmine.any(Object)))
  it(`returns state, "waiting"`, () => expect(result.state).toEqual("waiting"))
  it(`returns the liner`, () => expect(result.liner).toEqual(`Test Liner`))
})
