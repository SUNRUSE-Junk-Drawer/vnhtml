const rewire = require(`rewire`)
const index = rewire(`./index.babel.js`)

const get = name => index.__get__(name)
const set = (name, value) => {
  let replaced
  beforeEach(() => {
    replaced = index.__get__(name)
    index.__set__(name, value)
  })
  afterEach(() => {
    index.__set__(name, replaced)
  })
  return value
}

const setSpy = name => set(name, jasmine.createSpy(name))

describe(`linerCreate`, () => {
  it(`returns an object`, () => expect(get(`linerCreate`)(`Test Context`, `Test On Line`, `Test On End Of File`)).toEqual(jasmine.any(Object)))
  it(`returns line, 1`, () => expect(get(`linerCreate`)(`Test Context`, `Test On Line`, `Test On End Of File`).line).toEqual(1))
  it(`returns text, empty`, () => expect(get(`linerCreate`)(`Test Context`, `Test On Line`, `Test On End Of File`).text).toEqual(``))
  it(`returns lineComment, null`, () => expect(get(`linerCreate`)(`Test Context`, `Test On Line`, `Test On End Of File`).lineComment).toBeNull())
  it(`returns context, given`, () => expect(get(`linerCreate`)(`Test Context`, `Test On Line`, `Test On End Of File`).context).toEqual(`Test Context`))
  it(`returns onLine, given`, () => expect(get(`linerCreate`)(`Test Context`, `Test On Line`, `Test On End Of File`).onLine).toEqual(`Test On Line`))
  it(`returns onEndOfFile, given`, () => expect(get(`linerCreate`)(`Test Context`, `Test On Line`, `Test On End Of File`).onEndOfFile).toEqual(`Test On End Of File`))
  it(`returns a new object every call`, () => expect(get(`linerCreate`)(`Test Context`, `Test On Line`, `Test On End Of File`)).not.toBe(get(`linerCreate`)(`Test Context`, `Test On Line`, `Test On End Of File`)))
  it(`returns the same value every call`, () => expect(get(`linerCreate`)(`Test Context`, `Test On Line`, `Test On End Of File`)).toEqual(get(`linerCreate`)(`Test Context`, `Test On Line`, `Test On End Of File`)))
})

describe(`linerClassifyCharacter`, () => {
  const run = (input, output) => describe(`given "${input}"`, () => it(`returns "${output}"`, () => expect(get(`linerClassifyCharacter`)(input)).toEqual(output)))
  run(`a`, `partOfLine`)
  run(`d`, `partOfLine`)
  run(`q`, `partOfLine`)
  run(`z`, `partOfLine`)
  run(`0`, `partOfLine`)
  run(`4`, `partOfLine`)
  run(`9`, `partOfLine`)
  run(`0`, `partOfLine`)
  run(`!`, `partOfLine`)
  run(`$`, `partOfLine`)
  run(`?`, `partOfLine`)
  run(`#`, `partOfLine`)
  run(`ã‹`, `partOfLine`)
  run(` `, `partOfLine`)
  run(`\t`, `partOfLine`)
  run(`\r`, `newLine`)
  run(`\n`, `newLine`)
  run(`\``, `lineComment`)
})

describe(`linerTextNotEmpty`, () => {
  const run = (input, output) => describe(`given "${input}"`, () => it(`returns ${output}`, () => expect(get(`linerTextNotEmpty`)(input)).toBe(output)))
  run(``, false)
  run(` `, false)
  run(`\t`, false)
  run(`   \t     \t  `, false)
  run(`a`, true)
  run(` a`, true)
  run(`\ta`, true)
  run(`   \t     \t  a`, true)
  run(`awdhk\tauwdh iyi`, true)
  run(` awdhk\tauwdh iyi`, true)
  run(`\tawdhk\tauwdh iyi`, true)
  run(`   \t     \t  awdhk auwdh iyi`, true)
  run(`awdhk\tauwdh iyi `, true)
  run(`awdhk\tauwdh iyi\t`, true)
  run(`awdhk\tauwdh iyi   \t     \t  `, true)
  run(` awdhk\tauwdh iyi `, true)
  run(` awdhk\tauwdh iyi\t`, true)
  run(` awdhk\tauwdh iyi   \t     \t  `, true)
  run(`\tawdhk\tauwdh iyi `, true)
  run(`\tawdhk\tauwdh iyi\t`, true)
  run(`\tawdhk\tauwdh iyi   \t     \t  `, true)
  run(`  \t \t  \t  awdhk\tauwdh iyi `, true)
  run(`  \t \t  \t  awdhk\tauwdh iyi\t`, true)
  run(`  \t \t  \t  awdhk\tauwdh iyi   \t     \t  `, true)
})

describe(`linerCharacter`, () => {
  const linerClassifyCharacter = setSpy(`linerClassifyCharacter`)
  const linerTextNotEmpty = setSpy(`linerTextNotEmpty`)
  const onLine = jasmine.createSpy(`onLine`)
  const onEndOfFile = jasmine.createSpy(`onEndOfFile`)
  afterEach(() => {
    linerClassifyCharacter.calls.reset()
    linerTextNotEmpty.calls.reset()
    onLine.calls.reset()
    onEndOfFile.calls.reset()
  })
  let liner
  beforeEach(() => liner = {
    line: 2368,
    text: `Test Text`,
    context: `Test Context`,
    onLine,
    onEndOfFile
  })

  describe(`when not inside a line comment`, () => {
    beforeEach(() => liner.lineComment = null)
    describe(`when given a line comment`, () => {
      beforeEach(() => {
        linerClassifyCharacter.and.returnValue(`lineComment`)
        get(`linerCharacter`)(liner, `Test Character`)
      })
      it(`does not change line`, () => expect(liner.line).toEqual(2368))
      it(`does not change text`, () => expect(liner.text).toEqual(`Test Text`))
      it(`starts a line comment`, () => expect(liner.lineComment).toEqual(`Test Character`))
      it(`does not change the context`, () => expect(liner.context).toEqual(`Test Context`))
      it(`does not change onLine`, () => expect(liner.onLine).toBe(onLine))
      it(`does not change onEndOfFile`, () => expect(liner.onEndOfFile).toBe(onEndOfFile))
      it(`calls linerClassifyCharacter once`, () => expect(linerClassifyCharacter).toHaveBeenCalledTimes(1))
      it(`calls linerClassifyCharacter with the given character`, () => expect(linerClassifyCharacter).toHaveBeenCalledWith(`Test Character`))
      it(`does not call linerTextNotEmpty`, () => expect(linerTextNotEmpty).not.toHaveBeenCalled())
      it(`does not call onLine`, () => expect(onLine).not.toHaveBeenCalled())
      it(`does not call onEndOfFile`, () => expect(onEndOfFile).not.toHaveBeenCalled())
    })

    describe(`when given a new line`, () => {
      beforeEach(() => linerClassifyCharacter.and.returnValue(`newLine`))
      describe(`when the accumulated text is empty`, () => {
        beforeEach(() => {
          linerTextNotEmpty.and.returnValue(false)
          get(`linerCharacter`)(liner, `Test Character`)
        })
        it(`increments line`, () => expect(liner.line).toEqual(2369))
        it(`empties text`, () => expect(liner.text).toEqual(``))
        it(`does not start a line comment`, () => expect(liner.lineComment).toBeNull())
        it(`does not change the context`, () => expect(liner.context).toEqual(`Test Context`))
        it(`does not change onLine`, () => expect(liner.onLine).toBe(onLine))
        it(`does not change onEndOfFile`, () => expect(liner.onEndOfFile).toBe(onEndOfFile))
        it(`calls linerClassifyCharacter once`, () => expect(linerClassifyCharacter).toHaveBeenCalledTimes(1))
        it(`calls linerClassifyCharacter with the given character`, () => expect(linerClassifyCharacter).toHaveBeenCalledWith(`Test Character`))
        it(`calls linerTextNotEmpty once`, () => expect(linerTextNotEmpty).toHaveBeenCalledTimes(1))
        it(`calls linerTextNotEmpty with the text`, () => expect(linerTextNotEmpty).toHaveBeenCalledWith(`Test Text`))
        it(`does not call onLine`, () => expect(onLine).not.toHaveBeenCalled())
        it(`does not call onEndOfFile`, () => expect(onEndOfFile).not.toHaveBeenCalled())
      })

      describe(`when the accumulated text is not empty`, () => {
        beforeEach(() => {
          linerTextNotEmpty.and.returnValue(true)
          get(`linerCharacter`)(liner, `Test Character`)
        })
        it(`increments line`, () => expect(liner.line).toEqual(2369))
        it(`empties text`, () => expect(liner.text).toEqual(``))
        it(`does not start a line comment`, () => expect(liner.lineComment).toBeNull())
        it(`does not change the context`, () => expect(liner.context).toEqual(`Test Context`))
        it(`does not change onLine`, () => expect(liner.onLine).toBe(onLine))
        it(`does not change onEndOfFile`, () => expect(liner.onEndOfFile).toBe(onEndOfFile))
        it(`calls linerClassifyCharacter once`, () => expect(linerClassifyCharacter).toHaveBeenCalledTimes(1))
        it(`calls linerClassifyCharacter with the given character`, () => expect(linerClassifyCharacter).toHaveBeenCalledWith(`Test Character`))
        it(`calls linerTextNotEmpty once`, () => expect(linerTextNotEmpty).toHaveBeenCalledTimes(1))
        it(`calls linerTextNotEmpty with the text`, () => expect(linerTextNotEmpty).toHaveBeenCalledWith(`Test Text`))
        it(`calls onLine once`, () => expect(onLine).toHaveBeenCalledTimes(1))
        it(`calls onLine with the context`, () => expect(onLine).toHaveBeenCalledWith(`Test Context`, jasmine.anything(), jasmine.anything()))
        it(`calls onLine with the line number`, () => expect(onLine).toHaveBeenCalledWith(jasmine.anything(), 2368, jasmine.anything()))
        it(`calls onLine with the text`, () => expect(onLine).toHaveBeenCalledWith(jasmine.anything(), jasmine.anything(), `Test Text`))
        it(`does not call onEndOfFile`, () => expect(onEndOfFile).not.toHaveBeenCalled())
      })
    })

    describe(`when given a part of line`, () => {
      beforeEach(() => {
        linerClassifyCharacter.and.returnValue(`partOfLine`)
        get(`linerCharacter`)(liner, `Test Character`)
      })
      it(`does not change line`, () => expect(liner.line).toEqual(2368))
      it(`appends it to the end of text`, () => expect(liner.text).toEqual(`Test TextTest Character`))
      it(`does not start a line comment`, () => expect(liner.lineComment).toBeNull())
      it(`does not change the context`, () => expect(liner.context).toEqual(`Test Context`))
      it(`does not change onLine`, () => expect(liner.onLine).toBe(onLine))
      it(`does not change onEndOfFile`, () => expect(liner.onEndOfFile).toBe(onEndOfFile))
      it(`calls linerClassifyCharacter once`, () => expect(linerClassifyCharacter).toHaveBeenCalledTimes(1))
      it(`calls linerClassifyCharacter with the given character`, () => expect(linerClassifyCharacter).toHaveBeenCalledWith(`Test Character`))
      it(`does not call linerTextNotEmpty`, () => expect(linerTextNotEmpty).not.toHaveBeenCalled())
      it(`does not call onLine`, () => expect(onLine).not.toHaveBeenCalled())
      it(`does not call onEndOfFile`, () => expect(onEndOfFile).not.toHaveBeenCalled())
    })
  })

  describe(`when in a line comment`, () => {
    beforeEach(() => liner.lineComment = `Test Line Comment`)
    describe(`when given a line comment`, () => {
      beforeEach(() => {
        linerClassifyCharacter.and.returnValue(`lineComment`)
        get(`linerCharacter`)(liner, `Test Character`)
      })
      it(`does not change line`, () => expect(liner.line).toEqual(2368))
      it(`does not change text`, () => expect(liner.text).toEqual(`Test Text`))
      it(`appends it to the end of the line comment`, () => expect(liner.lineComment).toEqual(`Test Line CommentTest Character`))
      it(`does not change the context`, () => expect(liner.context).toEqual(`Test Context`))
      it(`does not change onLine`, () => expect(liner.onLine).toBe(onLine))
      it(`does not change onEndOfFile`, () => expect(liner.onEndOfFile).toBe(onEndOfFile))
      it(`calls linerClassifyCharacter once`, () => expect(linerClassifyCharacter).toHaveBeenCalledTimes(1))
      it(`calls linerClassifyCharacter with the given character`, () => expect(linerClassifyCharacter).toHaveBeenCalledWith(`Test Character`))
      it(`does not call linerTextNotEmpty`, () => expect(linerTextNotEmpty).not.toHaveBeenCalled())
      it(`does not call onLine`, () => expect(onLine).not.toHaveBeenCalled())
      it(`does not call onEndOfFile`, () => expect(onEndOfFile).not.toHaveBeenCalled())
    })

    describe(`when given a new line`, () => {
      beforeEach(() => linerClassifyCharacter.and.returnValue(`newLine`))
      describe(`when the accumulated text is empty`, () => {
        beforeEach(() => {
          linerTextNotEmpty.and.returnValue(false)
          get(`linerCharacter`)(liner, `Test Character`)
        })
        it(`increments line`, () => expect(liner.line).toEqual(2369))
        it(`empties text`, () => expect(liner.text).toEqual(``))
        it(`ends the line comment`, () => expect(liner.lineComment).toBeNull())
        it(`does not change the context`, () => expect(liner.context).toEqual(`Test Context`))
        it(`does not change onLine`, () => expect(liner.onLine).toBe(onLine))
        it(`does not change onEndOfFile`, () => expect(liner.onEndOfFile).toBe(onEndOfFile))
        it(`calls linerClassifyCharacter once`, () => expect(linerClassifyCharacter).toHaveBeenCalledTimes(1))
        it(`calls linerClassifyCharacter with the given character`, () => expect(linerClassifyCharacter).toHaveBeenCalledWith(`Test Character`))
        it(`calls linerTextNotEmpty once`, () => expect(linerTextNotEmpty).toHaveBeenCalledTimes(1))
        it(`calls linerTextNotEmpty with the text`, () => expect(linerTextNotEmpty).toHaveBeenCalledWith(`Test Text`))
        it(`does not call onLine`, () => expect(onLine).not.toHaveBeenCalled())
        it(`does not call onEndOfFile`, () => expect(onEndOfFile).not.toHaveBeenCalled())
      })

      describe(`when the accumulated text is not empty`, () => {
        beforeEach(() => {
          linerTextNotEmpty.and.returnValue(true)
          get(`linerCharacter`)(liner, `Test Character`)
        })
        it(`increments line`, () => expect(liner.line).toEqual(2369))
        it(`empties text`, () => expect(liner.text).toEqual(``))
        it(`ends the line comment`, () => expect(liner.lineComment).toBeNull())
        it(`does not change the context`, () => expect(liner.context).toEqual(`Test Context`))
        it(`does not change onLine`, () => expect(liner.onLine).toBe(onLine))
        it(`does not change onEndOfFile`, () => expect(liner.onEndOfFile).toBe(onEndOfFile))
        it(`calls linerClassifyCharacter once`, () => expect(linerClassifyCharacter).toHaveBeenCalledTimes(1))
        it(`calls linerClassifyCharacter with the given character`, () => expect(linerClassifyCharacter).toHaveBeenCalledWith(`Test Character`))
        it(`calls linerTextNotEmpty once`, () => expect(linerTextNotEmpty).toHaveBeenCalledTimes(1))
        it(`calls linerTextNotEmpty with the text`, () => expect(linerTextNotEmpty).toHaveBeenCalledWith(`Test Text`))
        it(`calls onLine once`, () => expect(onLine).toHaveBeenCalledTimes(1))
        it(`calls onLine with the context`, () => expect(onLine).toHaveBeenCalledWith(`Test Context`, jasmine.anything(), jasmine.anything()))
        it(`calls onLine with the line number`, () => expect(onLine).toHaveBeenCalledWith(jasmine.anything(), 2368, jasmine.anything()))
        it(`calls onLine with the text`, () => expect(onLine).toHaveBeenCalledWith(jasmine.anything(), jasmine.anything(), `Test Text`))
        it(`does not call onEndOfFile`, () => expect(onEndOfFile).not.toHaveBeenCalled())
      })
    })

    describe(`when given a part of line`, () => {
      beforeEach(() => {
        linerClassifyCharacter.and.returnValue(`partOfLine`)
        get(`linerCharacter`)(liner, `Test Character`)
      })
      it(`does not change line`, () => expect(liner.line).toEqual(2368))
      it(`does not change text`, () => expect(liner.text).toEqual(`Test Text`))
      it(`appends it to the end of the line comment`, () => expect(liner.lineComment).toEqual(`Test Line CommentTest Character`))
      it(`does not change the context`, () => expect(liner.context).toEqual(`Test Context`))
      it(`does not change onLine`, () => expect(liner.onLine).toBe(onLine))
      it(`does not change onEndOfFile`, () => expect(liner.onEndOfFile).toBe(onEndOfFile))
      it(`calls linerClassifyCharacter once`, () => expect(linerClassifyCharacter).toHaveBeenCalledTimes(1))
      it(`calls linerClassifyCharacter with the given character`, () => expect(linerClassifyCharacter).toHaveBeenCalledWith(`Test Character`))
      it(`does not call linerTextNotEmpty`, () => expect(linerTextNotEmpty).not.toHaveBeenCalled())
      it(`does not call onLine`, () => expect(onLine).not.toHaveBeenCalled())
      it(`does not call onEndOfFile`, () => expect(onEndOfFile).not.toHaveBeenCalled())
    })
  })
})

describe(`linerEndOfFile`, () => {
  const linerClassifyCharacter = setSpy(`linerClassifyCharacter`)
  const linerTextNotEmpty = setSpy(`linerTextNotEmpty`)
  const onLine = jasmine.createSpy(`onLine`)
  const onEndOfFile = jasmine.createSpy(`onEndOfFile`)
  let numberOfOnLineCallsAtTimeOfCallingOnEndOfFile
  onEndOfFile.and.callFake(() => {
    numberOfOnLineCallsAtTimeOfCallingOnEndOfFile = onLine.calls.count()
  })
  afterEach(() => {
    linerClassifyCharacter.calls.reset()
    linerTextNotEmpty.calls.reset()
    onLine.calls.reset()
    onEndOfFile.calls.reset()
  })
  let liner
  beforeEach(() => liner = {
    line: 2368,
    text: `Test Text`,
    context: `Test Context`,
    onLine,
    onEndOfFile
  })

  describe(`when not in a line comment`, () => {
    beforeEach(() => liner.lineComment = null)

    describe(`when the accumulated text is empty`, () => {
      beforeEach(() => {
        linerTextNotEmpty.and.returnValue(false)
        get(`linerEndOfFile`)(liner)
      })
      it(`does not call linerClassifyCharacter`, () => expect(linerClassifyCharacter).not.toHaveBeenCalled())
      it(`calls linerTextNotEmpty once`, () => expect(linerTextNotEmpty).toHaveBeenCalledTimes(1))
      it(`calls linerTextNotEmpty with the text`, () => expect(linerTextNotEmpty).toHaveBeenCalledWith(`Test Text`))
      it(`does not call onLine`, () => expect(onLine).not.toHaveBeenCalled())
      it(`calls onEndOfFile once`, () => expect(onEndOfFile).toHaveBeenCalledTimes(1))
    })

    describe(`when the accumulated text is not empty`, () => {
      beforeEach(() => {
        linerTextNotEmpty.and.returnValue(true)
        get(`linerEndOfFile`)(liner)
      })
      it(`does not call linerClassifyCharacter`, () => expect(linerClassifyCharacter).not.toHaveBeenCalled())
      it(`calls linerTextNotEmpty once`, () => expect(linerTextNotEmpty).toHaveBeenCalledTimes(1))
      it(`calls linerTextNotEmpty with the text`, () => expect(linerTextNotEmpty).toHaveBeenCalledWith(`Test Text`))
      it(`calls onLine once`, () => expect(onLine).toHaveBeenCalledTimes(1))
      it(`calls onLine with the context`, () => expect(onLine).toHaveBeenCalledWith(`Test Context`, jasmine.anything(), jasmine.anything()))
      it(`calls onLine with the line number`, () => expect(onLine).toHaveBeenCalledWith(jasmine.anything(), 2368, jasmine.anything()))
      it(`calls onLine with the text`, () => expect(onLine).toHaveBeenCalledWith(jasmine.anything(), jasmine.anything(), `Test Text`))
      it(`calls onEndOfFile once`, () => expect(onEndOfFile).toHaveBeenCalledTimes(1))
      it(`calls onLine before onEndOfFile`, () => expect(numberOfOnLineCallsAtTimeOfCallingOnEndOfFile).toEqual(1))
    })
  })

  describe(`when in a line comment`, () => {
    beforeEach(() => liner.lineComment = `Test Line Comment`)

    describe(`when the accumulated text is empty`, () => {
      beforeEach(() => {
        linerTextNotEmpty.and.returnValue(false)
        get(`linerEndOfFile`)(liner)
      })
      it(`does not call linerClassifyCharacter`, () => expect(linerClassifyCharacter).not.toHaveBeenCalled())
      it(`calls linerTextNotEmpty once`, () => expect(linerTextNotEmpty).toHaveBeenCalledTimes(1))
      it(`calls linerTextNotEmpty with the text`, () => expect(linerTextNotEmpty).toHaveBeenCalledWith(`Test Text`))
      it(`does not call onLine`, () => expect(onLine).not.toHaveBeenCalled())
      it(`calls onEndOfFile once`, () => expect(onEndOfFile).toHaveBeenCalledTimes(1))
    })

    describe(`when the accumulated text is not empty`, () => {
      beforeEach(() => {
        linerTextNotEmpty.and.returnValue(true)
        get(`linerEndOfFile`)(liner)
      })
      it(`does not call linerClassifyCharacter`, () => expect(linerClassifyCharacter).not.toHaveBeenCalled())
      it(`calls linerTextNotEmpty once`, () => expect(linerTextNotEmpty).toHaveBeenCalledTimes(1))
      it(`calls linerTextNotEmpty with the text`, () => expect(linerTextNotEmpty).toHaveBeenCalledWith(`Test Text`))
      it(`calls onLine once`, () => expect(onLine).toHaveBeenCalledTimes(1))
      it(`calls onLine with the context`, () => expect(onLine).toHaveBeenCalledWith(`Test Context`, jasmine.anything(), jasmine.anything()))
      it(`calls onLine with the line number`, () => expect(onLine).toHaveBeenCalledWith(jasmine.anything(), 2368, jasmine.anything()))
      it(`calls onLine with the text`, () => expect(onLine).toHaveBeenCalledWith(jasmine.anything(), jasmine.anything(), `Test Text`))
      it(`calls onEndOfFile once`, () => expect(onEndOfFile).toHaveBeenCalledTimes(1))
      it(`calls onLine before onEndOfFile`, () => expect(numberOfOnLineCallsAtTimeOfCallingOnEndOfFile).toEqual(1))
    })
  })
})

describe(`indenterCreate`, () => {
  it(`returns an object`, () => expect(get(`indenterCreate`)(`Test Context`, `Test On Line`, `Test On Indent`, `Test On Outdent`, `Test On Error`, `Test On End Of File`)).toEqual(jasmine.any(Object)))
  it(`returns stack, an array containing zero`, () => expect(get(`indenterCreate`)(`Test Context`, `Test On Line`, `Test On Indent`, `Test On Outdent`, `Test On Error`, `Test On End Of File`).stack).toEqual([0]))
  it(`returns indentationCharacter, null`, () => expect(get(`indenterCreate`)(`Test Context`, `Test On Line`, `Test On Indent`, `Test On Outdent`, `Test On Error`, `Test On End Of File`).indentationCharacter).toBeNull())
  it(`returns context, given`, () => expect(get(`indenterCreate`)(`Test Context`, `Test On Line`, `Test On Indent`, `Test On Outdent`, `Test On Error`, `Test On End Of File`).context).toEqual(`Test Context`))
  it(`returns onLine, given`, () => expect(get(`indenterCreate`)(`Test Context`, `Test On Line`, `Test On Indent`, `Test On Outdent`, `Test On Error`, `Test On End Of File`).onLine).toEqual(`Test On Line`))
  it(`returns onIndent, given`, () => expect(get(`indenterCreate`)(`Test Context`, `Test On Line`, `Test On Indent`, `Test On Outdent`, `Test On Error`, `Test On End Of File`).onIndent).toEqual(`Test On Indent`))
  it(`returns onOutdent, given`, () => expect(get(`indenterCreate`)(`Test Context`, `Test On Line`, `Test On Indent`, `Test On Outdent`, `Test On Error`, `Test On End Of File`).onOutdent).toEqual(`Test On Outdent`))
  it(`returns onError, given`, () => expect(get(`indenterCreate`)(`Test Context`, `Test On Line`, `Test On Indent`, `Test On Outdent`, `Test On Error`, `Test On End Of File`).onError).toEqual(`Test On Error`))
  it(`returns onEndOfFile, given`, () => expect(get(`indenterCreate`)(`Test Context`, `Test On Line`, `Test On Indent`, `Test On Outdent`, `Test On Error`, `Test On End Of File`).onEndOfFile).toEqual(`Test On End Of File`))
  it(`returns a new object every call`, () => expect(get(`indenterCreate`)(`Test Context`, `Test On Line`, `Test On Indent`, `Test On Outdent`, `Test On Error`, `Test On End Of File`)).not.toBe(get(`indenterCreate`)(`Test Context`, `Test On Line`, `Test On Indent`, `Test On Outdent`, `Test On Error`, `Test On End Of File`)))
  it(`returns a new stack every call`, () => expect(get(`indenterCreate`)(`Test Context`, `Test On Line`, `Test On Indent`, `Test On Outdent`, `Test On Error`, `Test On End Of File`).stack).not.toBe(get(`indenterCreate`)(`Test Context`, `Test On Line`, `Test On Indent`, `Test On Outdent`, `Test On Error`, `Test On End Of File`).stack))
  it(`returns the same value every call`, () => expect(get(`indenterCreate`)(`Test Context`, `Test On Line`, `Test On Indent`, `Test On Outdent`, `Test On Error`, `Test On End Of File`)).toEqual(get(`indenterCreate`)(`Test Context`, `Test On Line`, `Test On Indent`, `Test On Outdent`, `Test On Error`, `Test On End Of File`)))
})

describe(`indenterNormalizeName`, () => {
  const runEqual = (description, a, b) => it(description, () => expect(get(`indenterNormalizeName`)(a)).toEqual(get(`indenterNormalizeName`)(b)))
  const runInequal = (description, a, b) => it(description, () => expect(get(`indenterNormalizeName`)(a)).not.toEqual(get(`indenterNormalizeName`)(b)))
  runEqual(`normalizes case`, `Test Label`, `TeSt label`)
  runEqual(`normalizes white space type`, `Test\tLabel`, `Test Label`)
  runEqual(`normalizes white space quantity`, `Test      Label`, `Test Label`)
  runInequal(`does not normalize character choice`, `Test Label`, `Test Lebel`)
  runInequal(`does not normalize the existence of white space`, `Test Label`, `Test La bel`)
  it(`returns empty given null`, () => expect(get(`indenterNormalizeName`)(null)).toEqual(``))
})

describe(`indenterExtractIndentation`, () => {
  const run = (input, output) => describe(`given "${input}"`, () => it(`returns ${output}`, () => expect(get(`indenterExtractIndentation`)(input)).toEqual(output)))
  run(``, ``)
  run(` `, ` `)
  run(`\t`, `\t`)
  run(`   \t     \t  `, `   \t     \t  `)
  run(`a`, ``)
  run(` a`, ` `)
  run(`\ta`, `\t`)
  run(`   \t     \t  a`, `   \t     \t  `)
  run(`awdhk\tauwdh iyi`, ``)
  run(` awdhk\tauwdh iyi`, ` `)
  run(`\tawdhk\tauwdh iyi`, `\t`)
  run(`   \t     \t  awdhk auwdh iyi`, `   \t     \t  `)
  run(`awdhk\tauwdh iyi `, ``)
  run(`awdhk\tauwdh iyi\t`, ``)
  run(`awdhk\tauwdh iyi   \t     \t  `, ``)
  run(` awdhk\tauwdh iyi `, ` `)
  run(` awdhk\tauwdh iyi\t`, ` `)
  run(` awdhk\tauwdh iyi   \t     \t  `, ` `)
  run(`\tawdhk\tauwdh iyi `, `\t`)
  run(`\tawdhk\tauwdh iyi\t`, `\t`)
  run(`\tawdhk\tauwdh iyi   \t     \t  `, `\t`)
  run(`  \t \t  \t  awdhk\tauwdh iyi `, `  \t \t  \t  `)
  run(`  \t \t  \t  awdhk\tauwdh iyi\t`, `  \t \t  \t  `)
  run(`  \t \t  \t  awdhk\tauwdh iyi   \t     \t  `, `  \t \t  \t  `)
})

describe(`indenterExtractText`, () => {
  const run = (input, output) => describe(`given "${input}"`, () => it(`returns ${output}`, () => expect(get(`indenterExtractText`)(input)).toEqual(output)))
  run(``, ``)
  run(` `, ``)
  run(`\t`, ``)
  run(`   \t     \t  `, ``)
  run(`a`, `a`)
  run(` a`, `a`)
  run(`\ta`, `a`)
  run(`   \t     \t  a`, `a`)
  run(`awdhk\tauwdh iyi`, `awdhk\tauwdh iyi`)
  run(` awdhk\tauwdh iyi`, `awdhk\tauwdh iyi`)
  run(`\tawdhk\tauwdh iyi`, `awdhk\tauwdh iyi`)
  run(`   \t     \t  awdhk\tauwdh iyi`, `awdhk\tauwdh iyi`)
  run(`awdhk\tauwdh iyi `, `awdhk\tauwdh iyi`)
  run(`awdhk\tauwdh iyi\t`, `awdhk\tauwdh iyi`)
  run(`awdhk\tauwdh iyi   \t     \t  `, `awdhk\tauwdh iyi`)
  run(` awdhk\tauwdh iyi `, `awdhk\tauwdh iyi`)
  run(` awdhk\tauwdh iyi\t`, `awdhk\tauwdh iyi`)
  run(` awdhk\tauwdh iyi   \t     \t  `, `awdhk\tauwdh iyi`)
  run(`\tawdhk\tauwdh iyi `, `awdhk\tauwdh iyi`)
  run(`\tawdhk\tauwdh iyi\t`, `awdhk\tauwdh iyi`)
  run(`\tawdhk\tauwdh iyi   \t     \t  `, `awdhk\tauwdh iyi`)
  run(`  \t \t  \t  awdhk\tauwdh iyi `, `awdhk\tauwdh iyi`)
  run(`  \t \t  \t  awdhk\tauwdh iyi\t`, `awdhk\tauwdh iyi`)
  run(`  \t \t  \t  awdhk\tauwdh iyi   \t     \t  `, `awdhk\tauwdh iyi`)
})

describe(`indenterCheckWhiteSpace`, () => {
  const run = (input, output) => describe(`given "${input}"`, () => it(`returns ${output}`, () => expect(get(`indenterCheckWhiteSpace`)(input)).toEqual(output)))
  run(``, `none`)
  run(`a`, `a`)
  run(`aa`, `a`)
  run(`aaa`, `a`)
  run(`aaaa`, `a`)
  run(`ab`, `inconsistent`)
  run(`baa`, `inconsistent`)
  run(`aba`, `inconsistent`)
  run(`aab`, `inconsistent`)
  run(`abc`, `inconsistent`)
})

describe(`indenterLine`, () => {
  const indenterExtractIndentation = setSpy(`indenterExtractIndentation`)
  indenterExtractIndentation.and.returnValue(`Test Extracted Indentation`)
  const indenterExtractText = setSpy(`indenterExtractText`)
  indenterExtractText.and.returnValue(`Test Extracted Text`)
  const indenterMatch = setSpy(`indenterMatch`)
  indenterMatch.and.returnValue(`Test Matched Statement`)
  const indenterCheckWhiteSpace = setSpy(`indenterCheckWhiteSpace`)
  let numberOfOnIndentCallsAtTimeOfCallingOnLine
  let numberOfOnOutdentCallsAtTimeOfCallingOnLine
  const onLine = jasmine.createSpy(`onLine`)
  onLine.and.callFake(() => {
    numberOfOnIndentCallsAtTimeOfCallingOnLine = onIndent.calls.count()
    numberOfOnOutdentCallsAtTimeOfCallingOnLine = onOutdent.calls.count()
  })
  const onIndent = jasmine.createSpy(`onIndent`)
  const onOutdent = jasmine.createSpy(`onOutdent`)
  const onError = jasmine.createSpy(`onError`)
  const onEndOfFile = jasmine.createSpy(`onEndOfFile`)
  afterEach(() => {
    indenterExtractIndentation.calls.reset()
    indenterExtractText.calls.reset()
    indenterMatch.calls.reset()
    indenterCheckWhiteSpace.calls.reset()
    onLine.calls.reset()
    onIndent.calls.reset()
    onOutdent.calls.reset()
    onError.calls.reset()
    onEndOfFile.calls.reset()
  })
  let indenter
  beforeEach(() => indenter = {
    stack: [0],
    context: `Test Context`,
    onLine,
    onIndent,
    onOutdent,
    onError,
    onEndOfFile
  })

  describe(`when no indentation character has been found`, () => {
    beforeEach(() => indenter.indentationCharacter = null)

    describe(`when the given line does not have indentation`, () => {
      beforeEach(() => {
        indenterCheckWhiteSpace.and.returnValue(`none`)
        get(`indenterLine`)(indenter, 3897, `Test Line Text`)
      })
      it(`does not change stack`, () => expect(indenter.stack).toEqual([0]))
      it(`does not change indentationCharacter`, () => expect(indenter.indentationCharacter).toBeNull())
      it(`does not change context`, () => expect(indenter.context).toEqual(`Test Context`))
      it(`does not change onLine`, () => expect(indenter.onLine).toBe(onLine))
      it(`does not change onIndent`, () => expect(indenter.onIndent).toBe(onIndent))
      it(`does not change onOutdent`, () => expect(indenter.onOutdent).toBe(onOutdent))
      it(`does not change onError`, () => expect(indenter.onError).toBe(onError))
      it(`extracts indentation once`, () => expect(indenterExtractIndentation).toHaveBeenCalledTimes(1))
      it(`extracts indentation from the line text`, () => expect(indenterExtractIndentation).toHaveBeenCalledWith(`Test Line Text`))
      it(`extracts text once`, () => expect(indenterExtractText).toHaveBeenCalledTimes(1))
      it(`extracts text from the line text`, () => expect(indenterExtractText).toHaveBeenCalledWith(`Test Line Text`))
      it(`matches statements once`, () => expect(indenterMatch).toHaveBeenCalledTimes(1))
      it(`matches against the extracted text`, () => expect(indenterMatch).toHaveBeenCalledWith(`Test Extracted Text`))
      it(`checks white space once`, () => expect(indenterCheckWhiteSpace).toHaveBeenCalledTimes(1))
      it(`checks white space in the extracted indentation`, () => expect(indenterCheckWhiteSpace).toHaveBeenCalledWith(`Test Extracted Indentation`))
      it(`calls onLine once`, () => expect(onLine).toHaveBeenCalledTimes(1))
      it(`calls onLine with the context`, () => expect(onLine).toHaveBeenCalledWith(`Test Context`, jasmine.anything(), jasmine.anything(), jasmine.anything()))
      it(`calls onLine with the line number`, () => expect(onLine).toHaveBeenCalledWith(jasmine.anything(), 3897, jasmine.anything(), jasmine.anything()))
      it(`calls onLine with the extracted text`, () => expect(onLine).toHaveBeenCalledWith(jasmine.anything(), jasmine.anything(), `Test Extracted Text`, jasmine.anything()))
      it(`calls onLine with the matched statement`, () => expect(onLine).toHaveBeenCalledWith(jasmine.anything(), jasmine.anything(), jasmine.anything(), `Test Matched Statement`))
      it(`does not call onIndent`, () => expect(onIndent).not.toHaveBeenCalled())
      it(`does not call onOutdent`, () => expect(onOutdent).not.toHaveBeenCalled())
      it(`does not call onError`, () => expect(onError).not.toHaveBeenCalled())
      it(`does not call onEndOfFile`, () => expect(onEndOfFile).not.toHaveBeenCalled())
    })

    describe(`when the given line has inconsistent indentation`, () => {
      beforeEach(() => {
        indenterCheckWhiteSpace.and.returnValue(`inconsistent`)
        get(`indenterLine`)(indenter, 3897, `Test Line Text`)
      })
      it(`does not change stack`, () => expect(indenter.stack).toEqual([0]))
      it(`does not change indentationCharacter`, () => expect(indenter.indentationCharacter).toBeNull())
      it(`does not change context`, () => expect(indenter.context).toEqual(`Test Context`))
      it(`does not change onLine`, () => expect(indenter.onLine).toBe(onLine))
      it(`does not change onIndent`, () => expect(indenter.onIndent).toBe(onIndent))
      it(`does not change onOutdent`, () => expect(indenter.onOutdent).toBe(onOutdent))
      it(`does not change onError`, () => expect(indenter.onError).toBe(onError))
      it(`extracts indentation once`, () => expect(indenterExtractIndentation).toHaveBeenCalledTimes(1))
      it(`extracts indentation from the line text`, () => expect(indenterExtractIndentation).toHaveBeenCalledWith(`Test Line Text`))
      it(`does not extract text`, () => expect(indenterExtractText).not.toHaveBeenCalled())
      it(`does not match statements`, () => expect(indenterMatch).not.toHaveBeenCalled())
      it(`checks white space once`, () => expect(indenterCheckWhiteSpace).toHaveBeenCalledTimes(1))
      it(`checks white space in the extracted indentation`, () => expect(indenterCheckWhiteSpace).toHaveBeenCalledWith(`Test Extracted Indentation`))
      it(`does not call onLine`, () => expect(onLine).not.toHaveBeenCalled())
      it(`does not call onIndent`, () => expect(onIndent).not.toHaveBeenCalled())
      it(`does not call onOutdent`, () => expect(onOutdent).not.toHaveBeenCalled())
      it(`calls onError once`, () => expect(onError).toHaveBeenCalledTimes(1))
      it(`calls onError with the context`, () => expect(onError).toHaveBeenCalledWith(`Test Context`, jasmine.anything(), jasmine.anything()))
      it(`calls onError with the line number`, () => expect(onError).toHaveBeenCalledWith(jasmine.anything(), 3897, jasmine.anything()))
      it(`calls onError with a message informing the user that they cannot mix indentation white space`, () => expect(onError).toHaveBeenCalledWith(jasmine.anything(), jasmine.anything(), `Inconsistent indenting white space characters; it is likely that both spaces and tabs are being used to indent within the same file`))
      it(`does not call onEndOfFile`, () => expect(onEndOfFile).not.toHaveBeenCalled())
    })

    describe(`when the given line has indentation`, () => {
      beforeEach(() => {
        indenterCheckWhiteSpace.and.returnValue(`Test Indentation Character A`)
        get(`indenterLine`)(indenter, 3897, `Test Line Text`)
      })
      it(`appends the length of the indentation to the stack`, () => expect(indenter.stack).toEqual([0, 26]))
      it(`sets indentationCharacter to the indentation character`, () => expect(indenter.indentationCharacter).toEqual(`Test Indentation Character A`))
      it(`does not change context`, () => expect(indenter.context).toEqual(`Test Context`))
      it(`does not change onLine`, () => expect(indenter.onLine).toBe(onLine))
      it(`does not change onIndent`, () => expect(indenter.onIndent).toBe(onIndent))
      it(`does not change onOutdent`, () => expect(indenter.onOutdent).toBe(onOutdent))
      it(`does not change onError`, () => expect(indenter.onError).toBe(onError))
      it(`extracts indentation once`, () => expect(indenterExtractIndentation).toHaveBeenCalledTimes(1))
      it(`extracts indentation from the line text`, () => expect(indenterExtractIndentation).toHaveBeenCalledWith(`Test Line Text`))
      it(`extracts text once`, () => expect(indenterExtractText).toHaveBeenCalledTimes(1))
      it(`extracts text from the line text`, () => expect(indenterExtractText).toHaveBeenCalledWith(`Test Line Text`))
      it(`matches statements once`, () => expect(indenterMatch).toHaveBeenCalledTimes(1))
      it(`matches against the extracted text`, () => expect(indenterMatch).toHaveBeenCalledWith(`Test Extracted Text`))
      it(`checks white space once`, () => expect(indenterCheckWhiteSpace).toHaveBeenCalledTimes(1))
      it(`checks white space in the extracted indentation`, () => expect(indenterCheckWhiteSpace).toHaveBeenCalledWith(`Test Extracted Indentation`))
      it(`calls onLine once`, () => expect(onLine).toHaveBeenCalledTimes(1))
      it(`calls onLine with the context`, () => expect(onLine).toHaveBeenCalledWith(`Test Context`, jasmine.anything(), jasmine.anything(), jasmine.anything()))
      it(`calls onLine with the line number`, () => expect(onLine).toHaveBeenCalledWith(jasmine.anything(), 3897, jasmine.anything(), jasmine.anything()))
      it(`calls onLine with the extracted text`, () => expect(onLine).toHaveBeenCalledWith(jasmine.anything(), jasmine.anything(), `Test Extracted Text`, jasmine.anything()))
      it(`calls onLine with the matched statement`, () => expect(onLine).toHaveBeenCalledWith(jasmine.anything(), jasmine.anything(), jasmine.anything(), `Test Matched Statement`))
      it(`calls onIndent once`, () => expect(onIndent).toHaveBeenCalledTimes(1))
      it(`calls onIndent with the context`, () => expect(onIndent).toHaveBeenCalledWith(`Test Context`, jasmine.anything()))
      it(`calls onIndent with the line number`, () => expect(onIndent).toHaveBeenCalledWith(jasmine.anything(), 3897))
      it(`calls onIndent before onLine`, () => expect(numberOfOnIndentCallsAtTimeOfCallingOnLine).toEqual(1))
      it(`does not call onOutdent`, () => expect(onOutdent).not.toHaveBeenCalled())
      it(`does not call onError`, () => expect(onError).not.toHaveBeenCalled())
      it(`does not call onEndOfFile`, () => expect(onEndOfFile).not.toHaveBeenCalled())
    })
  })

  describe(`when an indentation character has been found`, () => {
    beforeEach(() => indenter.indentationCharacter = `Test Indentation Character A`)

    describe(`when the given line does not have indentation`, () => {
      beforeEach(() => {
        indenter.stack = [0, 14, 27, 36, 42]
        indenterCheckWhiteSpace.and.returnValue(`none`)
        get(`indenterLine`)(indenter, 3897, `Test Line Text`)
      })
      it(`clears the stack`, () => expect(indenter.stack).toEqual([0]))
      it(`does not change the indentation character`, () => expect(indenter.indentationCharacter).toEqual(`Test Indentation Character A`))
      it(`does not change context`, () => expect(indenter.context).toEqual(`Test Context`))
      it(`does not change onLine`, () => expect(indenter.onLine).toBe(onLine))
      it(`does not change onIndent`, () => expect(indenter.onIndent).toBe(onIndent))
      it(`does not change onOutdent`, () => expect(indenter.onOutdent).toBe(onOutdent))
      it(`does not change onError`, () => expect(indenter.onError).toBe(onError))
      it(`extracts indentation once`, () => expect(indenterExtractIndentation).toHaveBeenCalledTimes(1))
      it(`extracts indentation from the line text`, () => expect(indenterExtractIndentation).toHaveBeenCalledWith(`Test Line Text`))
      it(`extracts text once`, () => expect(indenterExtractText).toHaveBeenCalledTimes(1))
      it(`extracts text from the line text`, () => expect(indenterExtractText).toHaveBeenCalledWith(`Test Line Text`))
      it(`matches statements once`, () => expect(indenterMatch).toHaveBeenCalledTimes(1))
      it(`matches against the extracted text`, () => expect(indenterMatch).toHaveBeenCalledWith(`Test Extracted Text`))
      it(`checks white space once`, () => expect(indenterCheckWhiteSpace).toHaveBeenCalledTimes(1))
      it(`checks white space in the extracted indentation`, () => expect(indenterCheckWhiteSpace).toHaveBeenCalledWith(`Test Extracted Indentation`))
      it(`calls onLine once`, () => expect(onLine).toHaveBeenCalledTimes(1))
      it(`calls onLine with the context`, () => expect(onLine).toHaveBeenCalledWith(`Test Context`, jasmine.anything(), jasmine.anything(), jasmine.anything()))
      it(`calls onLine with the line number`, () => expect(onLine).toHaveBeenCalledWith(jasmine.anything(), 3897, jasmine.anything(), jasmine.anything()))
      it(`calls onLine with the extracted text`, () => expect(onLine).toHaveBeenCalledWith(jasmine.anything(), jasmine.anything(), `Test Extracted Text`, jasmine.anything()))
      it(`calls onLine with the matched statement`, () => expect(onLine).toHaveBeenCalledWith(jasmine.anything(), jasmine.anything(), jasmine.anything(), `Test Matched Statement`))
      it(`does not call onIndent`, () => expect(onIndent).not.toHaveBeenCalled())
      it(`calls onOutdent once per eliminated stack level`, () => expect(onOutdent).toHaveBeenCalledTimes(4))
      it(`calls onOutdent with the context`, () => {
        expect(onOutdent.calls.argsFor(0)).toEqual([`Test Context`, jasmine.anything()])
        expect(onOutdent.calls.argsFor(1)).toEqual([`Test Context`, jasmine.anything()])
        expect(onOutdent.calls.argsFor(2)).toEqual([`Test Context`, jasmine.anything()])
        expect(onOutdent.calls.argsFor(3)).toEqual([`Test Context`, jasmine.anything()])
      })
      it(`calls onOutdent with the line number`, () => {
        expect(onOutdent.calls.argsFor(0)).toEqual([jasmine.anything(), 3897])
        expect(onOutdent.calls.argsFor(1)).toEqual([jasmine.anything(), 3897])
        expect(onOutdent.calls.argsFor(2)).toEqual([jasmine.anything(), 3897])
        expect(onOutdent.calls.argsFor(3)).toEqual([jasmine.anything(), 3897])
      })
      it(`calls onOutdent before onLine`, () => expect(numberOfOnOutdentCallsAtTimeOfCallingOnLine).toEqual(4))
      it(`does not call onError`, () => expect(onError).not.toHaveBeenCalled())
      it(`does not call onEndOfFile`, () => expect(onEndOfFile).not.toHaveBeenCalled())
    })

    describe(`when the given line has inconsistent indentation`, () => {
      beforeEach(() => {
        indenter.stack = [0, 14, 27, 36, 42]
        indenterCheckWhiteSpace.and.returnValue(`inconsistent`)
        get(`indenterLine`)(indenter, 3897, `Test Line Text`)
      })
      it(`does not change stack`, () => expect(indenter.stack).toEqual([0, 14, 27, 36, 42]))
      it(`does not change indentationCharacter`, () => expect(indenter.indentationCharacter).toEqual(`Test Indentation Character A`))
      it(`does not change context`, () => expect(indenter.context).toEqual(`Test Context`))
      it(`does not change onLine`, () => expect(indenter.onLine).toBe(onLine))
      it(`does not change onIndent`, () => expect(indenter.onIndent).toBe(onIndent))
      it(`does not change onOutdent`, () => expect(indenter.onOutdent).toBe(onOutdent))
      it(`does not change onError`, () => expect(indenter.onError).toBe(onError))
      it(`extracts indentation once`, () => expect(indenterExtractIndentation).toHaveBeenCalledTimes(1))
      it(`extracts indentation from the line text`, () => expect(indenterExtractIndentation).toHaveBeenCalledWith(`Test Line Text`))
      it(`does not extract text`, () => expect(indenterExtractText).not.toHaveBeenCalled())
      it(`does not match statements`, () => expect(indenterMatch).not.toHaveBeenCalled())
      it(`checks white space once`, () => expect(indenterCheckWhiteSpace).toHaveBeenCalledTimes(1))
      it(`checks white space in the extracted indentation`, () => expect(indenterCheckWhiteSpace).toHaveBeenCalledWith(`Test Extracted Indentation`))
      it(`does not call onLine`, () => expect(onLine).not.toHaveBeenCalled())
      it(`does not call onIndent`, () => expect(onIndent).not.toHaveBeenCalled())
      it(`does not call onOutdent`, () => expect(onOutdent).not.toHaveBeenCalled())
      it(`calls onError once`, () => expect(onError).toHaveBeenCalledTimes(1))
      it(`calls onError with the context`, () => expect(onError).toHaveBeenCalledWith(`Test Context`, jasmine.anything(), jasmine.anything()))
      it(`calls onError with the line number`, () => expect(onError).toHaveBeenCalledWith(jasmine.anything(), 3897, jasmine.anything()))
      it(`calls onError with a message informing the user that they cannot mix indentation white space`, () => expect(onError).toHaveBeenCalledWith(jasmine.anything(), jasmine.anything(), `Inconsistent indenting white space characters; it is likely that both spaces and tabs are being used to indent within the same file`))
      it(`does not call onEndOfFile`, () => expect(onEndOfFile).not.toHaveBeenCalled())
    })

    describe(`when the given line has indentation inconsistent with the rest of the file`, () => {
      beforeEach(() => indenterCheckWhiteSpace.and.returnValue(`Test Indentation Character B`))
      describe(`when the indentation is greater than the top of the stack`, () => {
        beforeEach(() => {
          indenter.stack = [0, 4, 6, 10, 24]
          get(`indenterLine`)(indenter, 3897, `Test Line Text`)
        })
        it(`does not change stack`, () => expect(indenter.stack).toEqual([0, 4, 6, 10, 24]))
        it(`does not change indentationCharacter`, () => expect(indenter.indentationCharacter).toEqual(`Test Indentation Character A`))
        it(`does not change context`, () => expect(indenter.context).toEqual(`Test Context`))
        it(`does not change onLine`, () => expect(indenter.onLine).toBe(onLine))
        it(`does not change onIndent`, () => expect(indenter.onIndent).toBe(onIndent))
        it(`does not change onOutdent`, () => expect(indenter.onOutdent).toBe(onOutdent))
        it(`does not change onError`, () => expect(indenter.onError).toBe(onError))
        it(`extracts indentation once`, () => expect(indenterExtractIndentation).toHaveBeenCalledTimes(1))
        it(`extracts indentation from the line text`, () => expect(indenterExtractIndentation).toHaveBeenCalledWith(`Test Line Text`))
        it(`does not extract text`, () => expect(indenterExtractText).not.toHaveBeenCalled())
        it(`does not match statements`, () => expect(indenterMatch).not.toHaveBeenCalled())
        it(`checks white space once`, () => expect(indenterCheckWhiteSpace).toHaveBeenCalledTimes(1))
        it(`checks white space in the extracted indentation`, () => expect(indenterCheckWhiteSpace).toHaveBeenCalledWith(`Test Extracted Indentation`))
        it(`does not call onLine`, () => expect(onLine).not.toHaveBeenCalled())
        it(`does not call onIndent`, () => expect(onIndent).not.toHaveBeenCalled())
        it(`does not call onOutdent`, () => expect(onOutdent).not.toHaveBeenCalled())
        it(`calls onError once`, () => expect(onError).toHaveBeenCalledTimes(1))
        it(`calls onError with the context`, () => expect(onError).toHaveBeenCalledWith(`Test Context`, jasmine.anything(), jasmine.anything()))
        it(`calls onError with the line number`, () => expect(onError).toHaveBeenCalledWith(jasmine.anything(), 3897, jasmine.anything()))
        it(`calls onError with a message informing the user that they cannot mix indentation white space`, () => expect(onError).toHaveBeenCalledWith(jasmine.anything(), jasmine.anything(), `Inconsistent indenting white space characters; it is likely that both spaces and tabs are being used to indent within the same file`))
        it(`does not call onEndOfFile`, () => expect(onEndOfFile).not.toHaveBeenCalled())
      })

      describe(`when the indentation matches the top of the stack`, () => {
        beforeEach(() => {
          indenter.stack = [0, 4, 6, 10, 26]
          get(`indenterLine`)(indenter, 3897, `Test Line Text`)
        })
        it(`does not change stack`, () => expect(indenter.stack).toEqual([0, 4, 6, 10, 26]))
        it(`does not change indentationCharacter`, () => expect(indenter.indentationCharacter).toEqual(`Test Indentation Character A`))
        it(`does not change context`, () => expect(indenter.context).toEqual(`Test Context`))
        it(`does not change onLine`, () => expect(indenter.onLine).toBe(onLine))
        it(`does not change onIndent`, () => expect(indenter.onIndent).toBe(onIndent))
        it(`does not change onOutdent`, () => expect(indenter.onOutdent).toBe(onOutdent))
        it(`does not change onError`, () => expect(indenter.onError).toBe(onError))
        it(`extracts indentation once`, () => expect(indenterExtractIndentation).toHaveBeenCalledTimes(1))
        it(`extracts indentation from the line text`, () => expect(indenterExtractIndentation).toHaveBeenCalledWith(`Test Line Text`))
        it(`does not extract text`, () => expect(indenterExtractText).not.toHaveBeenCalled())
        it(`does not match statements`, () => expect(indenterMatch).not.toHaveBeenCalled())
        it(`checks white space once`, () => expect(indenterCheckWhiteSpace).toHaveBeenCalledTimes(1))
        it(`checks white space in the extracted indentation`, () => expect(indenterCheckWhiteSpace).toHaveBeenCalledWith(`Test Extracted Indentation`))
        it(`does not call onLine`, () => expect(onLine).not.toHaveBeenCalled())
        it(`does not call onIndent`, () => expect(onIndent).not.toHaveBeenCalled())
        it(`does not call onOutdent`, () => expect(onOutdent).not.toHaveBeenCalled())
        it(`calls onError once`, () => expect(onError).toHaveBeenCalledTimes(1))
        it(`calls onError with the context`, () => expect(onError).toHaveBeenCalledWith(`Test Context`, jasmine.anything(), jasmine.anything()))
        it(`calls onError with the line number`, () => expect(onError).toHaveBeenCalledWith(jasmine.anything(), 3897, jasmine.anything()))
        it(`calls onError with a message informing the user that they cannot mix indentation white space`, () => expect(onError).toHaveBeenCalledWith(jasmine.anything(), jasmine.anything(), `Inconsistent indenting white space characters; it is likely that both spaces and tabs are being used to indent within the same file`))
        it(`does not call onEndOfFile`, () => expect(onEndOfFile).not.toHaveBeenCalled())
      })

      describe(`when the indentation is between the top and first under on the stack`, () => {
        beforeEach(() => {
          indenter.stack = [0, 4, 6, 10, 28]
          get(`indenterLine`)(indenter, 3897, `Test Line Text`)
        })
        it(`does not change stack`, () => expect(indenter.stack).toEqual([0, 4, 6, 10, 28]))
        it(`does not change indentationCharacter`, () => expect(indenter.indentationCharacter).toEqual(`Test Indentation Character A`))
        it(`does not change context`, () => expect(indenter.context).toEqual(`Test Context`))
        it(`does not change onLine`, () => expect(indenter.onLine).toBe(onLine))
        it(`does not change onIndent`, () => expect(indenter.onIndent).toBe(onIndent))
        it(`does not change onOutdent`, () => expect(indenter.onOutdent).toBe(onOutdent))
        it(`does not change onError`, () => expect(indenter.onError).toBe(onError))
        it(`extracts indentation once`, () => expect(indenterExtractIndentation).toHaveBeenCalledTimes(1))
        it(`extracts indentation from the line text`, () => expect(indenterExtractIndentation).toHaveBeenCalledWith(`Test Line Text`))
        it(`does not extract text`, () => expect(indenterExtractText).not.toHaveBeenCalled())
        it(`does not match statements`, () => expect(indenterMatch).not.toHaveBeenCalled())
        it(`checks white space once`, () => expect(indenterCheckWhiteSpace).toHaveBeenCalledTimes(1))
        it(`checks white space in the extracted indentation`, () => expect(indenterCheckWhiteSpace).toHaveBeenCalledWith(`Test Extracted Indentation`))
        it(`does not call onLine`, () => expect(onLine).not.toHaveBeenCalled())
        it(`does not call onIndent`, () => expect(onIndent).not.toHaveBeenCalled())
        it(`does not call onOutdent`, () => expect(onOutdent).not.toHaveBeenCalled())
        it(`calls onError once`, () => expect(onError).toHaveBeenCalledTimes(1))
        it(`calls onError with the context`, () => expect(onError).toHaveBeenCalledWith(`Test Context`, jasmine.anything(), jasmine.anything()))
        it(`calls onError with the line number`, () => expect(onError).toHaveBeenCalledWith(jasmine.anything(), 3897, jasmine.anything()))
        it(`calls onError with a message informing the user that they cannot mix indentation white space`, () => expect(onError).toHaveBeenCalledWith(jasmine.anything(), jasmine.anything(), `Inconsistent indenting white space characters; it is likely that both spaces and tabs are being used to indent within the same file`))
        it(`does not call onEndOfFile`, () => expect(onEndOfFile).not.toHaveBeenCalled())
      })

      describe(`when the indentation is the first under on the stack`, () => {
        beforeEach(() => {
          indenter.stack = [0, 4, 6, 26, 31]
          get(`indenterLine`)(indenter, 3897, `Test Line Text`)
        })
        it(`does not change stack`, () => expect(indenter.stack).toEqual([0, 4, 6, 26, 31]))
        it(`does not change indentationCharacter`, () => expect(indenter.indentationCharacter).toEqual(`Test Indentation Character A`))
        it(`does not change context`, () => expect(indenter.context).toEqual(`Test Context`))
        it(`does not change onLine`, () => expect(indenter.onLine).toBe(onLine))
        it(`does not change onIndent`, () => expect(indenter.onIndent).toBe(onIndent))
        it(`does not change onOutdent`, () => expect(indenter.onOutdent).toBe(onOutdent))
        it(`does not change onError`, () => expect(indenter.onError).toBe(onError))
        it(`extracts indentation once`, () => expect(indenterExtractIndentation).toHaveBeenCalledTimes(1))
        it(`extracts indentation from the line text`, () => expect(indenterExtractIndentation).toHaveBeenCalledWith(`Test Line Text`))
        it(`does not extract text`, () => expect(indenterExtractText).not.toHaveBeenCalled())
        it(`does not match statements`, () => expect(indenterMatch).not.toHaveBeenCalled())
        it(`checks white space once`, () => expect(indenterCheckWhiteSpace).toHaveBeenCalledTimes(1))
        it(`checks white space in the extracted indentation`, () => expect(indenterCheckWhiteSpace).toHaveBeenCalledWith(`Test Extracted Indentation`))
        it(`does not call onLine`, () => expect(onLine).not.toHaveBeenCalled())
        it(`does not call onIndent`, () => expect(onIndent).not.toHaveBeenCalled())
        it(`does not call onOutdent`, () => expect(onOutdent).not.toHaveBeenCalled())
        it(`calls onError once`, () => expect(onError).toHaveBeenCalledTimes(1))
        it(`calls onError with the context`, () => expect(onError).toHaveBeenCalledWith(`Test Context`, jasmine.anything(), jasmine.anything()))
        it(`calls onError with the line number`, () => expect(onError).toHaveBeenCalledWith(jasmine.anything(), 3897, jasmine.anything()))
        it(`calls onError with a message informing the user that they cannot mix indentation white space`, () => expect(onError).toHaveBeenCalledWith(jasmine.anything(), jasmine.anything(), `Inconsistent indenting white space characters; it is likely that both spaces and tabs are being used to indent within the same file`))
        it(`does not call onEndOfFile`, () => expect(onEndOfFile).not.toHaveBeenCalled())
      })

      describe(`when the indentation is between the first and second under on the stack`, () => {
        beforeEach(() => {
          indenter.stack = [0, 4, 6, 29, 31]
          get(`indenterLine`)(indenter, 3897, `Test Line Text`)
        })
        it(`does not change stack`, () => expect(indenter.stack).toEqual([0, 4, 6, 29, 31]))
        it(`does not change indentationCharacter`, () => expect(indenter.indentationCharacter).toEqual(`Test Indentation Character A`))
        it(`does not change context`, () => expect(indenter.context).toEqual(`Test Context`))
        it(`does not change onLine`, () => expect(indenter.onLine).toBe(onLine))
        it(`does not change onIndent`, () => expect(indenter.onIndent).toBe(onIndent))
        it(`does not change onOutdent`, () => expect(indenter.onOutdent).toBe(onOutdent))
        it(`does not change onError`, () => expect(indenter.onError).toBe(onError))
        it(`extracts indentation once`, () => expect(indenterExtractIndentation).toHaveBeenCalledTimes(1))
        it(`extracts indentation from the line text`, () => expect(indenterExtractIndentation).toHaveBeenCalledWith(`Test Line Text`))
        it(`does not extract text`, () => expect(indenterExtractText).not.toHaveBeenCalled())
        it(`does not match statements`, () => expect(indenterMatch).not.toHaveBeenCalled())
        it(`checks white space once`, () => expect(indenterCheckWhiteSpace).toHaveBeenCalledTimes(1))
        it(`checks white space in the extracted indentation`, () => expect(indenterCheckWhiteSpace).toHaveBeenCalledWith(`Test Extracted Indentation`))
        it(`does not call onLine`, () => expect(onLine).not.toHaveBeenCalled())
        it(`does not call onIndent`, () => expect(onIndent).not.toHaveBeenCalled())
        it(`does not call onOutdent`, () => expect(onOutdent).not.toHaveBeenCalled())
        it(`calls onError once`, () => expect(onError).toHaveBeenCalledTimes(1))
        it(`calls onError with the context`, () => expect(onError).toHaveBeenCalledWith(`Test Context`, jasmine.anything(), jasmine.anything()))
        it(`calls onError with the line number`, () => expect(onError).toHaveBeenCalledWith(jasmine.anything(), 3897, jasmine.anything()))
        it(`calls onError with a message informing the user that they cannot mix indentation white space`, () => expect(onError).toHaveBeenCalledWith(jasmine.anything(), jasmine.anything(), `Inconsistent indenting white space characters; it is likely that both spaces and tabs are being used to indent within the same file`))
        it(`does not call onEndOfFile`, () => expect(onEndOfFile).not.toHaveBeenCalled())
      })

      describe(`when the indentation is the second under on the stack`, () => {
        beforeEach(() => {
          indenter.stack = [0, 4, 26, 29, 31]
          get(`indenterLine`)(indenter, 3897, `Test Line Text`)
        })
        it(`does not change stack`, () => expect(indenter.stack).toEqual([0, 4, 26, 29, 31]))
        it(`does not change indentationCharacter`, () => expect(indenter.indentationCharacter).toEqual(`Test Indentation Character A`))
        it(`does not change context`, () => expect(indenter.context).toEqual(`Test Context`))
        it(`does not change onLine`, () => expect(indenter.onLine).toBe(onLine))
        it(`does not change onIndent`, () => expect(indenter.onIndent).toBe(onIndent))
        it(`does not change onOutdent`, () => expect(indenter.onOutdent).toBe(onOutdent))
        it(`does not change onError`, () => expect(indenter.onError).toBe(onError))
        it(`extracts indentation once`, () => expect(indenterExtractIndentation).toHaveBeenCalledTimes(1))
        it(`extracts indentation from the line text`, () => expect(indenterExtractIndentation).toHaveBeenCalledWith(`Test Line Text`))
        it(`does not extract text`, () => expect(indenterExtractText).not.toHaveBeenCalled())
        it(`does not match statements`, () => expect(indenterMatch).not.toHaveBeenCalled())
        it(`checks white space once`, () => expect(indenterCheckWhiteSpace).toHaveBeenCalledTimes(1))
        it(`checks white space in the extracted indentation`, () => expect(indenterCheckWhiteSpace).toHaveBeenCalledWith(`Test Extracted Indentation`))
        it(`does not call onLine`, () => expect(onLine).not.toHaveBeenCalled())
        it(`does not call onIndent`, () => expect(onIndent).not.toHaveBeenCalled())
        it(`does not call onOutdent`, () => expect(onOutdent).not.toHaveBeenCalled())
        it(`calls onError once`, () => expect(onError).toHaveBeenCalledTimes(1))
        it(`calls onError with the context`, () => expect(onError).toHaveBeenCalledWith(`Test Context`, jasmine.anything(), jasmine.anything()))
        it(`calls onError with the line number`, () => expect(onError).toHaveBeenCalledWith(jasmine.anything(), 3897, jasmine.anything()))
        it(`calls onError with a message informing the user that they cannot mix indentation white space`, () => expect(onError).toHaveBeenCalledWith(jasmine.anything(), jasmine.anything(), `Inconsistent indenting white space characters; it is likely that both spaces and tabs are being used to indent within the same file`))
        it(`does not call onEndOfFile`, () => expect(onEndOfFile).not.toHaveBeenCalled())
      })
    })

    describe(`when the given line has indentation`, () => {
      beforeEach(() => {
        indenterCheckWhiteSpace.and.returnValue(`Test Indentation Character A`)
      })

      describe(`when the indentation is greater than the top of the stack`, () => {
        beforeEach(() => {
          indenter.stack = [0, 4, 6, 10, 24]
          get(`indenterLine`)(indenter, 3897, `Test Line Text`)
        })
        it(`appends the length of the indentation to the stack`, () => expect(indenter.stack).toEqual([0, 4, 6, 10, 24, 26]))
        it(`sets indentationCharacter to the indentation character`, () => expect(indenter.indentationCharacter).toEqual(`Test Indentation Character A`))
        it(`does not change context`, () => expect(indenter.context).toEqual(`Test Context`))
        it(`does not change onLine`, () => expect(indenter.onLine).toBe(onLine))
        it(`does not change onIndent`, () => expect(indenter.onIndent).toBe(onIndent))
        it(`does not change onOutdent`, () => expect(indenter.onOutdent).toBe(onOutdent))
        it(`does not change onError`, () => expect(indenter.onError).toBe(onError))
        it(`extracts indentation once`, () => expect(indenterExtractIndentation).toHaveBeenCalledTimes(1))
        it(`extracts indentation from the line text`, () => expect(indenterExtractIndentation).toHaveBeenCalledWith(`Test Line Text`))
        it(`extracts text once`, () => expect(indenterExtractText).toHaveBeenCalledTimes(1))
        it(`extracts text from the line text`, () => expect(indenterExtractText).toHaveBeenCalledWith(`Test Line Text`))
        it(`matches statements once`, () => expect(indenterMatch).toHaveBeenCalledTimes(1))
        it(`matches against the extracted text`, () => expect(indenterMatch).toHaveBeenCalledWith(`Test Extracted Text`))
        it(`checks white space once`, () => expect(indenterCheckWhiteSpace).toHaveBeenCalledTimes(1))
        it(`checks white space in the extracted indentation`, () => expect(indenterCheckWhiteSpace).toHaveBeenCalledWith(`Test Extracted Indentation`))
        it(`calls onLine once`, () => expect(onLine).toHaveBeenCalledTimes(1))
        it(`calls onLine with the context`, () => expect(onLine).toHaveBeenCalledWith(`Test Context`, jasmine.anything(), jasmine.anything(), jasmine.anything()))
        it(`calls onLine with the line number`, () => expect(onLine).toHaveBeenCalledWith(jasmine.anything(), 3897, jasmine.anything(), jasmine.anything()))
        it(`calls onLine with the extracted text`, () => expect(onLine).toHaveBeenCalledWith(jasmine.anything(), jasmine.anything(), `Test Extracted Text`, jasmine.anything()))
        it(`calls onLine with the matched statement`, () => expect(onLine).toHaveBeenCalledWith(jasmine.anything(), jasmine.anything(), jasmine.anything(), `Test Matched Statement`))
        it(`calls onIndent once`, () => expect(onIndent).toHaveBeenCalledTimes(1))
        it(`calls onIndent with the context`, () => expect(onIndent).toHaveBeenCalledWith(`Test Context`, jasmine.anything()))
        it(`calls onIndent with the line number`, () => expect(onIndent).toHaveBeenCalledWith(jasmine.anything(), 3897))
        it(`calls onIndent before onLine`, () => expect(numberOfOnIndentCallsAtTimeOfCallingOnLine).toEqual(1))
        it(`does not call onOutdent`, () => expect(onOutdent).not.toHaveBeenCalled())
        it(`does not call onError`, () => expect(onError).not.toHaveBeenCalled())
        it(`does not call onEndOfFile`, () => expect(onEndOfFile).not.toHaveBeenCalled())
      })

      describe(`when the indentation matches the top of the stack`, () => {
        beforeEach(() => {
          indenter.stack = [0, 4, 6, 10, 26]
          get(`indenterLine`)(indenter, 3897, `Test Line Text`)
        })
        it(`does not change the stack`, () => expect(indenter.stack).toEqual([0, 4, 6, 10, 26]))
        it(`sets indentationCharacter to the indentation character`, () => expect(indenter.indentationCharacter).toEqual(`Test Indentation Character A`))
        it(`does not change context`, () => expect(indenter.context).toEqual(`Test Context`))
        it(`does not change onLine`, () => expect(indenter.onLine).toBe(onLine))
        it(`does not change onIndent`, () => expect(indenter.onIndent).toBe(onIndent))
        it(`does not change onOutdent`, () => expect(indenter.onOutdent).toBe(onOutdent))
        it(`does not change onError`, () => expect(indenter.onError).toBe(onError))
        it(`extracts indentation once`, () => expect(indenterExtractIndentation).toHaveBeenCalledTimes(1))
        it(`extracts indentation from the line text`, () => expect(indenterExtractIndentation).toHaveBeenCalledWith(`Test Line Text`))
        it(`extracts text once`, () => expect(indenterExtractText).toHaveBeenCalledTimes(1))
        it(`extracts text from the line text`, () => expect(indenterExtractText).toHaveBeenCalledWith(`Test Line Text`))
        it(`matches statements once`, () => expect(indenterMatch).toHaveBeenCalledTimes(1))
        it(`matches against the extracted text`, () => expect(indenterMatch).toHaveBeenCalledWith(`Test Extracted Text`))
        it(`checks white space once`, () => expect(indenterCheckWhiteSpace).toHaveBeenCalledTimes(1))
        it(`checks white space in the extracted indentation`, () => expect(indenterCheckWhiteSpace).toHaveBeenCalledWith(`Test Extracted Indentation`))
        it(`calls onLine once`, () => expect(onLine).toHaveBeenCalledTimes(1))
        it(`calls onLine with the context`, () => expect(onLine).toHaveBeenCalledWith(`Test Context`, jasmine.anything(), jasmine.anything(), jasmine.anything()))
        it(`calls onLine with the line number`, () => expect(onLine).toHaveBeenCalledWith(jasmine.anything(), 3897, jasmine.anything(), jasmine.anything()))
        it(`calls onLine with the extracted text`, () => expect(onLine).toHaveBeenCalledWith(jasmine.anything(), jasmine.anything(), `Test Extracted Text`, jasmine.anything()))
        it(`calls onLine with the matched statement`, () => expect(onLine).toHaveBeenCalledWith(jasmine.anything(), jasmine.anything(), jasmine.anything(), `Test Matched Statement`))
        it(`does not call onIndent`, () => expect(onIndent).not.toHaveBeenCalled())
        it(`does not call onOutdent`, () => expect(onOutdent).not.toHaveBeenCalled())
        it(`does not call onError`, () => expect(onError).not.toHaveBeenCalled())
        it(`does not call onEndOfFile`, () => expect(onEndOfFile).not.toHaveBeenCalled())
      })

      describe(`when the indentation is between the top and first under on the stack`, () => {
        beforeEach(() => {
          indenter.stack = [0, 4, 6, 10, 28]
          get(`indenterLine`)(indenter, 3897, `Test Line Text`)
        })
        it(`does not change stack`, () => expect(indenter.stack).toEqual([0, 4, 6, 10, 28]))
        it(`does not change indentationCharacter`, () => expect(indenter.indentationCharacter).toEqual(`Test Indentation Character A`))
        it(`does not change context`, () => expect(indenter.context).toEqual(`Test Context`))
        it(`does not change onLine`, () => expect(indenter.onLine).toBe(onLine))
        it(`does not change onIndent`, () => expect(indenter.onIndent).toBe(onIndent))
        it(`does not change onOutdent`, () => expect(indenter.onOutdent).toBe(onOutdent))
        it(`does not change onError`, () => expect(indenter.onError).toBe(onError))
        it(`extracts indentation once`, () => expect(indenterExtractIndentation).toHaveBeenCalledTimes(1))
        it(`extracts indentation from the line text`, () => expect(indenterExtractIndentation).toHaveBeenCalledWith(`Test Line Text`))
        it(`does not extract text`, () => expect(indenterExtractText).not.toHaveBeenCalled())
        it(`does not match statements`, () => expect(indenterMatch).not.toHaveBeenCalled())
        it(`checks white space once`, () => expect(indenterCheckWhiteSpace).toHaveBeenCalledTimes(1))
        it(`checks white space in the extracted indentation`, () => expect(indenterCheckWhiteSpace).toHaveBeenCalledWith(`Test Extracted Indentation`))
        it(`does not call onLine`, () => expect(onLine).not.toHaveBeenCalled())
        it(`does not call onIndent`, () => expect(onIndent).not.toHaveBeenCalled())
        it(`does not call onOutdent`, () => expect(onOutdent).not.toHaveBeenCalled())
        it(`calls onError once`, () => expect(onError).toHaveBeenCalledTimes(1))
        it(`calls onError with the context`, () => expect(onError).toHaveBeenCalledWith(`Test Context`, jasmine.anything(), jasmine.anything()))
        it(`calls onError with the line number`, () => expect(onError).toHaveBeenCalledWith(jasmine.anything(), 3897, jasmine.anything()))
        it(`calls onError with a message informing the user that they cannot outdent to a level they have not previously indented to`, () => expect(onError).toHaveBeenCalledWith(jasmine.anything(), jasmine.anything(), `Outdent to level not previously indented to`))
        it(`does not call onEndOfFile`, () => expect(onEndOfFile).not.toHaveBeenCalled())
      })

      describe(`when the indentation is the first under on the stack`, () => {
        beforeEach(() => {
          indenter.stack = [0, 4, 6, 26, 31]
          get(`indenterLine`)(indenter, 3897, `Test Line Text`)
        })
        it(`removes the last item on the stack`, () => expect(indenter.stack).toEqual([0, 4, 6, 26]))
        it(`sets indentationCharacter to the indentation character`, () => expect(indenter.indentationCharacter).toEqual(`Test Indentation Character A`))
        it(`does not change context`, () => expect(indenter.context).toEqual(`Test Context`))
        it(`does not change onLine`, () => expect(indenter.onLine).toBe(onLine))
        it(`does not change onIndent`, () => expect(indenter.onIndent).toBe(onIndent))
        it(`does not change onOutdent`, () => expect(indenter.onOutdent).toBe(onOutdent))
        it(`does not change onError`, () => expect(indenter.onError).toBe(onError))
        it(`extracts indentation once`, () => expect(indenterExtractIndentation).toHaveBeenCalledTimes(1))
        it(`extracts indentation from the line text`, () => expect(indenterExtractIndentation).toHaveBeenCalledWith(`Test Line Text`))
        it(`extracts text once`, () => expect(indenterExtractText).toHaveBeenCalledTimes(1))
        it(`extracts text from the line text`, () => expect(indenterExtractText).toHaveBeenCalledWith(`Test Line Text`))
        it(`matches statements once`, () => expect(indenterMatch).toHaveBeenCalledTimes(1))
        it(`matches against the extracted text`, () => expect(indenterMatch).toHaveBeenCalledWith(`Test Extracted Text`))
        it(`checks white space once`, () => expect(indenterCheckWhiteSpace).toHaveBeenCalledTimes(1))
        it(`checks white space in the extracted indentation`, () => expect(indenterCheckWhiteSpace).toHaveBeenCalledWith(`Test Extracted Indentation`))
        it(`calls onLine once`, () => expect(onLine).toHaveBeenCalledTimes(1))
        it(`calls onLine with the context`, () => expect(onLine).toHaveBeenCalledWith(`Test Context`, jasmine.anything(), jasmine.anything(), jasmine.anything()))
        it(`calls onLine with the line number`, () => expect(onLine).toHaveBeenCalledWith(jasmine.anything(), 3897, jasmine.anything(), jasmine.anything()))
        it(`calls onLine with the extracted text`, () => expect(onLine).toHaveBeenCalledWith(jasmine.anything(), jasmine.anything(), `Test Extracted Text`, jasmine.anything()))
        it(`calls onLine with the matched statement`, () => expect(onLine).toHaveBeenCalledWith(jasmine.anything(), jasmine.anything(), jasmine.anything(), `Test Matched Statement`))
        it(`does not call onIndent`, () => expect(onIndent).not.toHaveBeenCalled())
        it(`calls onOutdent once`, () => expect(onOutdent).toHaveBeenCalledTimes(1))
        it(`calls onOutdent with the context`, () => expect(onOutdent).toHaveBeenCalledWith(`Test Context`, jasmine.anything()))
        it(`calls onOutdent with the line number`, () => expect(onOutdent).toHaveBeenCalledWith(jasmine.anything(), 3897))
        it(`calls onOutdent before onLine`, () => expect(numberOfOnOutdentCallsAtTimeOfCallingOnLine).toEqual(1))
        it(`does not call onError`, () => expect(onError).not.toHaveBeenCalled())
        it(`does not call onEndOfFile`, () => expect(onEndOfFile).not.toHaveBeenCalled())
      })

      describe(`when the indentation is between the first and second under on the stack`, () => {
        beforeEach(() => {
          indenter.stack = [0, 4, 6, 29, 31]
          get(`indenterLine`)(indenter, 3897, `Test Line Text`)
        })
        it(`does not change stack`, () => expect(indenter.stack).toEqual([0, 4, 6, 29, 31]))
        it(`does not change indentationCharacter`, () => expect(indenter.indentationCharacter).toEqual(`Test Indentation Character A`))
        it(`does not change context`, () => expect(indenter.context).toEqual(`Test Context`))
        it(`does not change onLine`, () => expect(indenter.onLine).toBe(onLine))
        it(`does not change onIndent`, () => expect(indenter.onIndent).toBe(onIndent))
        it(`does not change onOutdent`, () => expect(indenter.onOutdent).toBe(onOutdent))
        it(`does not change onError`, () => expect(indenter.onError).toBe(onError))
        it(`extracts indentation once`, () => expect(indenterExtractIndentation).toHaveBeenCalledTimes(1))
        it(`extracts indentation from the line text`, () => expect(indenterExtractIndentation).toHaveBeenCalledWith(`Test Line Text`))
        it(`does not extract text`, () => expect(indenterExtractText).not.toHaveBeenCalled())
        it(`does not match statements`, () => expect(indenterMatch).not.toHaveBeenCalled())
        it(`checks white space once`, () => expect(indenterCheckWhiteSpace).toHaveBeenCalledTimes(1))
        it(`checks white space in the extracted indentation`, () => expect(indenterCheckWhiteSpace).toHaveBeenCalledWith(`Test Extracted Indentation`))
        it(`does not call onLine`, () => expect(onLine).not.toHaveBeenCalled())
        it(`does not call onIndent`, () => expect(onIndent).not.toHaveBeenCalled())
        it(`does not call onOutdent`, () => expect(onOutdent).not.toHaveBeenCalled())
        it(`calls onError once`, () => expect(onError).toHaveBeenCalledTimes(1))
        it(`calls onError with the context`, () => expect(onError).toHaveBeenCalledWith(`Test Context`, jasmine.anything(), jasmine.anything()))
        it(`calls onError with the line number`, () => expect(onError).toHaveBeenCalledWith(jasmine.anything(), 3897, jasmine.anything()))
        it(`calls onError with a message informing the user that they cannot outdent to a level they have not previously indented to`, () => expect(onError).toHaveBeenCalledWith(jasmine.anything(), jasmine.anything(), `Outdent to level not previously indented to`))
        it(`does not call onEndOfFile`, () => expect(onEndOfFile).not.toHaveBeenCalled())
      })

      describe(`when the indentation is the second under on the stack`, () => {
        beforeEach(() => {
          indenter.stack = [0, 4, 26, 29, 31]
          get(`indenterLine`)(indenter, 3897, `Test Line Text`)
        })
        it(`removes the subsequent items on the stack`, () => expect(indenter.stack).toEqual([0, 4, 26]))
        it(`sets indentationCharacter to the indentation character`, () => expect(indenter.indentationCharacter).toEqual(`Test Indentation Character A`))
        it(`does not change context`, () => expect(indenter.context).toEqual(`Test Context`))
        it(`does not change onLine`, () => expect(indenter.onLine).toBe(onLine))
        it(`does not change onIndent`, () => expect(indenter.onIndent).toBe(onIndent))
        it(`does not change onOutdent`, () => expect(indenter.onOutdent).toBe(onOutdent))
        it(`does not change onError`, () => expect(indenter.onError).toBe(onError))
        it(`extracts indentation once`, () => expect(indenterExtractIndentation).toHaveBeenCalledTimes(1))
        it(`extracts indentation from the line text`, () => expect(indenterExtractIndentation).toHaveBeenCalledWith(`Test Line Text`))
        it(`extracts text once`, () => expect(indenterExtractText).toHaveBeenCalledTimes(1))
        it(`extracts text from the line text`, () => expect(indenterExtractText).toHaveBeenCalledWith(`Test Line Text`))
        it(`matches statements once`, () => expect(indenterMatch).toHaveBeenCalledTimes(1))
        it(`matches against the extracted text`, () => expect(indenterMatch).toHaveBeenCalledWith(`Test Extracted Text`))
        it(`checks white space once`, () => expect(indenterCheckWhiteSpace).toHaveBeenCalledTimes(1))
        it(`checks white space in the extracted indentation`, () => expect(indenterCheckWhiteSpace).toHaveBeenCalledWith(`Test Extracted Indentation`))
        it(`calls onLine once`, () => expect(onLine).toHaveBeenCalledTimes(1))
        it(`calls onLine with the context`, () => expect(onLine).toHaveBeenCalledWith(`Test Context`, jasmine.anything(), jasmine.anything(), jasmine.anything()))
        it(`calls onLine with the line number`, () => expect(onLine).toHaveBeenCalledWith(jasmine.anything(), 3897, jasmine.anything(), jasmine.anything()))
        it(`calls onLine with the extracted text`, () => expect(onLine).toHaveBeenCalledWith(jasmine.anything(), jasmine.anything(), `Test Extracted Text`, jasmine.anything()))
        it(`calls onLine with the matched statement`, () => expect(onLine).toHaveBeenCalledWith(jasmine.anything(), jasmine.anything(), jasmine.anything(), `Test Matched Statement`))
        it(`does not call onIndent`, () => expect(onIndent).not.toHaveBeenCalled())
        it(`calls onOutdent twice`, () => expect(onOutdent).toHaveBeenCalledTimes(2))
        it(`calls onOutdent with the context`, () => expect(onOutdent).toHaveBeenCalledWith(`Test Context`, jasmine.anything()))
        it(`calls onOutdent with the line number`, () => expect(onOutdent).toHaveBeenCalledWith(jasmine.anything(), 3897))
        it(`calls onOutdent before onLine`, () => expect(numberOfOnOutdentCallsAtTimeOfCallingOnLine).toEqual(2))
        it(`does not call onError`, () => expect(onError).not.toHaveBeenCalled())
        it(`does not call onEndOfFile`, () => expect(onEndOfFile).not.toHaveBeenCalled())
      })
    })
  })
})

describe(`indenterMatch`, () => {
  const indenterNormalizeName = setSpy(`indenterNormalizeName`)
  afterEach(() => indenterNormalizeName.calls.reset())
  const run = (input, normalizeNameMappings, output) => describe(`given ${JSON.stringify(input)}`, () => {
    let result
    beforeEach(() => {
      indenterNormalizeName.and.callFake(name => normalizeNameMappings[name])
      result = get(`indenterMatch`)(input)
    })
    it(`normalizes the expected number of names`, () => expect(indenterNormalizeName).toHaveBeenCalledTimes(Object.keys(normalizeNameMappings).length))
    Object.keys(normalizeNameMappings).forEach(nameMapping => it(`normalizes the name ${JSON.stringify(nameMapping)}`, () => expect(indenterNormalizeName).toHaveBeenCalledWith(nameMapping)))
    it(`returns the expected "${JSON.stringify(output)}"`, () => expect(result).toEqual(output))
  })
  describe(`free text`, () => {
    run(`:`, {}, null)
    run(`a`, {}, null)
    run(`An example of a sentence which does not match anything.`, {}, null)
  })
  describe(`line`, () => {
    run(`a:`, {}, null)
    run(`a    \t   \t :`, {}, null)
    run(`aBC:`, {}, null)
    run(`aBC    \t   \t :`, {}, null)
    run(`a  \t  \t \t  AnD \t \t\t \t \tb:`, {}, null)
    run(`a  \t  \t \t  AnD \t \t\t \t \tb    \t   \t :`, {}, null)
    run(`aBC  \t  \t \t  AnD \t \t\t \t \td:`, {}, null)
    run(`aBC  \t  \t \t  AnD \t \t\t \t \td    \t   \t :`, {}, null)
    run(`a  \t  \t \t  AnD \t \t\t \t \tBCd:`, {}, null)
    run(`a  \t  \t \t  AnD \t \t\t \t \tBCd    \t   \t :`, {}, null)
    run(`a   \t \t \t  b  \t  \t \t  AnD \t \t\t \t \tc:`, {}, null)
    run(`a   \t \t \t  b  \t  \t \t  AnD \t \t\t \t \tc    \t   \t :`, {}, null)
    run(`aBC   \t \t \t  d  \t  \t \t  AnD \t \t\t \t \te:`, {}, null)
    run(`aBC   \t \t \t  d  \t  \t \t  AnD \t \t\t \t \te    \t   \t :`, {}, null)
    run(`a   \t \t \t  BCd  \t  \t \t  AnD \t \t\t \t \te:`, {}, null)
    run(`a   \t \t \t  BCd  \t  \t \t  AnD \t \t\t \t \te    \t   \t :`, {}, null)
    run(`a   \t \t \t  b  \t  \t \t  AnD \t \t\t \t \tcDE:`, {}, null)
    run(`a   \t \t \t  b  \t  \t \t  AnD \t \t\t \t \tcDE    \t   \t :`, {}, null)
    run(`a \t \t \t   \t\t b \t \tc    \t AnD \t\t d:`, {}, null)
    run(`a \t \t \t   \t\t b \t \tc    \t AnD \t\t d \t \t\t \t :`, {}, null)
    run(`aBC \t \t \t   \t\t d \t \te    \t AnD \t\t f:`, {}, null)
    run(`aBC \t \t \t   \t\t d \t \te    \t AnD \t\t f \t \t\t \t :`, {}, null)
    run(`a \t \t \t   \t\t BCd \t \te    \t AnD \t\t f:`, {}, null)
    run(`a \t \t \t   \t\t BCd \t \te    \t AnD \t\t f \t \t\t \t :`, {}, null)
    run(`a \t \t \t   \t\t b \t \tcDE    \t AnD \t\t f:`, {}, null)
    run(`a \t \t \t   \t\t b \t \tcDE    \t AnD \t\t f \t \t\t \t :`, {}, null)
    run(`a \t \t \t   \t\t b \t \tc    \t AnD \t\t dEf:`, {}, null)
    run(`a \t \t \t   \t\t b \t \tc    \t AnD \t\t dEf \t \t\t \t :`, {}, null)
  })
  describe(`line with emote`, () => {
    run(`a(b):`, {}, null)
    run(`a \t \t\t (b):`, {}, null)
    run(`a( \t \t\t b):`, {}, null)
    run(`a(b   \t\t \t ):`, {}, null)
    run(`a(b)   \t\t \t    \t   \t :`, {}, null)
    run(`aBC(d):`, {}, null)
    run(`aBC \t \t\t (d):`, {}, null)
    run(`aBC( \t \t\t d):`, {}, null)
    run(`aBC(d   \t\t \t ):`, {}, null)
    run(`aBC(d)   \t\t \t    \t   \t :`, {}, null)
    run(`a(BCd):`, {}, null)
    run(`a \t \t\t (BCd):`, {}, null)
    run(`a( \t \t\t BCd):`, {}, null)
    run(`a(BCd   \t\t \t ):`, {}, null)
    run(`a(BCd)   \t\t \t    \t   \t :`, {}, null)
    run(`a  \t  \t \t  AnD \t \t\t \t \tb(c):`, {}, null)
    run(`a  \t  \t \t  AnD \t \t\t \t \tb \t \t\t (c):`, {}, null)
    run(`a  \t  \t \t  AnD \t \t\t \t \tb( \t \t\t c):`, {}, null)
    run(`a  \t  \t \t  AnD \t \t\t \t \tb(c   \t\t \t ):`, {}, null)
    run(`a  \t  \t \t  AnD \t \t\t \t \tb(c)   \t\t \t    \t   \t :`, {}, null)
    run(`aBC  \t  \t \t  AnD \t \t\t \t \td(e):`, {}, null)
    run(`aBC  \t  \t \t  AnD \t \t\t \t \td \t \t\t (e):`, {}, null)
    run(`aBC  \t  \t \t  AnD \t \t\t \t \td( \t \t\t e):`, {}, null)
    run(`aBC  \t  \t \t  AnD \t \t\t \t \td(e   \t\t \t ):`, {}, null)
    run(`aBC  \t  \t \t  AnD \t \t\t \t \td(e)   \t\t \t    \t   \t :`, {}, null)
    run(`a  \t  \t \t  AnD \t \t\t \t \tBCd(e):`, {}, null)
    run(`a  \t  \t \t  AnD \t \t\t \t \tBCd \t \t\t (e):`, {}, null)
    run(`a  \t  \t \t  AnD \t \t\t \t \tBCd( \t \t\t e):`, {}, null)
    run(`a  \t  \t \t  AnD \t \t\t \t \tBCd(e   \t\t \t ):`, {}, null)
    run(`a  \t  \t \t  AnD \t \t\t \t \tBCd(e)   \t\t \t    \t   \t :`, {}, null)
    run(`a  \t  \t \t  AnD \t \t\t \t \tb(cDE):`, {}, null)
    run(`a  \t  \t \t  AnD \t \t\t \t \tb \t \t\t (cDE):`, {}, null)
    run(`a  \t  \t \t  AnD \t \t\t \t \tb( \t \t\t cDE):`, {}, null)
    run(`a  \t  \t \t  AnD \t \t\t \t \tb(cDE   \t\t \t ):`, {}, null)
    run(`a  \t  \t \t  AnD \t \t\t \t \tb(cDE)   \t\t \t    \t   \t :`, {}, null)
    run(`a   \t \t \t  b  \t  \t \t  AnD \t \t\t \t \tc(d):`, {}, null)
    run(`a   \t \t \t  b  \t  \t \t  AnD \t \t\t \t \tc \t \t\t (d):`, {}, null)
    run(`a   \t \t \t  b  \t  \t \t  AnD \t \t\t \t \tc( \t \t\t d):`, {}, null)
    run(`a   \t \t \t  b  \t  \t \t  AnD \t \t\t \t \tc(d   \t\t \t ):`, {}, null)
    run(`a   \t \t \t  b  \t  \t \t  AnD \t \t\t \t \tc(d)   \t\t \t    \t   \t :`, {}, null)
    run(`aBC   \t \t \t  d  \t  \t \t  AnD \t \t\t \t \te(f):`, {}, null)
    run(`aBC   \t \t \t  d  \t  \t \t  AnD \t \t\t \t \te \t \t\t (f):`, {}, null)
    run(`aBC   \t \t \t  d  \t  \t \t  AnD \t \t\t \t \te( \t \t\t f):`, {}, null)
    run(`aBC   \t \t \t  d  \t  \t \t  AnD \t \t\t \t \te(f   \t\t \t ):`, {}, null)
    run(`aBC   \t \t \t  d  \t  \t \t  AnD \t \t\t \t \te(f)   \t\t \t    \t   \t :`, {}, null)
    run(`a   \t \t \t  BCd  \t  \t \t  AnD \t \t\t \t \te(f):`, {}, null)
    run(`a   \t \t \t  BCd  \t  \t \t  AnD \t \t\t \t \te \t \t\t (f):`, {}, null)
    run(`a   \t \t \t  BCd  \t  \t \t  AnD \t \t\t \t \te( \t \t\t f):`, {}, null)
    run(`a   \t \t \t  BCd  \t  \t \t  AnD \t \t\t \t \te(f   \t\t \t ):`, {}, null)
    run(`a   \t \t \t  BCd  \t  \t \t  AnD \t \t\t \t \te(f)   \t\t \t    \t   \t :`, {}, null)
    run(`a   \t \t \t  b  \t  \t \t  AnD \t \t\t \t \tcDE(f):`, {}, null)
    run(`a   \t \t \t  b  \t  \t \t  AnD \t \t\t \t \tcDE \t \t\t (f):`, {}, null)
    run(`a   \t \t \t  b  \t  \t \t  AnD \t \t\t \t \tcDE( \t \t\t f):`, {}, null)
    run(`a   \t \t \t  b  \t  \t \t  AnD \t \t\t \t \tcDE(f   \t\t \t ):`, {}, null)
    run(`a   \t \t \t  b  \t  \t \t  AnD \t \t\t \t \tcDE(f)   \t\t \t    \t   \t :`, {}, null)
    run(`a   \t \t \t  b  \t  \t \t  AnD \t \t\t \t \tc(dEf):`, {}, null)
    run(`a   \t \t \t  b  \t  \t \t  AnD \t \t\t \t \tc \t \t\t (dEf):`, {}, null)
    run(`a   \t \t \t  b  \t  \t \t  AnD \t \t\t \t \tc( \t \t\t dEf):`, {}, null)
    run(`a   \t \t \t  b  \t  \t \t  AnD \t \t\t \t \tc(dEf   \t\t \t ):`, {}, null)
    run(`a   \t \t \t  b  \t  \t \t  AnD \t \t\t \t \tc(dEf)   \t\t \t    \t   \t :`, {}, null)
    run(`a  \t  \t \t  b \t c\t\t AnD \t  \td(e):`, {}, null)
    run(`a  \t  \t \t  b \t c\t\t AnD \t  \td   \t\t \t(e):`, {}, null)
    run(`a  \t  \t \t  b \t c\t\t AnD \t  \td(  \t\t \t e):`, {}, null)
    run(`a  \t  \t \t  b \t c\t\t AnD \t  \td(e \t\t     ):`, {}, null)
    run(`a  \t  \t \t  b \t c\t\t AnD \t  \td(e)  \t \t   :`, {}, null)
    run(`aBC  \t  \t \t  d \t e\t\t AnD \t  \tf(g):`, {}, null)
    run(`aBC  \t  \t \t  d \t e\t\t AnD \t  \tf   \t\t \t(g):`, {}, null)
    run(`aBC  \t  \t \t  d \t e\t\t AnD \t  \tf(  \t\t \t g):`, {}, null)
    run(`aBC  \t  \t \t  d \t e\t\t AnD \t  \tf(g \t\t     ):`, {}, null)
    run(`aBC  \t  \t \t  d \t e\t\t AnD \t  \tf(g)  \t \t   :`, {}, null)
    run(`a  \t  \t \t  BCd \t e\t\t AnD \t  \tf(g):`, {}, null)
    run(`a  \t  \t \t  BCd \t e\t\t AnD \t  \tf   \t\t \t(g):`, {}, null)
    run(`a  \t  \t \t  BCd \t e\t\t AnD \t  \tf(  \t\t \t g):`, {}, null)
    run(`a  \t  \t \t  BCd \t e\t\t AnD \t  \tf(g \t\t     ):`, {}, null)
    run(`a  \t  \t \t  BCd \t e\t\t AnD \t  \tf(g)  \t \t   :`, {}, null)
    run(`a  \t  \t \t  b \t cDE\t\t AnD \t  \tf(g):`, {}, null)
    run(`a  \t  \t \t  b \t cDE\t\t AnD \t  \tf   \t\t \t(g):`, {}, null)
    run(`a  \t  \t \t  b \t cDE\t\t AnD \t  \tf(  \t\t \t g):`, {}, null)
    run(`a  \t  \t \t  b \t cDE\t\t AnD \t  \tf(g \t\t     ):`, {}, null)
    run(`a  \t  \t \t  b \t cDE\t\t AnD \t  \tf(g)  \t \t   :`, {}, null)
    run(`a  \t  \t \t  b \t c\t\t AnD \t  \tdEf(g):`, {}, null)
    run(`a  \t  \t \t  b \t c\t\t AnD \t  \tdEf   \t\t \t(g):`, {}, null)
    run(`a  \t  \t \t  b \t c\t\t AnD \t  \tdEf(  \t\t \t g):`, {}, null)
    run(`a  \t  \t \t  b \t c\t\t AnD \t  \tdEf(g \t\t     ):`, {}, null)
    run(`a  \t  \t \t  b \t c\t\t AnD \t  \tdEf(g)  \t \t   :`, {}, null)
    run(`a  \t  \t \t  b \t c\t\t AnD \t  \td(eFG):`, {}, null)
    run(`a  \t  \t \t  b \t c\t\t AnD \t  \td   \t\t \t(eFG):`, {}, null)
    run(`a  \t  \t \t  b \t c\t\t AnD \t  \td(  \t\t \t eFG):`, {}, null)
    run(`a  \t  \t \t  b \t c\t\t AnD \t  \td(eFG \t\t     ):`, {}, null)
    run(`a  \t  \t \t  b \t c\t\t AnD \t  \td(eFG)  \t \t   :`, {}, null)
  })
  describe(`line with text`, () => {
    run(`a:b`, { a: `Test Normalized Name A` }, { lineWithText: { characters: [{ name: `a`, normalizedName: `Test Normalized Name A` }], text: `b` } })
    run(`a  \t \t :b`, { a: `Test Normalized Name A` }, { lineWithText: { characters: [{ name: `a`, normalizedName: `Test Normalized Name A` }], text: `b` } })
    run(`a:\t\t  \t b`, { a: `Test Normalized Name A` }, { lineWithText: { characters: [{ name: `a`, normalizedName: `Test Normalized Name A` }], text: `b` } })
    run(`aBC:d`, { aBC: `Test Normalized Name A` }, { lineWithText: { characters: [{ name: `aBC`, normalizedName: `Test Normalized Name A` }], text: `d` } })
    run(`aBC  \t \t :d`, { aBC: `Test Normalized Name A` }, { lineWithText: { characters: [{ name: `aBC`, normalizedName: `Test Normalized Name A` }], text: `d` } })
    run(`aBC:\t\t  \t d`, { aBC: `Test Normalized Name A` }, { lineWithText: { characters: [{ name: `aBC`, normalizedName: `Test Normalized Name A` }], text: `d` } })
    run(`a:BCd \t \t \t\t eFGh \t : \t \t\t ijKL`, { a: `Test Normalized Name A` }, { lineWithText: { characters: [{ name: `a`, normalizedName: `Test Normalized Name A` }], text: `BCd \t \t \t\t eFGh \t : \t \t\t ijKL` } })
    run(`a  \t \t :BCd \t \t \t\t eFGh \t : \t \t\t ijKL`, { a: `Test Normalized Name A` }, { lineWithText: { characters: [{ name: `a`, normalizedName: `Test Normalized Name A` }], text: `BCd \t \t \t\t eFGh \t : \t \t\t ijKL` } })
    run(`a:\t\t  \t BCd \t \t \t\t eFGh \t : \t \t\t ijKL`, { a: `Test Normalized Name A` }, { lineWithText: { characters: [{ name: `a`, normalizedName: `Test Normalized Name A` }], text: `BCd \t \t \t\t eFGh \t : \t \t\t ijKL` } })
    run(`a \t\t  \t AnD \t \t  b:c`, { a: `Test Normalized Name A`, b: `Test Normalized Name B` }, { lineWithText: { characters: [{ name: `a`, normalizedName: `Test Normalized Name A` }, { name: `b`, normalizedName: `Test Normalized Name B` }], text: `c` } })
    run(`a \t\t  \t AnD \t \t  b\t   \t\t:c`, { a: `Test Normalized Name A`, b: `Test Normalized Name B` }, { lineWithText: { characters: [{ name: `a`, normalizedName: `Test Normalized Name A` }, { name: `b`, normalizedName: `Test Normalized Name B` }], text: `c` } })
    run(`a \t\t  \t AnD \t \t  b: \t\t  \t c`, { a: `Test Normalized Name A`, b: `Test Normalized Name B` }, { lineWithText: { characters: [{ name: `a`, normalizedName: `Test Normalized Name A` }, { name: `b`, normalizedName: `Test Normalized Name B` }], text: `c` } })
    run(`aBC \t\t  \t AnD \t \t  d:e`, { aBC: `Test Normalized Name A`, d: `Test Normalized Name B` }, { lineWithText: { characters: [{ name: `aBC`, normalizedName: `Test Normalized Name A` }, { name: `d`, normalizedName: `Test Normalized Name B` }], text: `e` } })
    run(`aBC \t\t  \t AnD \t \t  d\t   \t\t:e`, { aBC: `Test Normalized Name A`, d: `Test Normalized Name B` }, { lineWithText: { characters: [{ name: `aBC`, normalizedName: `Test Normalized Name A` }, { name: `d`, normalizedName: `Test Normalized Name B` }], text: `e` } })
    run(`aBC \t\t  \t AnD \t \t  d: \t\t  \t e`, { aBC: `Test Normalized Name A`, d: `Test Normalized Name B` }, { lineWithText: { characters: [{ name: `aBC`, normalizedName: `Test Normalized Name A` }, { name: `d`, normalizedName: `Test Normalized Name B` }], text: `e` } })
    run(`a \t\t  \t AnD \t \t  BCd:e`, { a: `Test Normalized Name A`, BCd: `Test Normalized Name B` }, { lineWithText: { characters: [{ name: `a`, normalizedName: `Test Normalized Name A` }, { name: `BCd`, normalizedName: `Test Normalized Name B` }], text: `e` } })
    run(`a \t\t  \t AnD \t \t  BCd\t   \t\t:e`, { a: `Test Normalized Name A`, BCd: `Test Normalized Name B` }, { lineWithText: { characters: [{ name: `a`, normalizedName: `Test Normalized Name A` }, { name: `BCd`, normalizedName: `Test Normalized Name B` }], text: `e` } })
    run(`a \t\t  \t AnD \t \t  BCd: \t\t  \t e`, { a: `Test Normalized Name A`, BCd: `Test Normalized Name B` }, { lineWithText: { characters: [{ name: `a`, normalizedName: `Test Normalized Name A` }, { name: `BCd`, normalizedName: `Test Normalized Name B` }], text: `e` } })
    run(`a \t\t  \t AnD \t \t  b:cDE \t \t \t\t FGhi \t : \t \t\t jkl`, { a: `Test Normalized Name A`, b: `Test Normalized Name B` }, { lineWithText: { characters: [{ name: `a`, normalizedName: `Test Normalized Name A` }, { name: `b`, normalizedName: `Test Normalized Name B` }], text: `cDE \t \t \t\t FGhi \t : \t \t\t jkl` } })
    run(`a \t\t  \t AnD \t \t  b\t   \t\t:cDE \t \t \t\t FGhi \t : \t \t\t jkl`, { a: `Test Normalized Name A`, b: `Test Normalized Name B` }, { lineWithText: { characters: [{ name: `a`, normalizedName: `Test Normalized Name A` }, { name: `b`, normalizedName: `Test Normalized Name B` }], text: `cDE \t \t \t\t FGhi \t : \t \t\t jkl` } })
    run(`a \t\t  \t AnD \t \t  b: \t\t  \t cDE \t \t \t\t FGhi \t : \t \t\t jkl`, { a: `Test Normalized Name A`, b: `Test Normalized Name B` }, { lineWithText: { characters: [{ name: `a`, normalizedName: `Test Normalized Name A` }, { name: `b`, normalizedName: `Test Normalized Name B` }], text: `cDE \t \t \t\t FGhi \t : \t \t\t jkl` } })
    run(`a \t\t  \t b   \t\t AnD  \t \t \t c:d`, { a: `Test Normalized Name A`, b: `Test Normalized Name B`, c: `Test Normalized Name C` }, { lineWithText: { characters: [{ name: `a`, normalizedName: `Test Normalized Name A` }, { name: `b`, normalizedName: `Test Normalized Name B` }, { name: `c`, normalizedName: `Test Normalized Name C` }], text: `d` } })
    run(`a \t\t  \t b   \t\t AnD  \t \t \t c  \t \t :d`, { a: `Test Normalized Name A`, b: `Test Normalized Name B`, c: `Test Normalized Name C` }, { lineWithText: { characters: [{ name: `a`, normalizedName: `Test Normalized Name A` }, { name: `b`, normalizedName: `Test Normalized Name B` }, { name: `c`, normalizedName: `Test Normalized Name C` }], text: `d` } })
    run(`a \t\t  \t b   \t\t AnD  \t \t \t c:  \t \t d`, { a: `Test Normalized Name A`, b: `Test Normalized Name B`, c: `Test Normalized Name C` }, { lineWithText: { characters: [{ name: `a`, normalizedName: `Test Normalized Name A` }, { name: `b`, normalizedName: `Test Normalized Name B` }, { name: `c`, normalizedName: `Test Normalized Name C` }], text: `d` } })
    run(`aBC \t\t  \t d   \t\t AnD  \t \t \t e:f`, { aBC: `Test Normalized Name A`, d: `Test Normalized Name B`, e: `Test Normalized Name C` }, { lineWithText: { characters: [{ name: `aBC`, normalizedName: `Test Normalized Name A` }, { name: `d`, normalizedName: `Test Normalized Name B` }, { name: `e`, normalizedName: `Test Normalized Name C` }], text: `f` } })
    run(`aBC \t\t  \t d   \t\t AnD  \t \t \t e  \t \t :f`, { aBC: `Test Normalized Name A`, d: `Test Normalized Name B`, e: `Test Normalized Name C` }, { lineWithText: { characters: [{ name: `aBC`, normalizedName: `Test Normalized Name A` }, { name: `d`, normalizedName: `Test Normalized Name B` }, { name: `e`, normalizedName: `Test Normalized Name C` }], text: `f` } })
    run(`aBC \t\t  \t d   \t\t AnD  \t \t \t e:  \t \t f`, { aBC: `Test Normalized Name A`, d: `Test Normalized Name B`, e: `Test Normalized Name C` }, { lineWithText: { characters: [{ name: `aBC`, normalizedName: `Test Normalized Name A` }, { name: `d`, normalizedName: `Test Normalized Name B` }, { name: `e`, normalizedName: `Test Normalized Name C` }], text: `f` } })
    run(`a \t\t  \t BCd   \t\t AnD  \t \t \t e:f`, { a: `Test Normalized Name A`, BCd: `Test Normalized Name B`, e: `Test Normalized Name C` }, { lineWithText: { characters: [{ name: `a`, normalizedName: `Test Normalized Name A` }, { name: `BCd`, normalizedName: `Test Normalized Name B` }, { name: `e`, normalizedName: `Test Normalized Name C` }], text: `f` } })
    run(`a \t\t  \t BCd   \t\t AnD  \t \t \t e  \t \t :f`, { a: `Test Normalized Name A`, BCd: `Test Normalized Name B`, e: `Test Normalized Name C` }, { lineWithText: { characters: [{ name: `a`, normalizedName: `Test Normalized Name A` }, { name: `BCd`, normalizedName: `Test Normalized Name B` }, { name: `e`, normalizedName: `Test Normalized Name C` }], text: `f` } })
    run(`a \t\t  \t BCd   \t\t AnD  \t \t \t e:  \t \t f`, { a: `Test Normalized Name A`, BCd: `Test Normalized Name B`, e: `Test Normalized Name C` }, { lineWithText: { characters: [{ name: `a`, normalizedName: `Test Normalized Name A` }, { name: `BCd`, normalizedName: `Test Normalized Name B` }, { name: `e`, normalizedName: `Test Normalized Name C` }], text: `f` } })
    run(`a \t\t  \t b   \t\t AnD  \t \t \t cDE:f`, { a: `Test Normalized Name A`, b: `Test Normalized Name B`, cDE: `Test Normalized Name C` }, { lineWithText: { characters: [{ name: `a`, normalizedName: `Test Normalized Name A` }, { name: `b`, normalizedName: `Test Normalized Name B` }, { name: `cDE`, normalizedName: `Test Normalized Name C` }], text: `f` } })
    run(`a \t\t  \t b   \t\t AnD  \t \t \t cDE  \t \t :f`, { a: `Test Normalized Name A`, b: `Test Normalized Name B`, cDE: `Test Normalized Name C` }, { lineWithText: { characters: [{ name: `a`, normalizedName: `Test Normalized Name A` }, { name: `b`, normalizedName: `Test Normalized Name B` }, { name: `cDE`, normalizedName: `Test Normalized Name C` }], text: `f` } })
    run(`a \t\t  \t b   \t\t AnD  \t \t \t cDE:  \t \t f`, { a: `Test Normalized Name A`, b: `Test Normalized Name B`, cDE: `Test Normalized Name C` }, { lineWithText: { characters: [{ name: `a`, normalizedName: `Test Normalized Name A` }, { name: `b`, normalizedName: `Test Normalized Name B` }, { name: `cDE`, normalizedName: `Test Normalized Name C` }], text: `f` } })
    run(`a \t\t  \t b   \t\t AnD  \t \t \t c:dEf \t \t \t\t GhiJ \t : \t \t\t klm`, { a: `Test Normalized Name A`, b: `Test Normalized Name B`, c: `Test Normalized Name C` }, { lineWithText: { characters: [{ name: `a`, normalizedName: `Test Normalized Name A` }, { name: `b`, normalizedName: `Test Normalized Name B` }, { name: `c`, normalizedName: `Test Normalized Name C` }], text: `dEf \t \t \t\t GhiJ \t : \t \t\t klm` } })
    run(`a \t\t  \t b   \t\t AnD  \t \t \t c  \t \t :dEf \t \t \t\t GhiJ \t : \t \t\t klm`, { a: `Test Normalized Name A`, b: `Test Normalized Name B`, c: `Test Normalized Name C` }, { lineWithText: { characters: [{ name: `a`, normalizedName: `Test Normalized Name A` }, { name: `b`, normalizedName: `Test Normalized Name B` }, { name: `c`, normalizedName: `Test Normalized Name C` }], text: `dEf \t \t \t\t GhiJ \t : \t \t\t klm` } })
    run(`a \t\t  \t b   \t\t AnD  \t \t \t c:  \t \t dEf \t \t \t\t GhiJ \t : \t \t\t klm`, { a: `Test Normalized Name A`, b: `Test Normalized Name B`, c: `Test Normalized Name C` }, { lineWithText: { characters: [{ name: `a`, normalizedName: `Test Normalized Name A` }, { name: `b`, normalizedName: `Test Normalized Name B` }, { name: `c`, normalizedName: `Test Normalized Name C` }], text: `dEf \t \t \t\t GhiJ \t : \t \t\t klm` } })
    run(`a \t \t \t   \t\t b \t \tc    \t AnD \t\t d:e`, { a: `Test Normalized Name A`, b: `Test Normalized Name B`, c: `Test Normalized Name C`, d: `Test Normalized Name D` }, { lineWithText: { characters: [{ name: `a`, normalizedName: `Test Normalized Name A` }, { name: `b`, normalizedName: `Test Normalized Name B` }, { name: `c`, normalizedName: `Test Normalized Name C` }, { name: `d`, normalizedName: `Test Normalized Name D` }], text: `e` } })
    run(`a \t \t \t   \t\t b \t \tc    \t AnD \t\t d \t \t\t \t :e`, { a: `Test Normalized Name A`, b: `Test Normalized Name B`, c: `Test Normalized Name C`, d: `Test Normalized Name D` }, { lineWithText: { characters: [{ name: `a`, normalizedName: `Test Normalized Name A` }, { name: `b`, normalizedName: `Test Normalized Name B` }, { name: `c`, normalizedName: `Test Normalized Name C` }, { name: `d`, normalizedName: `Test Normalized Name D` }], text: `e` } })
    run(`a \t \t \t   \t\t b \t \tc    \t AnD \t\t d: \t \t\t \t e`, { a: `Test Normalized Name A`, b: `Test Normalized Name B`, c: `Test Normalized Name C`, d: `Test Normalized Name D` }, { lineWithText: { characters: [{ name: `a`, normalizedName: `Test Normalized Name A` }, { name: `b`, normalizedName: `Test Normalized Name B` }, { name: `c`, normalizedName: `Test Normalized Name C` }, { name: `d`, normalizedName: `Test Normalized Name D` }], text: `e` } })
    run(`aBC \t \t \t   \t\t d \t \te    \t AnD \t\t f:g`, { aBC: `Test Normalized Name A`, d: `Test Normalized Name B`, e: `Test Normalized Name C`, f: `Test Normalized Name D` }, { lineWithText: { characters: [{ name: `aBC`, normalizedName: `Test Normalized Name A` }, { name: `d`, normalizedName: `Test Normalized Name B` }, { name: `e`, normalizedName: `Test Normalized Name C` }, { name: `f`, normalizedName: `Test Normalized Name D` }], text: `g` } })
    run(`aBC \t \t \t   \t\t d \t \te    \t AnD \t\t f \t \t\t \t :g`, { aBC: `Test Normalized Name A`, d: `Test Normalized Name B`, e: `Test Normalized Name C`, f: `Test Normalized Name D` }, { lineWithText: { characters: [{ name: `aBC`, normalizedName: `Test Normalized Name A` }, { name: `d`, normalizedName: `Test Normalized Name B` }, { name: `e`, normalizedName: `Test Normalized Name C` }, { name: `f`, normalizedName: `Test Normalized Name D` }], text: `g` } })
    run(`aBC \t \t \t   \t\t d \t \te    \t AnD \t\t f: \t \t\t \t g`, { aBC: `Test Normalized Name A`, d: `Test Normalized Name B`, e: `Test Normalized Name C`, f: `Test Normalized Name D` }, { lineWithText: { characters: [{ name: `aBC`, normalizedName: `Test Normalized Name A` }, { name: `d`, normalizedName: `Test Normalized Name B` }, { name: `e`, normalizedName: `Test Normalized Name C` }, { name: `f`, normalizedName: `Test Normalized Name D` }], text: `g` } })
    run(`a \t \t \t   \t\t BCd \t \te    \t AnD \t\t f:g`, { a: `Test Normalized Name A`, BCd: `Test Normalized Name B`, e: `Test Normalized Name C`, f: `Test Normalized Name D` }, { lineWithText: { characters: [{ name: `a`, normalizedName: `Test Normalized Name A` }, { name: `BCd`, normalizedName: `Test Normalized Name B` }, { name: `e`, normalizedName: `Test Normalized Name C` }, { name: `f`, normalizedName: `Test Normalized Name D` }], text: `g` } })
    run(`a \t \t \t   \t\t BCd \t \te    \t AnD \t\t f \t \t\t \t :g`, { a: `Test Normalized Name A`, BCd: `Test Normalized Name B`, e: `Test Normalized Name C`, f: `Test Normalized Name D` }, { lineWithText: { characters: [{ name: `a`, normalizedName: `Test Normalized Name A` }, { name: `BCd`, normalizedName: `Test Normalized Name B` }, { name: `e`, normalizedName: `Test Normalized Name C` }, { name: `f`, normalizedName: `Test Normalized Name D` }], text: `g` } })
    run(`a \t \t \t   \t\t BCd \t \te    \t AnD \t\t f: \t \t\t \t g`, { a: `Test Normalized Name A`, BCd: `Test Normalized Name B`, e: `Test Normalized Name C`, f: `Test Normalized Name D` }, { lineWithText: { characters: [{ name: `a`, normalizedName: `Test Normalized Name A` }, { name: `BCd`, normalizedName: `Test Normalized Name B` }, { name: `e`, normalizedName: `Test Normalized Name C` }, { name: `f`, normalizedName: `Test Normalized Name D` }], text: `g` } })
    run(`a \t \t \t   \t\t b \t \tcDE    \t AnD \t\t f:g`, { a: `Test Normalized Name A`, b: `Test Normalized Name B`, cDE: `Test Normalized Name C`, f: `Test Normalized Name D` }, { lineWithText: { characters: [{ name: `a`, normalizedName: `Test Normalized Name A` }, { name: `b`, normalizedName: `Test Normalized Name B` }, { name: `cDE`, normalizedName: `Test Normalized Name C` }, { name: `f`, normalizedName: `Test Normalized Name D` }], text: `g` } })
    run(`a \t \t \t   \t\t b \t \tcDE    \t AnD \t\t f \t \t\t \t :g`, { a: `Test Normalized Name A`, b: `Test Normalized Name B`, cDE: `Test Normalized Name C`, f: `Test Normalized Name D` }, { lineWithText: { characters: [{ name: `a`, normalizedName: `Test Normalized Name A` }, { name: `b`, normalizedName: `Test Normalized Name B` }, { name: `cDE`, normalizedName: `Test Normalized Name C` }, { name: `f`, normalizedName: `Test Normalized Name D` }], text: `g` } })
    run(`a \t \t \t   \t\t b \t \tcDE    \t AnD \t\t f: \t \t\t \t g`, { a: `Test Normalized Name A`, b: `Test Normalized Name B`, cDE: `Test Normalized Name C`, f: `Test Normalized Name D` }, { lineWithText: { characters: [{ name: `a`, normalizedName: `Test Normalized Name A` }, { name: `b`, normalizedName: `Test Normalized Name B` }, { name: `cDE`, normalizedName: `Test Normalized Name C` }, { name: `f`, normalizedName: `Test Normalized Name D` }], text: `g` } })
    run(`a \t \t \t   \t\t b \t \tc    \t AnD \t\t dEf:g`, { a: `Test Normalized Name A`, b: `Test Normalized Name B`, c: `Test Normalized Name C`, dEf: `Test Normalized Name D` }, { lineWithText: { characters: [{ name: `a`, normalizedName: `Test Normalized Name A` }, { name: `b`, normalizedName: `Test Normalized Name B` }, { name: `c`, normalizedName: `Test Normalized Name C` }, { name: `dEf`, normalizedName: `Test Normalized Name D` }], text: `g` } })
    run(`a \t \t \t   \t\t b \t \tc    \t AnD \t\t dEf \t \t\t \t :g`, { a: `Test Normalized Name A`, b: `Test Normalized Name B`, c: `Test Normalized Name C`, dEf: `Test Normalized Name D` }, { lineWithText: { characters: [{ name: `a`, normalizedName: `Test Normalized Name A` }, { name: `b`, normalizedName: `Test Normalized Name B` }, { name: `c`, normalizedName: `Test Normalized Name C` }, { name: `dEf`, normalizedName: `Test Normalized Name D` }], text: `g` } })
    run(`a \t \t \t   \t\t b \t \tc    \t AnD \t\t dEf: \t \t\t \t g`, { a: `Test Normalized Name A`, b: `Test Normalized Name B`, c: `Test Normalized Name C`, dEf: `Test Normalized Name D` }, { lineWithText: { characters: [{ name: `a`, normalizedName: `Test Normalized Name A` }, { name: `b`, normalizedName: `Test Normalized Name B` }, { name: `c`, normalizedName: `Test Normalized Name C` }, { name: `dEf`, normalizedName: `Test Normalized Name D` }], text: `g` } })
    run(`a \t \t \t   \t\t b \t \tc    \t AnD \t\t d:eFG \t \t \t\t hIJk \t : \t \t\t LMN`, { a: `Test Normalized Name A`, b: `Test Normalized Name B`, c: `Test Normalized Name C`, d: `Test Normalized Name D` }, { lineWithText: { characters: [{ name: `a`, normalizedName: `Test Normalized Name A` }, { name: `b`, normalizedName: `Test Normalized Name B` }, { name: `c`, normalizedName: `Test Normalized Name C` }, { name: `d`, normalizedName: `Test Normalized Name D` }], text: `eFG \t \t \t\t hIJk \t : \t \t\t LMN` } })
    run(`a \t \t \t   \t\t b \t \tc    \t AnD \t\t d \t \t\t \t :eFG \t \t \t\t hIJk \t : \t \t\t LMN`, { a: `Test Normalized Name A`, b: `Test Normalized Name B`, c: `Test Normalized Name C`, d: `Test Normalized Name D` }, { lineWithText: { characters: [{ name: `a`, normalizedName: `Test Normalized Name A` }, { name: `b`, normalizedName: `Test Normalized Name B` }, { name: `c`, normalizedName: `Test Normalized Name C` }, { name: `d`, normalizedName: `Test Normalized Name D` }], text: `eFG \t \t \t\t hIJk \t : \t \t\t LMN` } })
    run(`a \t \t \t   \t\t b \t \tc    \t AnD \t\t d: \t \t\t \t eFG \t \t \t\t hIJk \t : \t \t\t LMN`, { a: `Test Normalized Name A`, b: `Test Normalized Name B`, c: `Test Normalized Name C`, d: `Test Normalized Name D` }, { lineWithText: { characters: [{ name: `a`, normalizedName: `Test Normalized Name A` }, { name: `b`, normalizedName: `Test Normalized Name B` }, { name: `c`, normalizedName: `Test Normalized Name C` }, { name: `d`, normalizedName: `Test Normalized Name D` }], text: `eFG \t \t \t\t hIJk \t : \t \t\t LMN` } })
  })
  describe(`line with emote and text`, () => {
    run(`a(b):c`, { a: `Test Normalized Name A`, b: `Test Normalized Emote` }, { lineWithEmoteAndText: { characters: [{ name: `a`, normalizedName: `Test Normalized Name A` }], emote: `b`, normalizedEmote: `Test Normalized Emote`, text: `c` } })
    run(`a \t \t\t (b):c`, { a: `Test Normalized Name A`, b: `Test Normalized Emote` }, { lineWithEmoteAndText: { characters: [{ name: `a`, normalizedName: `Test Normalized Name A` }], emote: `b`, normalizedEmote: `Test Normalized Emote`, text: `c` } })
    run(`a( \t \t\t b):c`, { a: `Test Normalized Name A`, b: `Test Normalized Emote` }, { lineWithEmoteAndText: { characters: [{ name: `a`, normalizedName: `Test Normalized Name A` }], emote: `b`, normalizedEmote: `Test Normalized Emote`, text: `c` } })
    run(`a(b   \t\t \t ):c`, { a: `Test Normalized Name A`, b: `Test Normalized Emote` }, { lineWithEmoteAndText: { characters: [{ name: `a`, normalizedName: `Test Normalized Name A` }], emote: `b`, normalizedEmote: `Test Normalized Emote`, text: `c` } })
    run(`a(b)   \t\t \t    \t   \t :c`, { a: `Test Normalized Name A`, b: `Test Normalized Emote` }, { lineWithEmoteAndText: { characters: [{ name: `a`, normalizedName: `Test Normalized Name A` }], emote: `b`, normalizedEmote: `Test Normalized Emote`, text: `c` } })
    run(`a(b):   \t\t \t    \t   \t c`, { a: `Test Normalized Name A`, b: `Test Normalized Emote` }, { lineWithEmoteAndText: { characters: [{ name: `a`, normalizedName: `Test Normalized Name A` }], emote: `b`, normalizedEmote: `Test Normalized Emote`, text: `c` } })
    run(`aBC(d):e`, { aBC: `Test Normalized Name A`, d: `Test Normalized Emote` }, { lineWithEmoteAndText: { characters: [{ name: `aBC`, normalizedName: `Test Normalized Name A` }], emote: `d`, normalizedEmote: `Test Normalized Emote`, text: `e` } })
    run(`aBC \t \t\t (d):e`, { aBC: `Test Normalized Name A`, d: `Test Normalized Emote` }, { lineWithEmoteAndText: { characters: [{ name: `aBC`, normalizedName: `Test Normalized Name A` }], emote: `d`, normalizedEmote: `Test Normalized Emote`, text: `e` } })
    run(`aBC( \t \t\t d):e`, { aBC: `Test Normalized Name A`, d: `Test Normalized Emote` }, { lineWithEmoteAndText: { characters: [{ name: `aBC`, normalizedName: `Test Normalized Name A` }], emote: `d`, normalizedEmote: `Test Normalized Emote`, text: `e` } })
    run(`aBC(d   \t\t \t ):e`, { aBC: `Test Normalized Name A`, d: `Test Normalized Emote` }, { lineWithEmoteAndText: { characters: [{ name: `aBC`, normalizedName: `Test Normalized Name A` }], emote: `d`, normalizedEmote: `Test Normalized Emote`, text: `e` } })
    run(`aBC(d)   \t\t \t    \t   \t :e`, { aBC: `Test Normalized Name A`, d: `Test Normalized Emote` }, { lineWithEmoteAndText: { characters: [{ name: `aBC`, normalizedName: `Test Normalized Name A` }], emote: `d`, normalizedEmote: `Test Normalized Emote`, text: `e` } })
    run(`aBC(d):   \t\t \t    \t   \t e`, { aBC: `Test Normalized Name A`, d: `Test Normalized Emote` }, { lineWithEmoteAndText: { characters: [{ name: `aBC`, normalizedName: `Test Normalized Name A` }], emote: `d`, normalizedEmote: `Test Normalized Emote`, text: `e` } })
    run(`a(BCd):e`, { a: `Test Normalized Name A`, BCd: `Test Normalized Emote` }, { lineWithEmoteAndText: { characters: [{ name: `a`, normalizedName: `Test Normalized Name A` }], emote: `BCd`, normalizedEmote: `Test Normalized Emote`, text: `e` } })
    run(`a \t \t\t (BCd):e`, { a: `Test Normalized Name A`, BCd: `Test Normalized Emote` }, { lineWithEmoteAndText: { characters: [{ name: `a`, normalizedName: `Test Normalized Name A` }], emote: `BCd`, normalizedEmote: `Test Normalized Emote`, text: `e` } })
    run(`a( \t \t\t BCd):e`, { a: `Test Normalized Name A`, BCd: `Test Normalized Emote` }, { lineWithEmoteAndText: { characters: [{ name: `a`, normalizedName: `Test Normalized Name A` }], emote: `BCd`, normalizedEmote: `Test Normalized Emote`, text: `e` } })
    run(`a(BCd   \t\t \t ):e`, { a: `Test Normalized Name A`, BCd: `Test Normalized Emote` }, { lineWithEmoteAndText: { characters: [{ name: `a`, normalizedName: `Test Normalized Name A` }], emote: `BCd`, normalizedEmote: `Test Normalized Emote`, text: `e` } })
    run(`a(BCd)   \t\t \t    \t   \t :e`, { a: `Test Normalized Name A`, BCd: `Test Normalized Emote` }, { lineWithEmoteAndText: { characters: [{ name: `a`, normalizedName: `Test Normalized Name A` }], emote: `BCd`, normalizedEmote: `Test Normalized Emote`, text: `e` } })
    run(`a(BCd):   \t\t \t    \t   \t e`, { a: `Test Normalized Name A`, BCd: `Test Normalized Emote` }, { lineWithEmoteAndText: { characters: [{ name: `a`, normalizedName: `Test Normalized Name A` }], emote: `BCd`, normalizedEmote: `Test Normalized Emote`, text: `e` } })
    run(`a \t \t\t (b):cDE \t \t \t\t FGhi \t : \t \t\t jkl`, { a: `Test Normalized Name A`, b: `Test Normalized Emote` }, { lineWithEmoteAndText: { characters: [{ name: `a`, normalizedName: `Test Normalized Name A` }], emote: `b`, normalizedEmote: `Test Normalized Emote`, text: `cDE \t \t \t\t FGhi \t : \t \t\t jkl` } })
    run(`a \t \t\t (   \t\t \t b):cDE \t \t \t\t FGhi \t : \t \t\t jkl`, { a: `Test Normalized Name A`, b: `Test Normalized Emote` }, { lineWithEmoteAndText: { characters: [{ name: `a`, normalizedName: `Test Normalized Name A` }], emote: `b`, normalizedEmote: `Test Normalized Emote`, text: `cDE \t \t \t\t FGhi \t : \t \t\t jkl` } })
    run(`a \t \t\t (b   \t\t \t ):cDE \t \t \t\t FGhi \t : \t \t\t jkl`, { a: `Test Normalized Name A`, b: `Test Normalized Emote` }, { lineWithEmoteAndText: { characters: [{ name: `a`, normalizedName: `Test Normalized Name A` }], emote: `b`, normalizedEmote: `Test Normalized Emote`, text: `cDE \t \t \t\t FGhi \t : \t \t\t jkl` } })
    run(`a \t \t\t (b)   \t\t \t :cDE \t \t \t\t FGhi \t : \t \t\t jkl`, { a: `Test Normalized Name A`, b: `Test Normalized Emote` }, { lineWithEmoteAndText: { characters: [{ name: `a`, normalizedName: `Test Normalized Name A` }], emote: `b`, normalizedEmote: `Test Normalized Emote`, text: `cDE \t \t \t\t FGhi \t : \t \t\t jkl` } })
    run(`a \t \t\t (b):   \t\t \t cDE \t \t \t\t FGhi \t : \t \t\t jkl`, { a: `Test Normalized Name A`, b: `Test Normalized Emote` }, { lineWithEmoteAndText: { characters: [{ name: `a`, normalizedName: `Test Normalized Name A` }], emote: `b`, normalizedEmote: `Test Normalized Emote`, text: `cDE \t \t \t\t FGhi \t : \t \t\t jkl` } })
    run(`a  \t  \t \t  AnD \t \t\t \t \tb(c):d`, { a: `Test Normalized Name A`, b: `Test Normalized Name B`, c: `Test Normalized Emote` }, { lineWithEmoteAndText: { characters: [{ name: `a`, normalizedName: `Test Normalized Name A` }, { name: `b`, normalizedName: `Test Normalized Name B` }], emote: `c`, normalizedEmote: `Test Normalized Emote`, text: `d` } })
    run(`a  \t  \t \t  AnD \t \t\t \t \tb \t \t\t (c):d`, { a: `Test Normalized Name A`, b: `Test Normalized Name B`, c: `Test Normalized Emote` }, { lineWithEmoteAndText: { characters: [{ name: `a`, normalizedName: `Test Normalized Name A` }, { name: `b`, normalizedName: `Test Normalized Name B` }], emote: `c`, normalizedEmote: `Test Normalized Emote`, text: `d` } })
    run(`a  \t  \t \t  AnD \t \t\t \t \tb( \t \t\t c):d`, { a: `Test Normalized Name A`, b: `Test Normalized Name B`, c: `Test Normalized Emote` }, { lineWithEmoteAndText: { characters: [{ name: `a`, normalizedName: `Test Normalized Name A` }, { name: `b`, normalizedName: `Test Normalized Name B` }], emote: `c`, normalizedEmote: `Test Normalized Emote`, text: `d` } })
    run(`a  \t  \t \t  AnD \t \t\t \t \tb(c   \t\t \t ):d`, { a: `Test Normalized Name A`, b: `Test Normalized Name B`, c: `Test Normalized Emote` }, { lineWithEmoteAndText: { characters: [{ name: `a`, normalizedName: `Test Normalized Name A` }, { name: `b`, normalizedName: `Test Normalized Name B` }], emote: `c`, normalizedEmote: `Test Normalized Emote`, text: `d` } })
    run(`a  \t  \t \t  AnD \t \t\t \t \tb(c)   \t\t \t    \t   \t :d`, { a: `Test Normalized Name A`, b: `Test Normalized Name B`, c: `Test Normalized Emote` }, { lineWithEmoteAndText: { characters: [{ name: `a`, normalizedName: `Test Normalized Name A` }, { name: `b`, normalizedName: `Test Normalized Name B` }], emote: `c`, normalizedEmote: `Test Normalized Emote`, text: `d` } })
    run(`a  \t  \t \t  AnD \t \t\t \t \tb(c):   \t\t \t    \t   \t d`, { a: `Test Normalized Name A`, b: `Test Normalized Name B`, c: `Test Normalized Emote` }, { lineWithEmoteAndText: { characters: [{ name: `a`, normalizedName: `Test Normalized Name A` }, { name: `b`, normalizedName: `Test Normalized Name B` }], emote: `c`, normalizedEmote: `Test Normalized Emote`, text: `d` } })
    run(`aBC  \t  \t \t  AnD \t \t\t \t \td(e):f`, { aBC: `Test Normalized Name A`, d: `Test Normalized Name B`, e: `Test Normalized Emote` }, { lineWithEmoteAndText: { characters: [{ name: `aBC`, normalizedName: `Test Normalized Name A` }, { name: `d`, normalizedName: `Test Normalized Name B` }], emote: `e`, normalizedEmote: `Test Normalized Emote`, text: `f` } })
    run(`aBC  \t  \t \t  AnD \t \t\t \t \td \t \t\t (e):f`, { aBC: `Test Normalized Name A`, d: `Test Normalized Name B`, e: `Test Normalized Emote` }, { lineWithEmoteAndText: { characters: [{ name: `aBC`, normalizedName: `Test Normalized Name A` }, { name: `d`, normalizedName: `Test Normalized Name B` }], emote: `e`, normalizedEmote: `Test Normalized Emote`, text: `f` } })
    run(`aBC  \t  \t \t  AnD \t \t\t \t \td( \t \t\t e):f`, { aBC: `Test Normalized Name A`, d: `Test Normalized Name B`, e: `Test Normalized Emote` }, { lineWithEmoteAndText: { characters: [{ name: `aBC`, normalizedName: `Test Normalized Name A` }, { name: `d`, normalizedName: `Test Normalized Name B` }], emote: `e`, normalizedEmote: `Test Normalized Emote`, text: `f` } })
    run(`aBC  \t  \t \t  AnD \t \t\t \t \td(e   \t\t \t ):f`, { aBC: `Test Normalized Name A`, d: `Test Normalized Name B`, e: `Test Normalized Emote` }, { lineWithEmoteAndText: { characters: [{ name: `aBC`, normalizedName: `Test Normalized Name A` }, { name: `d`, normalizedName: `Test Normalized Name B` }], emote: `e`, normalizedEmote: `Test Normalized Emote`, text: `f` } })
    run(`aBC  \t  \t \t  AnD \t \t\t \t \td(e)   \t\t \t    \t   \t :f`, { aBC: `Test Normalized Name A`, d: `Test Normalized Name B`, e: `Test Normalized Emote` }, { lineWithEmoteAndText: { characters: [{ name: `aBC`, normalizedName: `Test Normalized Name A` }, { name: `d`, normalizedName: `Test Normalized Name B` }], emote: `e`, normalizedEmote: `Test Normalized Emote`, text: `f` } })
    run(`aBC  \t  \t \t  AnD \t \t\t \t \td(e):   \t\t \t    \t   \t f`, { aBC: `Test Normalized Name A`, d: `Test Normalized Name B`, e: `Test Normalized Emote` }, { lineWithEmoteAndText: { characters: [{ name: `aBC`, normalizedName: `Test Normalized Name A` }, { name: `d`, normalizedName: `Test Normalized Name B` }], emote: `e`, normalizedEmote: `Test Normalized Emote`, text: `f` } })
    run(`a  \t  \t \t  AnD \t \t\t \t \tBCd(e):f`, { a: `Test Normalized Name A`, BCd: `Test Normalized Name B`, e: `Test Normalized Emote` }, { lineWithEmoteAndText: { characters: [{ name: `a`, normalizedName: `Test Normalized Name A` }, { name: `BCd`, normalizedName: `Test Normalized Name B` }], emote: `e`, normalizedEmote: `Test Normalized Emote`, text: `f` } })
    run(`a  \t  \t \t  AnD \t \t\t \t \tBCd \t \t\t (e):f`, { a: `Test Normalized Name A`, BCd: `Test Normalized Name B`, e: `Test Normalized Emote` }, { lineWithEmoteAndText: { characters: [{ name: `a`, normalizedName: `Test Normalized Name A` }, { name: `BCd`, normalizedName: `Test Normalized Name B` }], emote: `e`, normalizedEmote: `Test Normalized Emote`, text: `f` } })
    run(`a  \t  \t \t  AnD \t \t\t \t \tBCd( \t \t\t e):f`, { a: `Test Normalized Name A`, BCd: `Test Normalized Name B`, e: `Test Normalized Emote` }, { lineWithEmoteAndText: { characters: [{ name: `a`, normalizedName: `Test Normalized Name A` }, { name: `BCd`, normalizedName: `Test Normalized Name B` }], emote: `e`, normalizedEmote: `Test Normalized Emote`, text: `f` } })
    run(`a  \t  \t \t  AnD \t \t\t \t \tBCd(e   \t\t \t ):f`, { a: `Test Normalized Name A`, BCd: `Test Normalized Name B`, e: `Test Normalized Emote` }, { lineWithEmoteAndText: { characters: [{ name: `a`, normalizedName: `Test Normalized Name A` }, { name: `BCd`, normalizedName: `Test Normalized Name B` }], emote: `e`, normalizedEmote: `Test Normalized Emote`, text: `f` } })
    run(`a  \t  \t \t  AnD \t \t\t \t \tBCd(e)   \t\t \t    \t   \t :f`, { a: `Test Normalized Name A`, BCd: `Test Normalized Name B`, e: `Test Normalized Emote` }, { lineWithEmoteAndText: { characters: [{ name: `a`, normalizedName: `Test Normalized Name A` }, { name: `BCd`, normalizedName: `Test Normalized Name B` }], emote: `e`, normalizedEmote: `Test Normalized Emote`, text: `f` } })
    run(`a  \t  \t \t  AnD \t \t\t \t \tBCd(e):   \t\t \t    \t   \t f`, { a: `Test Normalized Name A`, BCd: `Test Normalized Name B`, e: `Test Normalized Emote` }, { lineWithEmoteAndText: { characters: [{ name: `a`, normalizedName: `Test Normalized Name A` }, { name: `BCd`, normalizedName: `Test Normalized Name B` }], emote: `e`, normalizedEmote: `Test Normalized Emote`, text: `f` } })
    run(`a  \t  \t \t  AnD \t \t\t \t \tb(cDE):f`, { a: `Test Normalized Name A`, b: `Test Normalized Name B`, cDE: `Test Normalized Emote` }, { lineWithEmoteAndText: { characters: [{ name: `a`, normalizedName: `Test Normalized Name A` }, { name: `b`, normalizedName: `Test Normalized Name B` }], emote: `cDE`, normalizedEmote: `Test Normalized Emote`, text: `f` } })
    run(`a  \t  \t \t  AnD \t \t\t \t \tb \t \t\t (cDE):f`, { a: `Test Normalized Name A`, b: `Test Normalized Name B`, cDE: `Test Normalized Emote` }, { lineWithEmoteAndText: { characters: [{ name: `a`, normalizedName: `Test Normalized Name A` }, { name: `b`, normalizedName: `Test Normalized Name B` }], emote: `cDE`, normalizedEmote: `Test Normalized Emote`, text: `f` } })
    run(`a  \t  \t \t  AnD \t \t\t \t \tb( \t \t\t cDE):f`, { a: `Test Normalized Name A`, b: `Test Normalized Name B`, cDE: `Test Normalized Emote` }, { lineWithEmoteAndText: { characters: [{ name: `a`, normalizedName: `Test Normalized Name A` }, { name: `b`, normalizedName: `Test Normalized Name B` }], emote: `cDE`, normalizedEmote: `Test Normalized Emote`, text: `f` } })
    run(`a  \t  \t \t  AnD \t \t\t \t \tb(cDE   \t\t \t ):f`, { a: `Test Normalized Name A`, b: `Test Normalized Name B`, cDE: `Test Normalized Emote` }, { lineWithEmoteAndText: { characters: [{ name: `a`, normalizedName: `Test Normalized Name A` }, { name: `b`, normalizedName: `Test Normalized Name B` }], emote: `cDE`, normalizedEmote: `Test Normalized Emote`, text: `f` } })
    run(`a  \t  \t \t  AnD \t \t\t \t \tb(cDE)   \t\t \t    \t   \t :f`, { a: `Test Normalized Name A`, b: `Test Normalized Name B`, cDE: `Test Normalized Emote` }, { lineWithEmoteAndText: { characters: [{ name: `a`, normalizedName: `Test Normalized Name A` }, { name: `b`, normalizedName: `Test Normalized Name B` }], emote: `cDE`, normalizedEmote: `Test Normalized Emote`, text: `f` } })
    run(`a  \t  \t \t  AnD \t \t\t \t \tb(cDE):   \t\t \t    \t   \t f`, { a: `Test Normalized Name A`, b: `Test Normalized Name B`, cDE: `Test Normalized Emote` }, { lineWithEmoteAndText: { characters: [{ name: `a`, normalizedName: `Test Normalized Name A` }, { name: `b`, normalizedName: `Test Normalized Name B` }], emote: `cDE`, normalizedEmote: `Test Normalized Emote`, text: `f` } })
    run(`a  \t  \t \t  AnD \t \t\t \t \tb \t \t\t (c):dEf \t \t \t\t GhiJ \t : \t \t\t klm`, { a: `Test Normalized Name A`, b: `Test Normalized Name B`, c: `Test Normalized Emote` }, { lineWithEmoteAndText: { characters: [{ name: `a`, normalizedName: `Test Normalized Name A` }, { name: `b`, normalizedName: `Test Normalized Name B` }], emote: `c`, normalizedEmote: `Test Normalized Emote`, text: `dEf \t \t \t\t GhiJ \t : \t \t\t klm` } })
    run(`a  \t  \t \t  AnD \t \t\t \t \tb \t \t\t (   \t\t \t    \t   \t c):dEf \t \t \t\t GhiJ \t : \t \t\t klm`, { a: `Test Normalized Name A`, b: `Test Normalized Name B`, c: `Test Normalized Emote` }, { lineWithEmoteAndText: { characters: [{ name: `a`, normalizedName: `Test Normalized Name A` }, { name: `b`, normalizedName: `Test Normalized Name B` }], emote: `c`, normalizedEmote: `Test Normalized Emote`, text: `dEf \t \t \t\t GhiJ \t : \t \t\t klm` } })
    run(`a  \t  \t \t  AnD \t \t\t \t \tb \t \t\t (c   \t\t \t    \t   \t ):dEf \t \t \t\t GhiJ \t : \t \t\t klm`, { a: `Test Normalized Name A`, b: `Test Normalized Name B`, c: `Test Normalized Emote` }, { lineWithEmoteAndText: { characters: [{ name: `a`, normalizedName: `Test Normalized Name A` }, { name: `b`, normalizedName: `Test Normalized Name B` }], emote: `c`, normalizedEmote: `Test Normalized Emote`, text: `dEf \t \t \t\t GhiJ \t : \t \t\t klm` } })
    run(`a  \t  \t \t  AnD \t \t\t \t \tb \t \t\t (c)   \t\t \t    \t   \t :dEf \t \t \t\t GhiJ \t : \t \t\t klm`, { a: `Test Normalized Name A`, b: `Test Normalized Name B`, c: `Test Normalized Emote` }, { lineWithEmoteAndText: { characters: [{ name: `a`, normalizedName: `Test Normalized Name A` }, { name: `b`, normalizedName: `Test Normalized Name B` }], emote: `c`, normalizedEmote: `Test Normalized Emote`, text: `dEf \t \t \t\t GhiJ \t : \t \t\t klm` } })
    run(`a  \t  \t \t  AnD \t \t\t \t \tb \t \t\t (c):   \t\t \t    \t   \t dEf \t \t \t\t GhiJ \t : \t \t\t klm`, { a: `Test Normalized Name A`, b: `Test Normalized Name B`, c: `Test Normalized Emote` }, { lineWithEmoteAndText: { characters: [{ name: `a`, normalizedName: `Test Normalized Name A` }, { name: `b`, normalizedName: `Test Normalized Name B` }], emote: `c`, normalizedEmote: `Test Normalized Emote`, text: `dEf \t \t \t\t GhiJ \t : \t \t\t klm` } })
    run(`a   \t \t \t  b  \t  \t \t  AnD \t \t\t \t \tc(d):e`, { a: `Test Normalized Name A`, b: `Test Normalized Name B`, c: `Test Normalized Name C`, d: `Test Normalized Emote` }, { lineWithEmoteAndText: { characters: [{ name: `a`, normalizedName: `Test Normalized Name A` }, { name: `b`, normalizedName: `Test Normalized Name B` }, { name: `c`, normalizedName: `Test Normalized Name C` }], emote: `d`, normalizedEmote: `Test Normalized Emote`, text: `e` } })
    run(`a   \t \t \t  b  \t  \t \t  AnD \t \t\t \t \tc \t \t\t (d):e`, { a: `Test Normalized Name A`, b: `Test Normalized Name B`, c: `Test Normalized Name C`, d: `Test Normalized Emote` }, { lineWithEmoteAndText: { characters: [{ name: `a`, normalizedName: `Test Normalized Name A` }, { name: `b`, normalizedName: `Test Normalized Name B` }, { name: `c`, normalizedName: `Test Normalized Name C` }], emote: `d`, normalizedEmote: `Test Normalized Emote`, text: `e` } })
    run(`a   \t \t \t  b  \t  \t \t  AnD \t \t\t \t \tc( \t \t\t d):e`, { a: `Test Normalized Name A`, b: `Test Normalized Name B`, c: `Test Normalized Name C`, d: `Test Normalized Emote` }, { lineWithEmoteAndText: { characters: [{ name: `a`, normalizedName: `Test Normalized Name A` }, { name: `b`, normalizedName: `Test Normalized Name B` }, { name: `c`, normalizedName: `Test Normalized Name C` }], emote: `d`, normalizedEmote: `Test Normalized Emote`, text: `e` } })
    run(`a   \t \t \t  b  \t  \t \t  AnD \t \t\t \t \tc(d   \t\t \t ):e`, { a: `Test Normalized Name A`, b: `Test Normalized Name B`, c: `Test Normalized Name C`, d: `Test Normalized Emote` }, { lineWithEmoteAndText: { characters: [{ name: `a`, normalizedName: `Test Normalized Name A` }, { name: `b`, normalizedName: `Test Normalized Name B` }, { name: `c`, normalizedName: `Test Normalized Name C` }], emote: `d`, normalizedEmote: `Test Normalized Emote`, text: `e` } })
    run(`a   \t \t \t  b  \t  \t \t  AnD \t \t\t \t \tc(d)   \t\t \t    \t   \t :e`, { a: `Test Normalized Name A`, b: `Test Normalized Name B`, c: `Test Normalized Name C`, d: `Test Normalized Emote` }, { lineWithEmoteAndText: { characters: [{ name: `a`, normalizedName: `Test Normalized Name A` }, { name: `b`, normalizedName: `Test Normalized Name B` }, { name: `c`, normalizedName: `Test Normalized Name C` }], emote: `d`, normalizedEmote: `Test Normalized Emote`, text: `e` } })
    run(`a   \t \t \t  b  \t  \t \t  AnD \t \t\t \t \tc(d):   \t\t \t    \t   \t e`, { a: `Test Normalized Name A`, b: `Test Normalized Name B`, c: `Test Normalized Name C`, d: `Test Normalized Emote` }, { lineWithEmoteAndText: { characters: [{ name: `a`, normalizedName: `Test Normalized Name A` }, { name: `b`, normalizedName: `Test Normalized Name B` }, { name: `c`, normalizedName: `Test Normalized Name C` }], emote: `d`, normalizedEmote: `Test Normalized Emote`, text: `e` } })
    run(`aBC   \t \t \t  d  \t  \t \t  AnD \t \t\t \t \te(f):g`, { aBC: `Test Normalized Name A`, d: `Test Normalized Name B`, e: `Test Normalized Name C`, f: `Test Normalized Emote` }, { lineWithEmoteAndText: { characters: [{ name: `aBC`, normalizedName: `Test Normalized Name A` }, { name: `d`, normalizedName: `Test Normalized Name B` }, { name: `e`, normalizedName: `Test Normalized Name C` }], emote: `f`, normalizedEmote: `Test Normalized Emote`, text: `g` } })
    run(`aBC   \t \t \t  d  \t  \t \t  AnD \t \t\t \t \te \t \t\t (f):g`, { aBC: `Test Normalized Name A`, d: `Test Normalized Name B`, e: `Test Normalized Name C`, f: `Test Normalized Emote` }, { lineWithEmoteAndText: { characters: [{ name: `aBC`, normalizedName: `Test Normalized Name A` }, { name: `d`, normalizedName: `Test Normalized Name B` }, { name: `e`, normalizedName: `Test Normalized Name C` }], emote: `f`, normalizedEmote: `Test Normalized Emote`, text: `g` } })
    run(`aBC   \t \t \t  d  \t  \t \t  AnD \t \t\t \t \te( \t \t\t f):g`, { aBC: `Test Normalized Name A`, d: `Test Normalized Name B`, e: `Test Normalized Name C`, f: `Test Normalized Emote` }, { lineWithEmoteAndText: { characters: [{ name: `aBC`, normalizedName: `Test Normalized Name A` }, { name: `d`, normalizedName: `Test Normalized Name B` }, { name: `e`, normalizedName: `Test Normalized Name C` }], emote: `f`, normalizedEmote: `Test Normalized Emote`, text: `g` } })
    run(`aBC   \t \t \t  d  \t  \t \t  AnD \t \t\t \t \te(f   \t\t \t ):g`, { aBC: `Test Normalized Name A`, d: `Test Normalized Name B`, e: `Test Normalized Name C`, f: `Test Normalized Emote` }, { lineWithEmoteAndText: { characters: [{ name: `aBC`, normalizedName: `Test Normalized Name A` }, { name: `d`, normalizedName: `Test Normalized Name B` }, { name: `e`, normalizedName: `Test Normalized Name C` }], emote: `f`, normalizedEmote: `Test Normalized Emote`, text: `g` } })
    run(`aBC   \t \t \t  d  \t  \t \t  AnD \t \t\t \t \te(f)   \t\t \t    \t   \t :g`, { aBC: `Test Normalized Name A`, d: `Test Normalized Name B`, e: `Test Normalized Name C`, f: `Test Normalized Emote` }, { lineWithEmoteAndText: { characters: [{ name: `aBC`, normalizedName: `Test Normalized Name A` }, { name: `d`, normalizedName: `Test Normalized Name B` }, { name: `e`, normalizedName: `Test Normalized Name C` }], emote: `f`, normalizedEmote: `Test Normalized Emote`, text: `g` } })
    run(`aBC   \t \t \t  d  \t  \t \t  AnD \t \t\t \t \te(f):   \t\t \t    \t   \t g`, { aBC: `Test Normalized Name A`, d: `Test Normalized Name B`, e: `Test Normalized Name C`, f: `Test Normalized Emote` }, { lineWithEmoteAndText: { characters: [{ name: `aBC`, normalizedName: `Test Normalized Name A` }, { name: `d`, normalizedName: `Test Normalized Name B` }, { name: `e`, normalizedName: `Test Normalized Name C` }], emote: `f`, normalizedEmote: `Test Normalized Emote`, text: `g` } })
    run(`a   \t \t \t  BCd  \t  \t \t  AnD \t \t\t \t \te(f):g`, { a: `Test Normalized Name A`, BCd: `Test Normalized Name B`, e: `Test Normalized Name C`, f: `Test Normalized Emote` }, { lineWithEmoteAndText: { characters: [{ name: `a`, normalizedName: `Test Normalized Name A` }, { name: `BCd`, normalizedName: `Test Normalized Name B` }, { name: `e`, normalizedName: `Test Normalized Name C` }], emote: `f`, normalizedEmote: `Test Normalized Emote`, text: `g` } })
    run(`a   \t \t \t  BCd  \t  \t \t  AnD \t \t\t \t \te \t \t\t (f):g`, { a: `Test Normalized Name A`, BCd: `Test Normalized Name B`, e: `Test Normalized Name C`, f: `Test Normalized Emote` }, { lineWithEmoteAndText: { characters: [{ name: `a`, normalizedName: `Test Normalized Name A` }, { name: `BCd`, normalizedName: `Test Normalized Name B` }, { name: `e`, normalizedName: `Test Normalized Name C` }], emote: `f`, normalizedEmote: `Test Normalized Emote`, text: `g` } })
    run(`a   \t \t \t  BCd  \t  \t \t  AnD \t \t\t \t \te( \t \t\t f):g`, { a: `Test Normalized Name A`, BCd: `Test Normalized Name B`, e: `Test Normalized Name C`, f: `Test Normalized Emote` }, { lineWithEmoteAndText: { characters: [{ name: `a`, normalizedName: `Test Normalized Name A` }, { name: `BCd`, normalizedName: `Test Normalized Name B` }, { name: `e`, normalizedName: `Test Normalized Name C` }], emote: `f`, normalizedEmote: `Test Normalized Emote`, text: `g` } })
    run(`a   \t \t \t  BCd  \t  \t \t  AnD \t \t\t \t \te(f   \t\t \t ):g`, { a: `Test Normalized Name A`, BCd: `Test Normalized Name B`, e: `Test Normalized Name C`, f: `Test Normalized Emote` }, { lineWithEmoteAndText: { characters: [{ name: `a`, normalizedName: `Test Normalized Name A` }, { name: `BCd`, normalizedName: `Test Normalized Name B` }, { name: `e`, normalizedName: `Test Normalized Name C` }], emote: `f`, normalizedEmote: `Test Normalized Emote`, text: `g` } })
    run(`a   \t \t \t  BCd  \t  \t \t  AnD \t \t\t \t \te(f)   \t\t \t    \t   \t :g`, { a: `Test Normalized Name A`, BCd: `Test Normalized Name B`, e: `Test Normalized Name C`, f: `Test Normalized Emote` }, { lineWithEmoteAndText: { characters: [{ name: `a`, normalizedName: `Test Normalized Name A` }, { name: `BCd`, normalizedName: `Test Normalized Name B` }, { name: `e`, normalizedName: `Test Normalized Name C` }], emote: `f`, normalizedEmote: `Test Normalized Emote`, text: `g` } })
    run(`a   \t \t \t  BCd  \t  \t \t  AnD \t \t\t \t \te(f):   \t\t \t    \t   \t g`, { a: `Test Normalized Name A`, BCd: `Test Normalized Name B`, e: `Test Normalized Name C`, f: `Test Normalized Emote` }, { lineWithEmoteAndText: { characters: [{ name: `a`, normalizedName: `Test Normalized Name A` }, { name: `BCd`, normalizedName: `Test Normalized Name B` }, { name: `e`, normalizedName: `Test Normalized Name C` }], emote: `f`, normalizedEmote: `Test Normalized Emote`, text: `g` } })
    run(`a   \t \t \t  b  \t  \t \t  AnD \t \t\t \t \tcDE(f):g`, { a: `Test Normalized Name A`, b: `Test Normalized Name B`, cDE: `Test Normalized Name C`, f: `Test Normalized Emote` }, { lineWithEmoteAndText: { characters: [{ name: `a`, normalizedName: `Test Normalized Name A` }, { name: `b`, normalizedName: `Test Normalized Name B` }, { name: `cDE`, normalizedName: `Test Normalized Name C` }], emote: `f`, normalizedEmote: `Test Normalized Emote`, text: `g` } })
    run(`a   \t \t \t  b  \t  \t \t  AnD \t \t\t \t \tcDE \t \t\t (f):g`, { a: `Test Normalized Name A`, b: `Test Normalized Name B`, cDE: `Test Normalized Name C`, f: `Test Normalized Emote` }, { lineWithEmoteAndText: { characters: [{ name: `a`, normalizedName: `Test Normalized Name A` }, { name: `b`, normalizedName: `Test Normalized Name B` }, { name: `cDE`, normalizedName: `Test Normalized Name C` }], emote: `f`, normalizedEmote: `Test Normalized Emote`, text: `g` } })
    run(`a   \t \t \t  b  \t  \t \t  AnD \t \t\t \t \tcDE( \t \t\t f):g`, { a: `Test Normalized Name A`, b: `Test Normalized Name B`, cDE: `Test Normalized Name C`, f: `Test Normalized Emote` }, { lineWithEmoteAndText: { characters: [{ name: `a`, normalizedName: `Test Normalized Name A` }, { name: `b`, normalizedName: `Test Normalized Name B` }, { name: `cDE`, normalizedName: `Test Normalized Name C` }], emote: `f`, normalizedEmote: `Test Normalized Emote`, text: `g` } })
    run(`a   \t \t \t  b  \t  \t \t  AnD \t \t\t \t \tcDE(f   \t\t \t ):g`, { a: `Test Normalized Name A`, b: `Test Normalized Name B`, cDE: `Test Normalized Name C`, f: `Test Normalized Emote` }, { lineWithEmoteAndText: { characters: [{ name: `a`, normalizedName: `Test Normalized Name A` }, { name: `b`, normalizedName: `Test Normalized Name B` }, { name: `cDE`, normalizedName: `Test Normalized Name C` }], emote: `f`, normalizedEmote: `Test Normalized Emote`, text: `g` } })
    run(`a   \t \t \t  b  \t  \t \t  AnD \t \t\t \t \tcDE(f)   \t\t \t    \t   \t :g`, { a: `Test Normalized Name A`, b: `Test Normalized Name B`, cDE: `Test Normalized Name C`, f: `Test Normalized Emote` }, { lineWithEmoteAndText: { characters: [{ name: `a`, normalizedName: `Test Normalized Name A` }, { name: `b`, normalizedName: `Test Normalized Name B` }, { name: `cDE`, normalizedName: `Test Normalized Name C` }], emote: `f`, normalizedEmote: `Test Normalized Emote`, text: `g` } })
    run(`a   \t \t \t  b  \t  \t \t  AnD \t \t\t \t \tcDE(f):   \t\t \t    \t   \t g`, { a: `Test Normalized Name A`, b: `Test Normalized Name B`, cDE: `Test Normalized Name C`, f: `Test Normalized Emote` }, { lineWithEmoteAndText: { characters: [{ name: `a`, normalizedName: `Test Normalized Name A` }, { name: `b`, normalizedName: `Test Normalized Name B` }, { name: `cDE`, normalizedName: `Test Normalized Name C` }], emote: `f`, normalizedEmote: `Test Normalized Emote`, text: `g` } })
    run(`a   \t \t \t  b  \t  \t \t  AnD \t \t\t \t \tc(dEf):g`, { a: `Test Normalized Name A`, b: `Test Normalized Name B`, c: `Test Normalized Name C`, dEf: `Test Normalized Emote` }, { lineWithEmoteAndText: { characters: [{ name: `a`, normalizedName: `Test Normalized Name A` }, { name: `b`, normalizedName: `Test Normalized Name B` }, { name: `c`, normalizedName: `Test Normalized Name C` }], emote: `dEf`, normalizedEmote: `Test Normalized Emote`, text: `g` } })
    run(`a   \t \t \t  b  \t  \t \t  AnD \t \t\t \t \tc \t \t\t (dEf):g`, { a: `Test Normalized Name A`, b: `Test Normalized Name B`, c: `Test Normalized Name C`, dEf: `Test Normalized Emote` }, { lineWithEmoteAndText: { characters: [{ name: `a`, normalizedName: `Test Normalized Name A` }, { name: `b`, normalizedName: `Test Normalized Name B` }, { name: `c`, normalizedName: `Test Normalized Name C` }], emote: `dEf`, normalizedEmote: `Test Normalized Emote`, text: `g` } })
    run(`a   \t \t \t  b  \t  \t \t  AnD \t \t\t \t \tc( \t \t\t dEf):g`, { a: `Test Normalized Name A`, b: `Test Normalized Name B`, c: `Test Normalized Name C`, dEf: `Test Normalized Emote` }, { lineWithEmoteAndText: { characters: [{ name: `a`, normalizedName: `Test Normalized Name A` }, { name: `b`, normalizedName: `Test Normalized Name B` }, { name: `c`, normalizedName: `Test Normalized Name C` }], emote: `dEf`, normalizedEmote: `Test Normalized Emote`, text: `g` } })
    run(`a   \t \t \t  b  \t  \t \t  AnD \t \t\t \t \tc(dEf   \t\t \t ):g`, { a: `Test Normalized Name A`, b: `Test Normalized Name B`, c: `Test Normalized Name C`, dEf: `Test Normalized Emote` }, { lineWithEmoteAndText: { characters: [{ name: `a`, normalizedName: `Test Normalized Name A` }, { name: `b`, normalizedName: `Test Normalized Name B` }, { name: `c`, normalizedName: `Test Normalized Name C` }], emote: `dEf`, normalizedEmote: `Test Normalized Emote`, text: `g` } })
    run(`a   \t \t \t  b  \t  \t \t  AnD \t \t\t \t \tc(dEf)   \t\t \t    \t   \t :g`, { a: `Test Normalized Name A`, b: `Test Normalized Name B`, c: `Test Normalized Name C`, dEf: `Test Normalized Emote` }, { lineWithEmoteAndText: { characters: [{ name: `a`, normalizedName: `Test Normalized Name A` }, { name: `b`, normalizedName: `Test Normalized Name B` }, { name: `c`, normalizedName: `Test Normalized Name C` }], emote: `dEf`, normalizedEmote: `Test Normalized Emote`, text: `g` } })
    run(`a   \t \t \t  b  \t  \t \t  AnD \t \t\t \t \tc(dEf):   \t\t \t    \t   \t g`, { a: `Test Normalized Name A`, b: `Test Normalized Name B`, c: `Test Normalized Name C`, dEf: `Test Normalized Emote` }, { lineWithEmoteAndText: { characters: [{ name: `a`, normalizedName: `Test Normalized Name A` }, { name: `b`, normalizedName: `Test Normalized Name B` }, { name: `c`, normalizedName: `Test Normalized Name C` }], emote: `dEf`, normalizedEmote: `Test Normalized Emote`, text: `g` } })
    run(`a   \t \t \t  b  \t  \t \t  AnD \t \t\t \t \tc \t \t\t (d):eFG \t \t \t\t hIJk \t : \t \t\t LMN`, { a: `Test Normalized Name A`, b: `Test Normalized Name B`, c: `Test Normalized Name C`, d: `Test Normalized Emote` }, { lineWithEmoteAndText: { characters: [{ name: `a`, normalizedName: `Test Normalized Name A` }, { name: `b`, normalizedName: `Test Normalized Name B` }, { name: `c`, normalizedName: `Test Normalized Name C` }], emote: `d`, normalizedEmote: `Test Normalized Emote`, text: `eFG \t \t \t\t hIJk \t : \t \t\t LMN` } })
    run(`a   \t \t \t  b  \t  \t \t  AnD \t \t\t \t \tc \t \t\t (   \t\t \t    \t   \t d):eFG \t \t \t\t hIJk \t : \t \t\t LMN`, { a: `Test Normalized Name A`, b: `Test Normalized Name B`, c: `Test Normalized Name C`, d: `Test Normalized Emote` }, { lineWithEmoteAndText: { characters: [{ name: `a`, normalizedName: `Test Normalized Name A` }, { name: `b`, normalizedName: `Test Normalized Name B` }, { name: `c`, normalizedName: `Test Normalized Name C` }], emote: `d`, normalizedEmote: `Test Normalized Emote`, text: `eFG \t \t \t\t hIJk \t : \t \t\t LMN` } })
    run(`a   \t \t \t  b  \t  \t \t  AnD \t \t\t \t \tc \t \t\t (d   \t\t \t    \t   \t ):eFG \t \t \t\t hIJk \t : \t \t\t LMN`, { a: `Test Normalized Name A`, b: `Test Normalized Name B`, c: `Test Normalized Name C`, d: `Test Normalized Emote` }, { lineWithEmoteAndText: { characters: [{ name: `a`, normalizedName: `Test Normalized Name A` }, { name: `b`, normalizedName: `Test Normalized Name B` }, { name: `c`, normalizedName: `Test Normalized Name C` }], emote: `d`, normalizedEmote: `Test Normalized Emote`, text: `eFG \t \t \t\t hIJk \t : \t \t\t LMN` } })
    run(`a   \t \t \t  b  \t  \t \t  AnD \t \t\t \t \tc \t \t\t (d)   \t\t \t    \t   \t :eFG \t \t \t\t hIJk \t : \t \t\t LMN`, { a: `Test Normalized Name A`, b: `Test Normalized Name B`, c: `Test Normalized Name C`, d: `Test Normalized Emote` }, { lineWithEmoteAndText: { characters: [{ name: `a`, normalizedName: `Test Normalized Name A` }, { name: `b`, normalizedName: `Test Normalized Name B` }, { name: `c`, normalizedName: `Test Normalized Name C` }], emote: `d`, normalizedEmote: `Test Normalized Emote`, text: `eFG \t \t \t\t hIJk \t : \t \t\t LMN` } })
    run(`a   \t \t \t  b  \t  \t \t  AnD \t \t\t \t \tc \t \t\t (d):   \t\t \t    \t   \t eFG \t \t \t\t hIJk \t : \t \t\t LMN`, { a: `Test Normalized Name A`, b: `Test Normalized Name B`, c: `Test Normalized Name C`, d: `Test Normalized Emote` }, { lineWithEmoteAndText: { characters: [{ name: `a`, normalizedName: `Test Normalized Name A` }, { name: `b`, normalizedName: `Test Normalized Name B` }, { name: `c`, normalizedName: `Test Normalized Name C` }], emote: `d`, normalizedEmote: `Test Normalized Emote`, text: `eFG \t \t \t\t hIJk \t : \t \t\t LMN` } })
    run(`a  \t  \t \t  b \t c\t\t AnD \t  \td(e):f`, { a: `Test Normalized Name A`, b: `Test Normalized Name B`, c: `Test Normalized Name C`, d: `Test Normalized Name D`, e: `Test Normalized Emote` }, { lineWithEmoteAndText: { characters: [{ name: `a`, normalizedName: `Test Normalized Name A` }, { name: `b`, normalizedName: `Test Normalized Name B` }, { name: `c`, normalizedName: `Test Normalized Name C` }, { name: `d`, normalizedName: `Test Normalized Name D` }], emote: `e`, normalizedEmote: `Test Normalized Emote`, text: `f` } })
    run(`a  \t  \t \t  b \t c\t\t AnD \t  \td   \t\t \t(e):f`, { a: `Test Normalized Name A`, b: `Test Normalized Name B`, c: `Test Normalized Name C`, d: `Test Normalized Name D`, e: `Test Normalized Emote` }, { lineWithEmoteAndText: { characters: [{ name: `a`, normalizedName: `Test Normalized Name A` }, { name: `b`, normalizedName: `Test Normalized Name B` }, { name: `c`, normalizedName: `Test Normalized Name C` }, { name: `d`, normalizedName: `Test Normalized Name D` }], emote: `e`, normalizedEmote: `Test Normalized Emote`, text: `f` } })
    run(`a  \t  \t \t  b \t c\t\t AnD \t  \td(  \t\t \t e):f`, { a: `Test Normalized Name A`, b: `Test Normalized Name B`, c: `Test Normalized Name C`, d: `Test Normalized Name D`, e: `Test Normalized Emote` }, { lineWithEmoteAndText: { characters: [{ name: `a`, normalizedName: `Test Normalized Name A` }, { name: `b`, normalizedName: `Test Normalized Name B` }, { name: `c`, normalizedName: `Test Normalized Name C` }, { name: `d`, normalizedName: `Test Normalized Name D` }], emote: `e`, normalizedEmote: `Test Normalized Emote`, text: `f` } })
    run(`a  \t  \t \t  b \t c\t\t AnD \t  \td(e \t\t     ):f`, { a: `Test Normalized Name A`, b: `Test Normalized Name B`, c: `Test Normalized Name C`, d: `Test Normalized Name D`, e: `Test Normalized Emote` }, { lineWithEmoteAndText: { characters: [{ name: `a`, normalizedName: `Test Normalized Name A` }, { name: `b`, normalizedName: `Test Normalized Name B` }, { name: `c`, normalizedName: `Test Normalized Name C` }, { name: `d`, normalizedName: `Test Normalized Name D` }], emote: `e`, normalizedEmote: `Test Normalized Emote`, text: `f` } })
    run(`a  \t  \t \t  b \t c\t\t AnD \t  \td(e)  \t \t   :f`, { a: `Test Normalized Name A`, b: `Test Normalized Name B`, c: `Test Normalized Name C`, d: `Test Normalized Name D`, e: `Test Normalized Emote` }, { lineWithEmoteAndText: { characters: [{ name: `a`, normalizedName: `Test Normalized Name A` }, { name: `b`, normalizedName: `Test Normalized Name B` }, { name: `c`, normalizedName: `Test Normalized Name C` }, { name: `d`, normalizedName: `Test Normalized Name D` }], emote: `e`, normalizedEmote: `Test Normalized Emote`, text: `f` } })
    run(`a  \t  \t \t  b \t c\t\t AnD \t  \td(e):  \t \t   f`, { a: `Test Normalized Name A`, b: `Test Normalized Name B`, c: `Test Normalized Name C`, d: `Test Normalized Name D`, e: `Test Normalized Emote` }, { lineWithEmoteAndText: { characters: [{ name: `a`, normalizedName: `Test Normalized Name A` }, { name: `b`, normalizedName: `Test Normalized Name B` }, { name: `c`, normalizedName: `Test Normalized Name C` }, { name: `d`, normalizedName: `Test Normalized Name D` }], emote: `e`, normalizedEmote: `Test Normalized Emote`, text: `f` } })
    run(`aBC  \t  \t \t  d \t e\t\t AnD \t  \tf(g):h`, { aBC: `Test Normalized Name A`, d: `Test Normalized Name B`, e: `Test Normalized Name C`, f: `Test Normalized Name D`, g: `Test Normalized Emote` }, { lineWithEmoteAndText: { characters: [{ name: `aBC`, normalizedName: `Test Normalized Name A` }, { name: `d`, normalizedName: `Test Normalized Name B` }, { name: `e`, normalizedName: `Test Normalized Name C` }, { name: `f`, normalizedName: `Test Normalized Name D` }], emote: `g`, normalizedEmote: `Test Normalized Emote`, text: `h` } })
    run(`aBC  \t  \t \t  d \t e\t\t AnD \t  \tf   \t\t \t(g):h`, { aBC: `Test Normalized Name A`, d: `Test Normalized Name B`, e: `Test Normalized Name C`, f: `Test Normalized Name D`, g: `Test Normalized Emote` }, { lineWithEmoteAndText: { characters: [{ name: `aBC`, normalizedName: `Test Normalized Name A` }, { name: `d`, normalizedName: `Test Normalized Name B` }, { name: `e`, normalizedName: `Test Normalized Name C` }, { name: `f`, normalizedName: `Test Normalized Name D` }], emote: `g`, normalizedEmote: `Test Normalized Emote`, text: `h` } })
    run(`aBC  \t  \t \t  d \t e\t\t AnD \t  \tf(  \t\t \t g):h`, { aBC: `Test Normalized Name A`, d: `Test Normalized Name B`, e: `Test Normalized Name C`, f: `Test Normalized Name D`, g: `Test Normalized Emote` }, { lineWithEmoteAndText: { characters: [{ name: `aBC`, normalizedName: `Test Normalized Name A` }, { name: `d`, normalizedName: `Test Normalized Name B` }, { name: `e`, normalizedName: `Test Normalized Name C` }, { name: `f`, normalizedName: `Test Normalized Name D` }], emote: `g`, normalizedEmote: `Test Normalized Emote`, text: `h` } })
    run(`aBC  \t  \t \t  d \t e\t\t AnD \t  \tf(g \t\t     ):h`, { aBC: `Test Normalized Name A`, d: `Test Normalized Name B`, e: `Test Normalized Name C`, f: `Test Normalized Name D`, g: `Test Normalized Emote` }, { lineWithEmoteAndText: { characters: [{ name: `aBC`, normalizedName: `Test Normalized Name A` }, { name: `d`, normalizedName: `Test Normalized Name B` }, { name: `e`, normalizedName: `Test Normalized Name C` }, { name: `f`, normalizedName: `Test Normalized Name D` }], emote: `g`, normalizedEmote: `Test Normalized Emote`, text: `h` } })
    run(`aBC  \t  \t \t  d \t e\t\t AnD \t  \tf(g)  \t \t   :h`, { aBC: `Test Normalized Name A`, d: `Test Normalized Name B`, e: `Test Normalized Name C`, f: `Test Normalized Name D`, g: `Test Normalized Emote` }, { lineWithEmoteAndText: { characters: [{ name: `aBC`, normalizedName: `Test Normalized Name A` }, { name: `d`, normalizedName: `Test Normalized Name B` }, { name: `e`, normalizedName: `Test Normalized Name C` }, { name: `f`, normalizedName: `Test Normalized Name D` }], emote: `g`, normalizedEmote: `Test Normalized Emote`, text: `h` } })
    run(`aBC  \t  \t \t  d \t e\t\t AnD \t  \tf(g):  \t \t   h`, { aBC: `Test Normalized Name A`, d: `Test Normalized Name B`, e: `Test Normalized Name C`, f: `Test Normalized Name D`, g: `Test Normalized Emote` }, { lineWithEmoteAndText: { characters: [{ name: `aBC`, normalizedName: `Test Normalized Name A` }, { name: `d`, normalizedName: `Test Normalized Name B` }, { name: `e`, normalizedName: `Test Normalized Name C` }, { name: `f`, normalizedName: `Test Normalized Name D` }], emote: `g`, normalizedEmote: `Test Normalized Emote`, text: `h` } })
    run(`a  \t  \t \t  BCd \t e\t\t AnD \t  \tf(g):h`, { a: `Test Normalized Name A`, BCd: `Test Normalized Name B`, e: `Test Normalized Name C`, f: `Test Normalized Name D`, g: `Test Normalized Emote` }, { lineWithEmoteAndText: { characters: [{ name: `a`, normalizedName: `Test Normalized Name A` }, { name: `BCd`, normalizedName: `Test Normalized Name B` }, { name: `e`, normalizedName: `Test Normalized Name C` }, { name: `f`, normalizedName: `Test Normalized Name D` }], emote: `g`, normalizedEmote: `Test Normalized Emote`, text: `h` } })
    run(`a  \t  \t \t  BCd \t e\t\t AnD \t  \tf   \t\t \t(g):h`, { a: `Test Normalized Name A`, BCd: `Test Normalized Name B`, e: `Test Normalized Name C`, f: `Test Normalized Name D`, g: `Test Normalized Emote` }, { lineWithEmoteAndText: { characters: [{ name: `a`, normalizedName: `Test Normalized Name A` }, { name: `BCd`, normalizedName: `Test Normalized Name B` }, { name: `e`, normalizedName: `Test Normalized Name C` }, { name: `f`, normalizedName: `Test Normalized Name D` }], emote: `g`, normalizedEmote: `Test Normalized Emote`, text: `h` } })
    run(`a  \t  \t \t  BCd \t e\t\t AnD \t  \tf(  \t\t \t g):h`, { a: `Test Normalized Name A`, BCd: `Test Normalized Name B`, e: `Test Normalized Name C`, f: `Test Normalized Name D`, g: `Test Normalized Emote` }, { lineWithEmoteAndText: { characters: [{ name: `a`, normalizedName: `Test Normalized Name A` }, { name: `BCd`, normalizedName: `Test Normalized Name B` }, { name: `e`, normalizedName: `Test Normalized Name C` }, { name: `f`, normalizedName: `Test Normalized Name D` }], emote: `g`, normalizedEmote: `Test Normalized Emote`, text: `h` } })
    run(`a  \t  \t \t  BCd \t e\t\t AnD \t  \tf(g \t\t     ):h`, { a: `Test Normalized Name A`, BCd: `Test Normalized Name B`, e: `Test Normalized Name C`, f: `Test Normalized Name D`, g: `Test Normalized Emote` }, { lineWithEmoteAndText: { characters: [{ name: `a`, normalizedName: `Test Normalized Name A` }, { name: `BCd`, normalizedName: `Test Normalized Name B` }, { name: `e`, normalizedName: `Test Normalized Name C` }, { name: `f`, normalizedName: `Test Normalized Name D` }], emote: `g`, normalizedEmote: `Test Normalized Emote`, text: `h` } })
    run(`a  \t  \t \t  BCd \t e\t\t AnD \t  \tf(g)  \t \t   :h`, { a: `Test Normalized Name A`, BCd: `Test Normalized Name B`, e: `Test Normalized Name C`, f: `Test Normalized Name D`, g: `Test Normalized Emote` }, { lineWithEmoteAndText: { characters: [{ name: `a`, normalizedName: `Test Normalized Name A` }, { name: `BCd`, normalizedName: `Test Normalized Name B` }, { name: `e`, normalizedName: `Test Normalized Name C` }, { name: `f`, normalizedName: `Test Normalized Name D` }], emote: `g`, normalizedEmote: `Test Normalized Emote`, text: `h` } })
    run(`a  \t  \t \t  BCd \t e\t\t AnD \t  \tf(g):  \t \t   h`, { a: `Test Normalized Name A`, BCd: `Test Normalized Name B`, e: `Test Normalized Name C`, f: `Test Normalized Name D`, g: `Test Normalized Emote` }, { lineWithEmoteAndText: { characters: [{ name: `a`, normalizedName: `Test Normalized Name A` }, { name: `BCd`, normalizedName: `Test Normalized Name B` }, { name: `e`, normalizedName: `Test Normalized Name C` }, { name: `f`, normalizedName: `Test Normalized Name D` }], emote: `g`, normalizedEmote: `Test Normalized Emote`, text: `h` } })
    run(`a  \t  \t \t  b \t cDE\t\t AnD \t  \tf(g):h`, { a: `Test Normalized Name A`, b: `Test Normalized Name B`, cDE: `Test Normalized Name C`, f: `Test Normalized Name D`, g: `Test Normalized Emote` }, { lineWithEmoteAndText: { characters: [{ name: `a`, normalizedName: `Test Normalized Name A` }, { name: `b`, normalizedName: `Test Normalized Name B` }, { name: `cDE`, normalizedName: `Test Normalized Name C` }, { name: `f`, normalizedName: `Test Normalized Name D` }], emote: `g`, normalizedEmote: `Test Normalized Emote`, text: `h` } })
    run(`a  \t  \t \t  b \t cDE\t\t AnD \t  \tf   \t\t \t(g):h`, { a: `Test Normalized Name A`, b: `Test Normalized Name B`, cDE: `Test Normalized Name C`, f: `Test Normalized Name D`, g: `Test Normalized Emote` }, { lineWithEmoteAndText: { characters: [{ name: `a`, normalizedName: `Test Normalized Name A` }, { name: `b`, normalizedName: `Test Normalized Name B` }, { name: `cDE`, normalizedName: `Test Normalized Name C` }, { name: `f`, normalizedName: `Test Normalized Name D` }], emote: `g`, normalizedEmote: `Test Normalized Emote`, text: `h` } })
    run(`a  \t  \t \t  b \t cDE\t\t AnD \t  \tf(  \t\t \t g):h`, { a: `Test Normalized Name A`, b: `Test Normalized Name B`, cDE: `Test Normalized Name C`, f: `Test Normalized Name D`, g: `Test Normalized Emote` }, { lineWithEmoteAndText: { characters: [{ name: `a`, normalizedName: `Test Normalized Name A` }, { name: `b`, normalizedName: `Test Normalized Name B` }, { name: `cDE`, normalizedName: `Test Normalized Name C` }, { name: `f`, normalizedName: `Test Normalized Name D` }], emote: `g`, normalizedEmote: `Test Normalized Emote`, text: `h` } })
    run(`a  \t  \t \t  b \t cDE\t\t AnD \t  \tf(g \t\t     ):h`, { a: `Test Normalized Name A`, b: `Test Normalized Name B`, cDE: `Test Normalized Name C`, f: `Test Normalized Name D`, g: `Test Normalized Emote` }, { lineWithEmoteAndText: { characters: [{ name: `a`, normalizedName: `Test Normalized Name A` }, { name: `b`, normalizedName: `Test Normalized Name B` }, { name: `cDE`, normalizedName: `Test Normalized Name C` }, { name: `f`, normalizedName: `Test Normalized Name D` }], emote: `g`, normalizedEmote: `Test Normalized Emote`, text: `h` } })
    run(`a  \t  \t \t  b \t cDE\t\t AnD \t  \tf(g)  \t \t   :h`, { a: `Test Normalized Name A`, b: `Test Normalized Name B`, cDE: `Test Normalized Name C`, f: `Test Normalized Name D`, g: `Test Normalized Emote` }, { lineWithEmoteAndText: { characters: [{ name: `a`, normalizedName: `Test Normalized Name A` }, { name: `b`, normalizedName: `Test Normalized Name B` }, { name: `cDE`, normalizedName: `Test Normalized Name C` }, { name: `f`, normalizedName: `Test Normalized Name D` }], emote: `g`, normalizedEmote: `Test Normalized Emote`, text: `h` } })
    run(`a  \t  \t \t  b \t cDE\t\t AnD \t  \tf(g):  \t \t   h`, { a: `Test Normalized Name A`, b: `Test Normalized Name B`, cDE: `Test Normalized Name C`, f: `Test Normalized Name D`, g: `Test Normalized Emote` }, { lineWithEmoteAndText: { characters: [{ name: `a`, normalizedName: `Test Normalized Name A` }, { name: `b`, normalizedName: `Test Normalized Name B` }, { name: `cDE`, normalizedName: `Test Normalized Name C` }, { name: `f`, normalizedName: `Test Normalized Name D` }], emote: `g`, normalizedEmote: `Test Normalized Emote`, text: `h` } })
    run(`a  \t  \t \t  b \t c\t\t AnD \t  \tdEf(g):h`, { a: `Test Normalized Name A`, b: `Test Normalized Name B`, c: `Test Normalized Name C`, dEf: `Test Normalized Name D`, g: `Test Normalized Emote` }, { lineWithEmoteAndText: { characters: [{ name: `a`, normalizedName: `Test Normalized Name A` }, { name: `b`, normalizedName: `Test Normalized Name B` }, { name: `c`, normalizedName: `Test Normalized Name C` }, { name: `dEf`, normalizedName: `Test Normalized Name D` }], emote: `g`, normalizedEmote: `Test Normalized Emote`, text: `h` } })
    run(`a  \t  \t \t  b \t c\t\t AnD \t  \tdEf   \t\t \t(g):h`, { a: `Test Normalized Name A`, b: `Test Normalized Name B`, c: `Test Normalized Name C`, dEf: `Test Normalized Name D`, g: `Test Normalized Emote` }, { lineWithEmoteAndText: { characters: [{ name: `a`, normalizedName: `Test Normalized Name A` }, { name: `b`, normalizedName: `Test Normalized Name B` }, { name: `c`, normalizedName: `Test Normalized Name C` }, { name: `dEf`, normalizedName: `Test Normalized Name D` }], emote: `g`, normalizedEmote: `Test Normalized Emote`, text: `h` } })
    run(`a  \t  \t \t  b \t c\t\t AnD \t  \tdEf(  \t\t \t g):h`, { a: `Test Normalized Name A`, b: `Test Normalized Name B`, c: `Test Normalized Name C`, dEf: `Test Normalized Name D`, g: `Test Normalized Emote` }, { lineWithEmoteAndText: { characters: [{ name: `a`, normalizedName: `Test Normalized Name A` }, { name: `b`, normalizedName: `Test Normalized Name B` }, { name: `c`, normalizedName: `Test Normalized Name C` }, { name: `dEf`, normalizedName: `Test Normalized Name D` }], emote: `g`, normalizedEmote: `Test Normalized Emote`, text: `h` } })
    run(`a  \t  \t \t  b \t c\t\t AnD \t  \tdEf(g \t\t     ):h`, { a: `Test Normalized Name A`, b: `Test Normalized Name B`, c: `Test Normalized Name C`, dEf: `Test Normalized Name D`, g: `Test Normalized Emote` }, { lineWithEmoteAndText: { characters: [{ name: `a`, normalizedName: `Test Normalized Name A` }, { name: `b`, normalizedName: `Test Normalized Name B` }, { name: `c`, normalizedName: `Test Normalized Name C` }, { name: `dEf`, normalizedName: `Test Normalized Name D` }], emote: `g`, normalizedEmote: `Test Normalized Emote`, text: `h` } })
    run(`a  \t  \t \t  b \t c\t\t AnD \t  \tdEf(g)  \t \t   :h`, { a: `Test Normalized Name A`, b: `Test Normalized Name B`, c: `Test Normalized Name C`, dEf: `Test Normalized Name D`, g: `Test Normalized Emote` }, { lineWithEmoteAndText: { characters: [{ name: `a`, normalizedName: `Test Normalized Name A` }, { name: `b`, normalizedName: `Test Normalized Name B` }, { name: `c`, normalizedName: `Test Normalized Name C` }, { name: `dEf`, normalizedName: `Test Normalized Name D` }], emote: `g`, normalizedEmote: `Test Normalized Emote`, text: `h` } })
    run(`a  \t  \t \t  b \t c\t\t AnD \t  \tdEf(g):  \t \t   h`, { a: `Test Normalized Name A`, b: `Test Normalized Name B`, c: `Test Normalized Name C`, dEf: `Test Normalized Name D`, g: `Test Normalized Emote` }, { lineWithEmoteAndText: { characters: [{ name: `a`, normalizedName: `Test Normalized Name A` }, { name: `b`, normalizedName: `Test Normalized Name B` }, { name: `c`, normalizedName: `Test Normalized Name C` }, { name: `dEf`, normalizedName: `Test Normalized Name D` }], emote: `g`, normalizedEmote: `Test Normalized Emote`, text: `h` } })
    run(`a  \t  \t \t  b \t c\t\t AnD \t  \td(eFG):h`, { a: `Test Normalized Name A`, b: `Test Normalized Name B`, c: `Test Normalized Name C`, d: `Test Normalized Name D`, eFG: `Test Normalized Emote` }, { lineWithEmoteAndText: { characters: [{ name: `a`, normalizedName: `Test Normalized Name A` }, { name: `b`, normalizedName: `Test Normalized Name B` }, { name: `c`, normalizedName: `Test Normalized Name C` }, { name: `d`, normalizedName: `Test Normalized Name D` }], emote: `eFG`, normalizedEmote: `Test Normalized Emote`, text: `h` } })
    run(`a  \t  \t \t  b \t c\t\t AnD \t  \td   \t\t \t(eFG):h`, { a: `Test Normalized Name A`, b: `Test Normalized Name B`, c: `Test Normalized Name C`, d: `Test Normalized Name D`, eFG: `Test Normalized Emote` }, { lineWithEmoteAndText: { characters: [{ name: `a`, normalizedName: `Test Normalized Name A` }, { name: `b`, normalizedName: `Test Normalized Name B` }, { name: `c`, normalizedName: `Test Normalized Name C` }, { name: `d`, normalizedName: `Test Normalized Name D` }], emote: `eFG`, normalizedEmote: `Test Normalized Emote`, text: `h` } })
    run(`a  \t  \t \t  b \t c\t\t AnD \t  \td(  \t\t \t eFG):h`, { a: `Test Normalized Name A`, b: `Test Normalized Name B`, c: `Test Normalized Name C`, d: `Test Normalized Name D`, eFG: `Test Normalized Emote` }, { lineWithEmoteAndText: { characters: [{ name: `a`, normalizedName: `Test Normalized Name A` }, { name: `b`, normalizedName: `Test Normalized Name B` }, { name: `c`, normalizedName: `Test Normalized Name C` }, { name: `d`, normalizedName: `Test Normalized Name D` }], emote: `eFG`, normalizedEmote: `Test Normalized Emote`, text: `h` } })
    run(`a  \t  \t \t  b \t c\t\t AnD \t  \td(eFG \t\t     ):h`, { a: `Test Normalized Name A`, b: `Test Normalized Name B`, c: `Test Normalized Name C`, d: `Test Normalized Name D`, eFG: `Test Normalized Emote` }, { lineWithEmoteAndText: { characters: [{ name: `a`, normalizedName: `Test Normalized Name A` }, { name: `b`, normalizedName: `Test Normalized Name B` }, { name: `c`, normalizedName: `Test Normalized Name C` }, { name: `d`, normalizedName: `Test Normalized Name D` }], emote: `eFG`, normalizedEmote: `Test Normalized Emote`, text: `h` } })
    run(`a  \t  \t \t  b \t c\t\t AnD \t  \td(eFG)  \t \t   :h`, { a: `Test Normalized Name A`, b: `Test Normalized Name B`, c: `Test Normalized Name C`, d: `Test Normalized Name D`, eFG: `Test Normalized Emote` }, { lineWithEmoteAndText: { characters: [{ name: `a`, normalizedName: `Test Normalized Name A` }, { name: `b`, normalizedName: `Test Normalized Name B` }, { name: `c`, normalizedName: `Test Normalized Name C` }, { name: `d`, normalizedName: `Test Normalized Name D` }], emote: `eFG`, normalizedEmote: `Test Normalized Emote`, text: `h` } })
    run(`a  \t  \t \t  b \t c\t\t AnD \t  \td(eFG):  \t \t   h`, { a: `Test Normalized Name A`, b: `Test Normalized Name B`, c: `Test Normalized Name C`, d: `Test Normalized Name D`, eFG: `Test Normalized Emote` }, { lineWithEmoteAndText: { characters: [{ name: `a`, normalizedName: `Test Normalized Name A` }, { name: `b`, normalizedName: `Test Normalized Name B` }, { name: `c`, normalizedName: `Test Normalized Name C` }, { name: `d`, normalizedName: `Test Normalized Name D` }], emote: `eFG`, normalizedEmote: `Test Normalized Emote`, text: `h` } })
    run(`a  \t  \t \t  b \t c\t\t AnD \t  \td   \t\t \t(e):fgh \t \t \t\t ijKL \t : \t \t\t mno`, { a: `Test Normalized Name A`, b: `Test Normalized Name B`, c: `Test Normalized Name C`, d: `Test Normalized Name D`, e: `Test Normalized Emote` }, { lineWithEmoteAndText: { characters: [{ name: `a`, normalizedName: `Test Normalized Name A` }, { name: `b`, normalizedName: `Test Normalized Name B` }, { name: `c`, normalizedName: `Test Normalized Name C` }, { name: `d`, normalizedName: `Test Normalized Name D` }], emote: `e`, normalizedEmote: `Test Normalized Emote`, text: `fgh \t \t \t\t ijKL \t : \t \t\t mno` } })
    run(`a  \t  \t \t  b \t c\t\t AnD \t  \td   \t\t \t(  \t \t   e):fgh \t \t \t\t ijKL \t : \t \t\t mno`, { a: `Test Normalized Name A`, b: `Test Normalized Name B`, c: `Test Normalized Name C`, d: `Test Normalized Name D`, e: `Test Normalized Emote` }, { lineWithEmoteAndText: { characters: [{ name: `a`, normalizedName: `Test Normalized Name A` }, { name: `b`, normalizedName: `Test Normalized Name B` }, { name: `c`, normalizedName: `Test Normalized Name C` }, { name: `d`, normalizedName: `Test Normalized Name D` }], emote: `e`, normalizedEmote: `Test Normalized Emote`, text: `fgh \t \t \t\t ijKL \t : \t \t\t mno` } })
    run(`a  \t  \t \t  b \t c\t\t AnD \t  \td   \t\t \t(e  \t \t   ):fgh \t \t \t\t ijKL \t : \t \t\t mno`, { a: `Test Normalized Name A`, b: `Test Normalized Name B`, c: `Test Normalized Name C`, d: `Test Normalized Name D`, e: `Test Normalized Emote` }, { lineWithEmoteAndText: { characters: [{ name: `a`, normalizedName: `Test Normalized Name A` }, { name: `b`, normalizedName: `Test Normalized Name B` }, { name: `c`, normalizedName: `Test Normalized Name C` }, { name: `d`, normalizedName: `Test Normalized Name D` }], emote: `e`, normalizedEmote: `Test Normalized Emote`, text: `fgh \t \t \t\t ijKL \t : \t \t\t mno` } })
    run(`a  \t  \t \t  b \t c\t\t AnD \t  \td   \t\t \t(e)  \t \t   :fgh \t \t \t\t ijKL \t : \t \t\t mno`, { a: `Test Normalized Name A`, b: `Test Normalized Name B`, c: `Test Normalized Name C`, d: `Test Normalized Name D`, e: `Test Normalized Emote` }, { lineWithEmoteAndText: { characters: [{ name: `a`, normalizedName: `Test Normalized Name A` }, { name: `b`, normalizedName: `Test Normalized Name B` }, { name: `c`, normalizedName: `Test Normalized Name C` }, { name: `d`, normalizedName: `Test Normalized Name D` }], emote: `e`, normalizedEmote: `Test Normalized Emote`, text: `fgh \t \t \t\t ijKL \t : \t \t\t mno` } })
    run(`a  \t  \t \t  b \t c\t\t AnD \t  \td   \t\t \t(e):  \t \t   fgh \t \t \t\t ijKL \t : \t \t\t mno`, { a: `Test Normalized Name A`, b: `Test Normalized Name B`, c: `Test Normalized Name C`, d: `Test Normalized Name D`, e: `Test Normalized Emote` }, { lineWithEmoteAndText: { characters: [{ name: `a`, normalizedName: `Test Normalized Name A` }, { name: `b`, normalizedName: `Test Normalized Name B` }, { name: `c`, normalizedName: `Test Normalized Name C` }, { name: `d`, normalizedName: `Test Normalized Name D` }], emote: `e`, normalizedEmote: `Test Normalized Emote`, text: `fgh \t \t \t\t ijKL \t : \t \t\t mno` } })
  })
  describe(`emote`, () => {
    run(`a \t\t \t iS \t \t b`, { a: `Test Normalized Name A`, b: `Test Normalized Emote` }, { emote: { characters: [{ name: `a`, normalizedName: `Test Normalized Name A` }], emote: `b`, normalizedEmote: `Test Normalized Emote` } })
    run(`aBc \t\t \t iS \t \t b`, { aBc: `Test Normalized Name A`, b: `Test Normalized Emote` }, { emote: { characters: [{ name: `aBc`, normalizedName: `Test Normalized Name A` }], emote: `b`, normalizedEmote: `Test Normalized Emote` } })
    run(`a \t\t \t iS \t \t bCD`, { a: `Test Normalized Name A`, bCD: `Test Normalized Emote` }, { emote: { characters: [{ name: `a`, normalizedName: `Test Normalized Name A` }], emote: `bCD`, normalizedEmote: `Test Normalized Emote` } })
    /* TODO: This line looks like a mistake. */ run(`a \t\t \t iS \t \t b`, { a: `Test Normalized Name A`, b: `Test Normalized Emote` }, { emote: { characters: [{ name: `a`, normalizedName: `Test Normalized Name A` }], emote: `b`, normalizedEmote: `Test Normalized Emote` } })
    run(`a \t\t \t and  \t \t B \t\t \t Are \t \t c`, { a: `Test Normalized Name A`, B: `Test Normalized Name B`, c: `Test Normalized Emote` }, { emote: { characters: [{ name: `a`, normalizedName: `Test Normalized Name A` }, { name: `B`, normalizedName: `Test Normalized Name B` }], emote: `c`, normalizedEmote: `Test Normalized Emote` } })
    run(`aBC \t\t \t and  \t \t D \t\t \t are \t \t e`, { aBC: `Test Normalized Name A`, D: `Test Normalized Name B`, e: `Test Normalized Emote` }, { emote: { characters: [{ name: `aBC`, normalizedName: `Test Normalized Name A` }, { name: `D`, normalizedName: `Test Normalized Name B` }], emote: `e`, normalizedEmote: `Test Normalized Emote` } })
    run(`a \t\t \t and  \t \t BcD \t\t \t are \t \t e`, { a: `Test Normalized Name A`, BcD: `Test Normalized Name B`, e: `Test Normalized Emote` }, { emote: { characters: [{ name: `a`, normalizedName: `Test Normalized Name A` }, { name: `BcD`, normalizedName: `Test Normalized Name B` }], emote: `e`, normalizedEmote: `Test Normalized Emote` } })
    run(`a \t\t \t and  \t \t B \t\t \t ARE \t \t cDE`, { a: `Test Normalized Name A`, B: `Test Normalized Name B`, cDE: `Test Normalized Emote` }, { emote: { characters: [{ name: `a`, normalizedName: `Test Normalized Name A` }, { name: `B`, normalizedName: `Test Normalized Name B` }], emote: `cDE`, normalizedEmote: `Test Normalized Emote` } })
    run(`a \t\t \t B \t       \t and  \t \t C \t\t \t Are \t \t d`, { a: `Test Normalized Name A`, B: `Test Normalized Name B`, C: `Test Normalized Name C`, d: `Test Normalized Emote` }, { emote: { characters: [{ name: `a`, normalizedName: `Test Normalized Name A` }, { name: `B`, normalizedName: `Test Normalized Name B` }, { name: `C`, normalizedName: `Test Normalized Name C` }], emote: `d`, normalizedEmote: `Test Normalized Emote` } })
    run(`aBC \t\t \t d \t       \t and  \t \t e \t\t \t ArE \t \t f`, { aBC: `Test Normalized Name A`, d: `Test Normalized Name B`, e: `Test Normalized Name C`, f: `Test Normalized Emote` }, { emote: { characters: [{ name: `aBC`, normalizedName: `Test Normalized Name A` }, { name: `d`, normalizedName: `Test Normalized Name B` }, { name: `e`, normalizedName: `Test Normalized Name C` }], emote: `f`, normalizedEmote: `Test Normalized Emote` } })
    run(`a \t\t \t bCd \t       \t and  \t \t e \t\t \t aRe \t \t f`, { a: `Test Normalized Name A`, bCd: `Test Normalized Name B`, e: `Test Normalized Name C`, f: `Test Normalized Emote` }, { emote: { characters: [{ name: `a`, normalizedName: `Test Normalized Name A` }, { name: `bCd`, normalizedName: `Test Normalized Name B` }, { name: `e`, normalizedName: `Test Normalized Name C` }], emote: `f`, normalizedEmote: `Test Normalized Emote` } })
    run(`a \t\t \t B \t       \t and  \t \t cdE \t\t \t arE \t \t f`, { a: `Test Normalized Name A`, B: `Test Normalized Name B`, cdE: `Test Normalized Name C`, f: `Test Normalized Emote` }, { emote: { characters: [{ name: `a`, normalizedName: `Test Normalized Name A` }, { name: `B`, normalizedName: `Test Normalized Name B` }, { name: `cdE`, normalizedName: `Test Normalized Name C` }], emote: `f`, normalizedEmote: `Test Normalized Emote` } })
    run(`a \t\t \t b \t       \t and  \t \t C \t\t \t ARE \t \t Def`, { a: `Test Normalized Name A`, b: `Test Normalized Name B`, C: `Test Normalized Name C`, Def: `Test Normalized Emote` }, { emote: { characters: [{ name: `a`, normalizedName: `Test Normalized Name A` }, { name: `b`, normalizedName: `Test Normalized Name B` }, { name: `C`, normalizedName: `Test Normalized Name C` }], emote: `Def`, normalizedEmote: `Test Normalized Emote` } })
    run(`a \t\t \t B \t       \t c\t \tand  \t \t d \t\t \t ARE \t \t E`, { a: `Test Normalized Name A`, B: `Test Normalized Name B`, c: `Test Normalized Name C`, d: `Test Normalized Name D`, E: `Test Normalized Emote` }, { emote: { characters: [{ name: `a`, normalizedName: `Test Normalized Name A` }, { name: `B`, normalizedName: `Test Normalized Name B` }, { name: `c`, normalizedName: `Test Normalized Name C` }, { name: `d`, normalizedName: `Test Normalized Name D` }], emote: `E`, normalizedEmote: `Test Normalized Emote` } })
    run(`ABC \t\t \t d \t       \t e\t \tand  \t \t f \t\t \t are \t \t g`, { ABC: `Test Normalized Name A`, d: `Test Normalized Name B`, e: `Test Normalized Name C`, f: `Test Normalized Name D`, g: `Test Normalized Emote` }, { emote: { characters: [{ name: `ABC`, normalizedName: `Test Normalized Name A` }, { name: `d`, normalizedName: `Test Normalized Name B` }, { name: `e`, normalizedName: `Test Normalized Name C` }, { name: `f`, normalizedName: `Test Normalized Name D` }], emote: `g`, normalizedEmote: `Test Normalized Emote` } })
    run(`a \t\t \t bcd \t       \t e\t \tand  \t \t f \t\t \t arE \t \t g`, { a: `Test Normalized Name A`, bcd: `Test Normalized Name B`, e: `Test Normalized Name C`, f: `Test Normalized Name D`, g: `Test Normalized Emote` }, { emote: { characters: [{ name: `a`, normalizedName: `Test Normalized Name A` }, { name: `bcd`, normalizedName: `Test Normalized Name B` }, { name: `e`, normalizedName: `Test Normalized Name C` }, { name: `f`, normalizedName: `Test Normalized Name D` }], emote: `g`, normalizedEmote: `Test Normalized Emote` } })
    run(`a \t\t \t B \t       \t cDE\t \tand  \t \t f \t\t \t ARe \t \t g`, { a: `Test Normalized Name A`, B: `Test Normalized Name B`, cDE: `Test Normalized Name C`, f: `Test Normalized Name D`, g: `Test Normalized Emote` }, { emote: { characters: [{ name: `a`, normalizedName: `Test Normalized Name A` }, { name: `B`, normalizedName: `Test Normalized Name B` }, { name: `cDE`, normalizedName: `Test Normalized Name C` }, { name: `f`, normalizedName: `Test Normalized Name D` }], emote: `g`, normalizedEmote: `Test Normalized Emote` } })
    run(`a \t\t \t B \t       \t c\t \tand  \t \t DEf \t\t \t ArE \t \t g`, { a: `Test Normalized Name A`, B: `Test Normalized Name B`, c: `Test Normalized Name C`, DEf: `Test Normalized Name D`, g: `Test Normalized Emote` }, { emote: { characters: [{ name: `a`, normalizedName: `Test Normalized Name A` }, { name: `B`, normalizedName: `Test Normalized Name B` }, { name: `c`, normalizedName: `Test Normalized Name C` }, { name: `DEf`, normalizedName: `Test Normalized Name D` }], emote: `g`, normalizedEmote: `Test Normalized Emote` } })
    run(`a \t\t \t B \t       \t c\t \tand  \t \t d \t\t \t aRe \t \t EFG`, { a: `Test Normalized Name A`, B: `Test Normalized Name B`, c: `Test Normalized Name C`, d: `Test Normalized Name D`, EFG: `Test Normalized Emote` }, { emote: { characters: [{ name: `a`, normalizedName: `Test Normalized Name A` }, { name: `B`, normalizedName: `Test Normalized Name B` }, { name: `c`, normalizedName: `Test Normalized Name C` }, { name: `d`, normalizedName: `Test Normalized Name D` }], emote: `EFG`, normalizedEmote: `Test Normalized Emote` } })
  })
  describe(`leave`, () => {
    run(`a \t\t \t lEAvEs`, { a: `Test Normalized Name A` }, { leave: { characters: [{ name: `a`, normalizedName: `Test Normalized Name A` }] } })
    run(`aBc \t\t \t LEAVes`, { aBc: `Test Normalized Name A` }, { leave: { characters: [{ name: `aBc`, normalizedName: `Test Normalized Name A` }] } })
    run(`a \t\t \t leavES`, { a: `Test Normalized Name A` }, { leave: { characters: [{ name: `a`, normalizedName: `Test Normalized Name A` }] } })
    run(`a \t\t \t and  \t \t B \t\t \t LEavE`, { a: `Test Normalized Name A`, B: `Test Normalized Name B` }, { leave: { characters: [{ name: `a`, normalizedName: `Test Normalized Name A` }, { name: `B`, normalizedName: `Test Normalized Name B` }] } })
    run(`aBC \t\t \t and  \t \t D \t\t \t leAVe`, { aBC: `Test Normalized Name A`, D: `Test Normalized Name B` }, { leave: { characters: [{ name: `aBC`, normalizedName: `Test Normalized Name A` }, { name: `D`, normalizedName: `Test Normalized Name B` }] } })
    run(`a \t\t \t and  \t \t BcD \t\t \t leaVE`, { a: `Test Normalized Name A`, BcD: `Test Normalized Name B` }, { leave: { characters: [{ name: `a`, normalizedName: `Test Normalized Name A` }, { name: `BcD`, normalizedName: `Test Normalized Name B` }] } })
    run(`a \t\t \t B \t       \t and  \t \t C \t\t \t LEAve`, { a: `Test Normalized Name A`, B: `Test Normalized Name B`, C: `Test Normalized Name C` }, { leave: { characters: [{ name: `a`, normalizedName: `Test Normalized Name A` }, { name: `B`, normalizedName: `Test Normalized Name B` }, { name: `C`, normalizedName: `Test Normalized Name C` }] } })
    run(`aBC \t\t \t d \t       \t and  \t \t e \t\t \t leAVe`, { aBC: `Test Normalized Name A`, d: `Test Normalized Name B`, e: `Test Normalized Name C` }, { leave: { characters: [{ name: `aBC`, normalizedName: `Test Normalized Name A` }, { name: `d`, normalizedName: `Test Normalized Name B` }, { name: `e`, normalizedName: `Test Normalized Name C` }] } })
    run(`a \t\t \t bCd \t       \t and  \t \t e \t\t \t LEavE`, { a: `Test Normalized Name A`, bCd: `Test Normalized Name B`, e: `Test Normalized Name C` }, { leave: { characters: [{ name: `a`, normalizedName: `Test Normalized Name A` }, { name: `bCd`, normalizedName: `Test Normalized Name B` }, { name: `e`, normalizedName: `Test Normalized Name C` }] } })
    run(`a \t\t \t B \t       \t and  \t \t cdE \t\t \t LEAVE`, { a: `Test Normalized Name A`, B: `Test Normalized Name B`, cdE: `Test Normalized Name C` }, { leave: { characters: [{ name: `a`, normalizedName: `Test Normalized Name A` }, { name: `B`, normalizedName: `Test Normalized Name B` }, { name: `cdE`, normalizedName: `Test Normalized Name C` }] } })
    run(`a \t\t \t B \t       \t c\t \tand  \t \t d \t\t \t leave`, { a: `Test Normalized Name A`, B: `Test Normalized Name B`, c: `Test Normalized Name C`, d: `Test Normalized Name D` }, { leave: { characters: [{ name: `a`, normalizedName: `Test Normalized Name A` }, { name: `B`, normalizedName: `Test Normalized Name B` }, { name: `c`, normalizedName: `Test Normalized Name C` }, { name: `d`, normalizedName: `Test Normalized Name D` }] } })
    run(`ABC \t\t \t d \t       \t e\t \tand  \t \t f \t\t \t lEAVe`, { ABC: `Test Normalized Name A`, d: `Test Normalized Name B`, e: `Test Normalized Name C`, f: `Test Normalized Name D` }, { leave: { characters: [{ name: `ABC`, normalizedName: `Test Normalized Name A` }, { name: `d`, normalizedName: `Test Normalized Name B` }, { name: `e`, normalizedName: `Test Normalized Name C` }, { name: `f`, normalizedName: `Test Normalized Name D` }] } })
    run(`a \t\t \t bcd \t       \t e\t \tand  \t \t f \t\t \t LeavE`, { a: `Test Normalized Name A`, bcd: `Test Normalized Name B`, e: `Test Normalized Name C`, f: `Test Normalized Name D` }, { leave: { characters: [{ name: `a`, normalizedName: `Test Normalized Name A` }, { name: `bcd`, normalizedName: `Test Normalized Name B` }, { name: `e`, normalizedName: `Test Normalized Name C` }, { name: `f`, normalizedName: `Test Normalized Name D` }] } })
    run(`a \t\t \t B \t       \t cDE\t \tand  \t \t f \t\t \t LEAVE`, { a: `Test Normalized Name A`, B: `Test Normalized Name B`, cDE: `Test Normalized Name C`, f: `Test Normalized Name D` }, { leave: { characters: [{ name: `a`, normalizedName: `Test Normalized Name A` }, { name: `B`, normalizedName: `Test Normalized Name B` }, { name: `cDE`, normalizedName: `Test Normalized Name C` }, { name: `f`, normalizedName: `Test Normalized Name D` }] } })
    run(`a \t\t \t B \t       \t c\t \tand  \t \t DEf \t\t \t Leave`, { a: `Test Normalized Name A`, B: `Test Normalized Name B`, c: `Test Normalized Name C`, DEf: `Test Normalized Name D` }, { leave: { characters: [{ name: `a`, normalizedName: `Test Normalized Name A` }, { name: `B`, normalizedName: `Test Normalized Name B` }, { name: `c`, normalizedName: `Test Normalized Name C` }, { name: `DEf`, normalizedName: `Test Normalized Name D` }] } })
  })
  describe(`set`, () => {
    run(`sET \t \t\t a \t    \t B`, { a: `Test Normalized Flag`, B: `Test Normalized Value` }, { set: { flag: `a`, normalizedFlag: `Test Normalized Flag`, value: `B`, normalizedValue: `Test Normalized Value` } })
    run(`SEt \t \t\t ABc \t    \t b`, { ABc: `Test Normalized Flag`, b: `Test Normalized Value` }, { set: { flag: `ABc`, normalizedFlag: `Test Normalized Flag`, value: `b`, normalizedValue: `Test Normalized Value` } })
    run(`sEt \t \t\t a \t    \t bCd`, { a: `Test Normalized Flag`, bCd: `Test Normalized Value` }, { set: { flag: `a`, normalizedFlag: `Test Normalized Flag`, value: `bCd`, normalizedValue: `Test Normalized Value` } })
  })
  describe(`if`, () => {
    run(`IF \t \t\t a \t    \t B`, { a: `Test Normalized Flag`, B: `Test Normalized Value` }, { if: { flag: `a`, normalizedFlag: `Test Normalized Flag`, value: `B`, normalizedValue: `Test Normalized Value` } })
    run(`If \t \t\t ABc \t    \t b`, { ABc: `Test Normalized Flag`, b: `Test Normalized Value` }, { if: { flag: `ABc`, normalizedFlag: `Test Normalized Flag`, value: `b`, normalizedValue: `Test Normalized Value` } })
    run(`iF \t \t\t a \t    \t bCd`, { a: `Test Normalized Flag`, bCd: `Test Normalized Value` }, { if: { flag: `a`, normalizedFlag: `Test Normalized Flag`, value: `bCd`, normalizedValue: `Test Normalized Value` } })
  })
  describe(`else if`, () => {
    run(`elSE \t   \t \t IF \t \t\t a \t    \t B`, { a: `Test Normalized Flag`, B: `Test Normalized Value` }, { elseIf: { flag: `a`, normalizedFlag: `Test Normalized Flag`, value: `B`, normalizedValue: `Test Normalized Value` } })
    run(`ELse \t   \t \t If \t \t\t ABc \t    \t b`, { ABc: `Test Normalized Flag`, b: `Test Normalized Value` }, { elseIf: { flag: `ABc`, normalizedFlag: `Test Normalized Flag`, value: `b`, normalizedValue: `Test Normalized Value` } })
    run(`eLSe \t   \t \t iF \t \t\t a \t    \t bCd`, { a: `Test Normalized Flag`, bCd: `Test Normalized Value` }, { elseIf: { flag: `a`, normalizedFlag: `Test Normalized Flag`, value: `bCd`, normalizedValue: `Test Normalized Value` } })
  })
  describe(`else`, () => {
    run(`elSE`, {}, { else: {} })
  })
  describe(`menu`, () => {
    run(`mENu`, {}, { menu: {} })
  })
  describe(`label`, () => {
    run(`LABel \t\t \ta`, { a: `Test Normalized Name` }, { label: { name: `a`, normalizedName: `Test Normalized Name` } })
    run(`lABEl \t\t \tABc`, { ABc: `Test Normalized Name` }, { label: { name: `ABc`, normalizedName: `Test Normalized Name` } })
  })
  describe(`go to`, () => {
    run(`gO\t\t \ttO \t\t \ta`, { a: `Test Normalized Label` }, { goTo: { label: `a`, normalizedLabel: `Test Normalized Label` } })
    run(`GO\t\t \tTo \t\t \tABc`, { ABc: `Test Normalized Label` }, { goTo: { label: `ABc`, normalizedLabel: `Test Normalized Label` } })
  })
  describe(`in background`, () => {
    run(`a\t\t \tIn \t\t \tBACKGRound`, { a: `Test Normalized Name` }, { background: { name: `a`, normalizedName: `Test Normalized Name` } })
    run(`ABc\t\t \tiN \t\t \tbaCKgrOUND`, { ABc: `Test Normalized Name` }, { background: { name: `ABc`, normalizedName: `Test Normalized Name` } })
  })
  describe(`include`, () => {
    run(`INcludE \t\t \ta`, { a: `Test Normalized Name` }, { include: { name: `a`, normalizedName: `Test Normalized Name` } })
    run(`inCLUDe \t\t \tABc`, { ABc: `Test Normalized Name` }, { include: { name: `ABc`, normalizedName: `Test Normalized Name` } })
  })
})

describe(`indenterEndOfFile`, () => {
  const onLine = jasmine.createSpy(`onLine`)
  const onIndent = jasmine.createSpy(`onIndent`)
  const onOutdent = jasmine.createSpy(`onOutdent`)
  const onError = jasmine.createSpy(`onError`)
  const onEndOfFile = jasmine.createSpy(`onEndOfFile`)
  let numberOfOnOutdentCallsAtTimeOfCallingOnLine
  onEndOfFile.and.callFake(() => {
    numberOfOnOutdentCallsAtTimeOfCallingOnLine = onOutdent.calls.count()
  })
  afterEach(() => {
    onLine.calls.reset()
    onIndent.calls.reset()
    onOutdent.calls.reset()
    onError.calls.reset()
    onEndOfFile.calls.reset()
  })
  let indenter
  beforeEach(() => indenter = {
    context: `Test Context`,
    onLine,
    onIndent,
    onOutdent,
    onError,
    onEndOfFile
  })

  describe(`when there is not an indentation character`, () => {
    beforeEach(() => {
      indenter.stack = [0]
      indenter.indentationCharacter = null
      get(`indenterEndOfFile`)(indenter)
    })
    it(`does not call onLine`, () => expect(onLine).not.toHaveBeenCalled())
    it(`does not call onIndent`, () => expect(onIndent).not.toHaveBeenCalled())
    it(`does not call onOutdent`, () => expect(onOutdent).not.toHaveBeenCalled())
    it(`does not call onError`, () => expect(onError).not.toHaveBeenCalled())
    it(`calls onEndOfFile once`, () => expect(onEndOfFile).toHaveBeenCalledTimes(1))
    it(`calls onEndOfFile with the context`, () => expect(onEndOfFile).toHaveBeenCalledWith(`Test Context`))
  })

  describe(`when there is an indentation character`, () => {
    beforeEach(() => {
      indenter.stack = [0, 24, 33, 51, 78]
      indenter.indentationCharacter = `Test Indentation Character`
      get(`indenterEndOfFile`)(indenter)
    })
    it(`does not call onLine`, () => expect(onLine).not.toHaveBeenCalled())
    it(`does not call onIndent`, () => expect(onIndent).not.toHaveBeenCalled())
    it(`calls onOutdent once per stack level`, () => expect(onOutdent).toHaveBeenCalledTimes(4))
    it(`calls onOutdent with the context`, () => {
      expect(onOutdent.calls.argsFor(0)).toEqual([`Test Context`])
      expect(onOutdent.calls.argsFor(1)).toEqual([`Test Context`])
      expect(onOutdent.calls.argsFor(2)).toEqual([`Test Context`])
      expect(onOutdent.calls.argsFor(3)).toEqual([`Test Context`])
    })
    it(`does not call onError`, () => expect(onError).not.toHaveBeenCalled())
    it(`calls onEndOfFile once`, () => expect(onEndOfFile).toHaveBeenCalledTimes(1))
    it(`calls onEndOfFile with the context`, () => expect(onEndOfFile).toHaveBeenCalledWith(`Test Context`))
    it(`calls onOutdent before onEndOfFile`, () => expect(numberOfOnOutdentCallsAtTimeOfCallingOnLine).toEqual(4))
  })
})

describe(`create`, () => {
  const linerCreate = setSpy(`linerCreate`)
  linerCreate.and.returnValue(`Test Liner`)
  const indenterCreate = setSpy(`indenterCreate`)
  indenterCreate.and.returnValue(`Test Indenter`)
  const indenterLine = setSpy(`indenterLine`)
  const indenterEndOfFile = setSpy(`indenterEndOfFile`)
  afterEach(() => {
    linerCreate.calls.reset()
    indenterCreate.calls.reset()
    indenterLine.calls.reset()
    indenterEndOfFile.calls.reset()
  })
  let result
  beforeEach(() => result = index.create(`Test Context`, `Test On Line`, `Test On Indent`, `Test On Outdent`, `Test On Error`, `Test On End Of File`))
  it(`creates one liner`, () => expect(linerCreate).toHaveBeenCalledTimes(1))
  it(`creates the liner using the indenter`, () => expect(linerCreate).toHaveBeenCalledWith(`Test Indenter`, jasmine.anything(), jasmine.anything()))
  it(`creates the liner using indenterLine`, () => expect(linerCreate).toHaveBeenCalledWith(jasmine.anything(), indenterLine, jasmine.anything()))
  it(`creates the liner using indenterEndOfFile`, () => expect(linerCreate).toHaveBeenCalledWith(jasmine.anything(), jasmine.anything(), indenterEndOfFile))
  it(`creates one indenter`, () => expect(indenterCreate).toHaveBeenCalledTimes(1))
  it(`creates the indenter using the context`, () => expect(indenterCreate).toHaveBeenCalledWith(`Test Context`, jasmine.anything(), jasmine.anything(), jasmine.anything(), jasmine.anything(), jasmine.anything()))
  it(`creates the indenter using the onLine`, () => expect(indenterCreate).toHaveBeenCalledWith(jasmine.anything(), `Test On Line`, jasmine.anything(), jasmine.anything(), jasmine.anything(), jasmine.anything()))
  it(`creates the indenter using the onIndent`, () => expect(indenterCreate).toHaveBeenCalledWith(jasmine.anything(), jasmine.anything(), `Test On Indent`, jasmine.anything(), jasmine.anything(), jasmine.anything()))
  it(`creates the indenter using the onOutdent`, () => expect(indenterCreate).toHaveBeenCalledWith(jasmine.anything(), jasmine.anything(), jasmine.anything(), `Test On Outdent`, jasmine.anything(), jasmine.anything()))
  it(`creates the indenter using the onError`, () => expect(indenterCreate).toHaveBeenCalledWith(jasmine.anything(), jasmine.anything(), jasmine.anything(), jasmine.anything(), `Test On Error`, jasmine.anything()))
  it(`creates the indenter using the onEndOfFile`, () => expect(indenterCreate).toHaveBeenCalledWith(jasmine.anything(), jasmine.anything(), jasmine.anything(), jasmine.anything(), jasmine.anything(), `Test On End Of File`))
  it(`returns an object`, () => expect(result).toEqual(jasmine.any(Object)))
  it(`returns state, "waiting"`, () => expect(result.state).toEqual("waiting"))
  it(`returns the liner`, () => expect(result.liner).toEqual(`Test Liner`))
})

describe(`character`, () => {
  const linerCharacter = setSpy(`linerCharacter`)
  afterEach(() => linerCharacter.calls.reset())
  let stateAtTimeOfCallingLinerCharacter
  let linerAtTimeOfCallingLinerCharacter
  let state
  beforeEach(() => state = {
    liner: `Test Liner`
  })

  describe(`when in state "waiting"`, () => {
    beforeEach(() => state.state = `waiting`)
    describe(`when no error occurs`, () => {
      beforeEach(() => {
        linerCharacter.and.callFake(() => {
          stateAtTimeOfCallingLinerCharacter = state.state
          linerAtTimeOfCallingLinerCharacter = state.liner
        })
        index.character(state, `Test Character`)
      })
      it(`passes one character to the liner`, () => expect(linerCharacter).toHaveBeenCalledTimes(1))
      it(`passes the liner context to the liner`, () => expect(linerCharacter).toHaveBeenCalledWith(`Test Liner`, jasmine.anything()))
      it(`passes the given character to the liner`, () => expect(linerCharacter).toHaveBeenCalledWith(jasmine.anything(), `Test Character`))
      it(`set the state to "processing" while the liner ran`, () => expect(stateAtTimeOfCallingLinerCharacter).toEqual(`processing`))
      it(`did not change the liner context while the liner ran`, () => expect(linerAtTimeOfCallingLinerCharacter).toEqual(`Test Liner`))
      it(`resets the state to "waiting"`, () => expect(state.state).toEqual(`waiting`))
      it(`does not change the liner context`, () => expect(state.liner).toEqual(`Test Liner`))
    })
    describe(`when an error is thrown`, () => {
      beforeEach(() => linerCharacter.and.callFake(() => {
        stateAtTimeOfCallingLinerCharacter = state.state
        linerAtTimeOfCallingLinerCharacter = state.liner
        throw new Error(`Test Error`)
      }))
      it(`rethrows the error`, () => expect(() => index.character(state, `Test Character`)).toThrowError(`Test Error`))
      describe(`side effects`, () => {
        beforeEach(() => {
          try {
            index.character(state, `Test Character`)
          } catch { }
        })
        it(`passes one character to the liner`, () => expect(linerCharacter).toHaveBeenCalledTimes(1))
        it(`passes the liner context to the liner`, () => expect(linerCharacter).toHaveBeenCalledWith(`Test Liner`, jasmine.anything()))
        it(`passes the given character to the liner`, () => expect(linerCharacter).toHaveBeenCalledWith(jasmine.anything(), `Test Character`))
        it(`set the state to "processing" while the liner ran`, () => expect(stateAtTimeOfCallingLinerCharacter).toEqual(`processing`))
        it(`did not change the liner context while the liner ran`, () => expect(linerAtTimeOfCallingLinerCharacter).toEqual(`Test Liner`))
        it(`sets the state to "error"`, () => expect(state.state).toEqual(`error`))
        it(`does not change the liner context`, () => expect(state.liner).toEqual(`Test Liner`))
      })
    })
    describe(`when called recursively`, () => {
      beforeEach(() => linerCharacter.and.callFake(() => {
        stateAtTimeOfCallingLinerCharacter = state.state
        linerAtTimeOfCallingLinerCharacter = state.liner
        state.state = `error`
        throw new Error(`Test Error`)
      }))
      it(`rethrows the error`, () => expect(() => index.character(state, `Test Character`)).toThrowError(`Test Error`))
      describe(`side effects`, () => {
        beforeEach(() => {
          try {
            index.character(state, `Test Character`)
          } catch { }
        })
        it(`passes one character to the liner`, () => expect(linerCharacter).toHaveBeenCalledTimes(1))
        it(`passes the liner context to the liner`, () => expect(linerCharacter).toHaveBeenCalledWith(`Test Liner`, jasmine.anything()))
        it(`passes the given character to the liner`, () => expect(linerCharacter).toHaveBeenCalledWith(jasmine.anything(), `Test Character`))
        it(`set the state to "processing" while the liner ran`, () => expect(stateAtTimeOfCallingLinerCharacter).toEqual(`processing`))
        it(`did not change the liner context while the liner ran`, () => expect(linerAtTimeOfCallingLinerCharacter).toEqual(`Test Liner`))
        it(`leaves the state as "error"`, () => expect(state.state).toEqual(`error`))
        it(`does not change the liner context`, () => expect(state.liner).toEqual(`Test Liner`))
      })
    })
    describe(`when called recusively and the error is swallowed`, () => {
      beforeEach(() => {
        linerCharacter.and.callFake(() => {
          stateAtTimeOfCallingLinerCharacter = state.state
          linerAtTimeOfCallingLinerCharacter = state.liner
          state.state = `error`
        })
        index.character(state, `Test Character`)
      })
      it(`passes one character to the liner`, () => expect(linerCharacter).toHaveBeenCalledTimes(1))
      it(`passes the liner context to the liner`, () => expect(linerCharacter).toHaveBeenCalledWith(`Test Liner`, jasmine.anything()))
      it(`passes the given character to the liner`, () => expect(linerCharacter).toHaveBeenCalledWith(jasmine.anything(), `Test Character`))
      it(`set the state to "processing" while the liner ran`, () => expect(stateAtTimeOfCallingLinerCharacter).toEqual(`processing`))
      it(`did not change the liner context while the liner ran`, () => expect(linerAtTimeOfCallingLinerCharacter).toEqual(`Test Liner`))
      it(`leaves the state as "error"`, () => expect(state.state).toEqual(`error`))
      it(`does not change the liner context`, () => expect(state.liner).toEqual(`Test Liner`))
    })
  })

  describe(`when in state "processing"`, () => {
    beforeEach(() => state.state = `processing`)
    it(`throws an error`, () => expect(() => index.character(state, `Test Character`)).toThrowError(`Cannot append characters recursively`))
    describe(`side effects`, () => {
      beforeEach(() => {
        try {
          index.character(state, `Test Character`)
        } catch { }
      })
      it(`does not pass a character to the liner`, () => expect(linerCharacter).not.toHaveBeenCalled())
      it(`changes state to "error"`, () => expect(state.state).toEqual("error"))
      it(`does not change the liner context`, () => expect(state.liner).toEqual(`Test Liner`))
    })
  })

  describe(`when in state "endOfFile"`, () => {
    beforeEach(() => state.state = `endOfFile`)
    it(`throws an error`, () => expect(() => index.character(state, `Test Character`)).toThrowError(`Cannot append characters after the end of the file`))
    describe(`side effects`, () => {
      beforeEach(() => {
        try {
          index.character(state, `Test Character`)
        } catch { }
      })
      it(`does not pass a character to the liner`, () => expect(linerCharacter).not.toHaveBeenCalled())
      it(`does not change state`, () => expect(state.state).toEqual("endOfFile"))
      it(`does not change the liner context`, () => expect(state.liner).toEqual(`Test Liner`))
    })
  })

  describe(`when in state "error"`, () => {
    beforeEach(() => state.state = `error`)
    it(`throws an error`, () => expect(() => index.character(state, `Test Character`)).toThrowError(`Cannot append characters after an error has occurred`))
    describe(`side effects`, () => {
      beforeEach(() => {
        try {
          index.character(state, `Test Character`)
        } catch { }
      })
      it(`does not pass a character to the liner`, () => expect(linerCharacter).not.toHaveBeenCalled())
      it(`does not change state`, () => expect(state.state).toEqual("error"))
      it(`does not change the liner context`, () => expect(state.liner).toEqual(`Test Liner`))
    })
  })
})

describe(`text`, () => {
  const character = setSpy(`character`)
  afterEach(() => character.calls.reset())
  describe(`when no error is thrown`, () => {
    beforeEach(() => {
      character.and.stub()
      index.text(`Test State`, `Test ðŸ’© Text`)
    })
    it(`calls character once per character of the given text`, () => expect(character).toHaveBeenCalledTimes(11))
    it(`passes the given state to character`, () => {
      expect(character.calls.argsFor(0)).toEqual([`Test State`, jasmine.anything()])
      expect(character.calls.argsFor(1)).toEqual([`Test State`, jasmine.anything()])
      expect(character.calls.argsFor(2)).toEqual([`Test State`, jasmine.anything()])
      expect(character.calls.argsFor(3)).toEqual([`Test State`, jasmine.anything()])
      expect(character.calls.argsFor(4)).toEqual([`Test State`, jasmine.anything()])
      expect(character.calls.argsFor(5)).toEqual([`Test State`, jasmine.anything()])
      expect(character.calls.argsFor(6)).toEqual([`Test State`, jasmine.anything()])
      expect(character.calls.argsFor(7)).toEqual([`Test State`, jasmine.anything()])
      expect(character.calls.argsFor(8)).toEqual([`Test State`, jasmine.anything()])
      expect(character.calls.argsFor(9)).toEqual([`Test State`, jasmine.anything()])
      expect(character.calls.argsFor(10)).toEqual([`Test State`, jasmine.anything()])
    })
    it(`passes the characters of the given text to character, in order`, () => {
      expect(character.calls.argsFor(0)).toEqual([jasmine.anything(), `T`])
      expect(character.calls.argsFor(1)).toEqual([jasmine.anything(), `e`])
      expect(character.calls.argsFor(2)).toEqual([jasmine.anything(), `s`])
      expect(character.calls.argsFor(3)).toEqual([jasmine.anything(), `t`])
      expect(character.calls.argsFor(4)).toEqual([jasmine.anything(), ` `])
      expect(character.calls.argsFor(5)).toEqual([jasmine.anything(), `ðŸ’©`])
      expect(character.calls.argsFor(6)).toEqual([jasmine.anything(), ` `])
      expect(character.calls.argsFor(7)).toEqual([jasmine.anything(), `T`])
      expect(character.calls.argsFor(8)).toEqual([jasmine.anything(), `e`])
      expect(character.calls.argsFor(9)).toEqual([jasmine.anything(), `x`])
      expect(character.calls.argsFor(10)).toEqual([jasmine.anything(), `t`])
    })
  })
})

describe(`endOfFile`, () => {
  const linerEndOfFile = setSpy(`linerEndOfFile`)
  afterEach(() => linerEndOfFile.calls.reset())
  let stateAtTimeOfCallingLinerEndOfFile
  let linerAtTimeOfCallingLinerEndOfFile
  let state
  beforeEach(() => state = {
    liner: `Test Liner`
  })

  describe(`when in state "waiting"`, () => {
    beforeEach(() => state.state = `waiting`)
    describe(`when no error occurs`, () => {
      beforeEach(() => {
        linerEndOfFile.and.callFake(() => {
          stateAtTimeOfCallingLinerEndOfFile = state.state
          linerAtTimeOfCallingLinerEndOfFile = state.liner
        })
        index.endOfFile(state)
      })
      it(`calls linerEndOfFile once`, () => expect(linerEndOfFile).toHaveBeenCalledTimes(1))
      it(`passes the liner context to the liner`, () => expect(linerEndOfFile).toHaveBeenCalledWith(`Test Liner`))
      it(`set the state to "processing" while the liner ran`, () => expect(stateAtTimeOfCallingLinerEndOfFile).toEqual(`processing`))
      it(`did not change the liner context while the liner ran`, () => expect(linerAtTimeOfCallingLinerEndOfFile).toEqual(`Test Liner`))
      it(`resets the state to "waiting"`, () => expect(state.state).toEqual(`waiting`))
      it(`does not change the liner context`, () => expect(state.liner).toEqual(`Test Liner`))
    })
    describe(`when an error is thrown`, () => {
      beforeEach(() => linerEndOfFile.and.callFake(() => {
        stateAtTimeOfCallingLinerEndOfFile = state.state
        linerAtTimeOfCallingLinerEndOfFile = state.liner
        throw new Error(`Test Error`)
      }))
      it(`rethrows the error`, () => expect(() => index.endOfFile(state)).toThrowError(`Test Error`))
      describe(`side effects`, () => {
        beforeEach(() => {
          try {
            index.endOfFile(state)
          } catch { }
        })
        it(`calls linerEndOfFile once`, () => expect(linerEndOfFile).toHaveBeenCalledTimes(1))
        it(`passes the liner context to the liner`, () => expect(linerEndOfFile).toHaveBeenCalledWith(`Test Liner`))
        it(`set the state to "processing" while the liner ran`, () => expect(stateAtTimeOfCallingLinerEndOfFile).toEqual(`processing`))
        it(`did not change the liner context while the liner ran`, () => expect(linerAtTimeOfCallingLinerEndOfFile).toEqual(`Test Liner`))
        it(`sets the state to "error"`, () => expect(state.state).toEqual(`error`))
        it(`does not change the liner context`, () => expect(state.liner).toEqual(`Test Liner`))
      })
    })
    describe(`when called recursively`, () => {
      beforeEach(() => linerEndOfFile.and.callFake(() => {
        stateAtTimeOfCallingLinerEndOfFile = state.state
        linerAtTimeOfCallingLinerEndOfFile = state.liner
        state.state = `error`
        throw new Error(`Test Error`)
      }))
      it(`rethrows the error`, () => expect(() => index.endOfFile(state)).toThrowError(`Test Error`))
      describe(`side effects`, () => {
        beforeEach(() => {
          try {
            index.endOfFile(state)
          } catch { }
        })
        it(`calls linerEndOfFile once`, () => expect(linerEndOfFile).toHaveBeenCalledTimes(1))
        it(`passes the liner context to the liner`, () => expect(linerEndOfFile).toHaveBeenCalledWith(`Test Liner`))
        it(`set the state to "processing" while the liner ran`, () => expect(stateAtTimeOfCallingLinerEndOfFile).toEqual(`processing`))
        it(`did not change the liner context while the liner ran`, () => expect(linerAtTimeOfCallingLinerEndOfFile).toEqual(`Test Liner`))
        it(`leaves the state as "error"`, () => expect(state.state).toEqual(`error`))
        it(`does not change the liner context`, () => expect(state.liner).toEqual(`Test Liner`))
      })
    })
    describe(`when called recusively and the error is swallowed`, () => {
      beforeEach(() => {
        linerEndOfFile.and.callFake(() => {
          stateAtTimeOfCallingLinerEndOfFile = state.state
          linerAtTimeOfCallingLinerEndOfFile = state.liner
          state.state = `error`
        })
        index.endOfFile(state)
      })
      it(`calls linerEndOfFile once`, () => expect(linerEndOfFile).toHaveBeenCalledTimes(1))
      it(`passes the liner context to the liner`, () => expect(linerEndOfFile).toHaveBeenCalledWith(`Test Liner`))
      it(`set the state to "processing" while the liner ran`, () => expect(stateAtTimeOfCallingLinerEndOfFile).toEqual(`processing`))
      it(`did not change the liner context while the liner ran`, () => expect(linerAtTimeOfCallingLinerEndOfFile).toEqual(`Test Liner`))
      it(`leaves the state as "error"`, () => expect(state.state).toEqual(`error`))
      it(`does not change the liner context`, () => expect(state.liner).toEqual(`Test Liner`))
    })
  })

  describe(`when in state "processing"`, () => {
    beforeEach(() => state.state = `processing`)
    it(`throws an error`, () => expect(() => index.endOfFile(state)).toThrowError(`Cannot mark the end of the file recursively`))
    describe(`side effects`, () => {
      beforeEach(() => {
        try {
          index.endOfFile(state)
        } catch { }
      })
      it(`does call linerEndOfFile`, () => expect(linerEndOfFile).not.toHaveBeenCalled())
      it(`changes state to "error"`, () => expect(state.state).toEqual("error"))
      it(`does not change the liner context`, () => expect(state.liner).toEqual(`Test Liner`))
    })
  })

  describe(`when in state "endOfFile"`, () => {
    beforeEach(() => state.state = `endOfFile`)
    it(`throws an error`, () => expect(() => index.endOfFile(state)).toThrowError(`Cannot mark the end of the file after the end of the file`))
    describe(`side effects`, () => {
      beforeEach(() => {
        try {
          index.endOfFile(state)
        } catch { }
      })
      it(`does call linerEndOfFile`, () => expect(linerEndOfFile).not.toHaveBeenCalled())
      it(`does not change state`, () => expect(state.state).toEqual("endOfFile"))
      it(`does not change the liner context`, () => expect(state.liner).toEqual(`Test Liner`))
    })
  })

  describe(`when in state "error"`, () => {
    beforeEach(() => state.state = `error`)
    it(`throws an error`, () => expect(() => index.endOfFile(state)).toThrowError(`Cannot mark the end of the file after an error has occurred`))
    describe(`side effects`, () => {
      beforeEach(() => {
        try {
          index.endOfFile(state)
        } catch { }
      })
      it(`does call linerEndOfFile`, () => expect(linerEndOfFile).not.toHaveBeenCalled())
      it(`does not change state`, () => expect(state.state).toEqual("error"))
      it(`does not change the liner context`, () => expect(state.liner).toEqual(`Test Liner`))
    })
  })
})
